package knot.data.buffers

import java.nio.ByteOrder
import java.nio.channels.WritableByteChannel

object BufferOutput {
  def toArray(): BufferOutput = {
    toArray(8192)
  }

  def toArray(size: Int): BufferOutput = {
    new DefaultBufferOutput(OutputSink.toArray(size, ByteOrder.nativeOrder()))
  }

  def toChannel(channel: WritableByteChannel): BufferOutput = {
    toChannel(channel, 8192)
  }

  def toChannel(channel: WritableByteChannel, bufferSize: Int): BufferOutput = {
    new DefaultBufferOutput(OutputSink.toChannel(channel, bufferSize, ByteOrder.nativeOrder()))
  }
}

trait BufferOutput {

  def sink: OutputSink

  /**
    * bufer size
    *
    * @return buffer size
    */
  def size: Long

  def order: ByteOrder

  /**
    * get next write index of this buffer.
    *
    * @return next write index.
    */
  def writerIndex: Long

  def putByte(v: Byte): Unit

  def putBytes(src: Array[Byte], offset: Int, length: Int): Unit

  def putInt(v: Int): Unit

  def putShort(v: Short): Unit

  def putLong(v: Long): Unit

  def putFloat(v: Float): Unit

  def putDouble(v: Double): Unit

  /**
    * Flush this buffer. Call this before buffer read.
    */
  def flush(): Unit

  def close(): Unit
}
