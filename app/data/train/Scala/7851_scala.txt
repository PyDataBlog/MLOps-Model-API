package me.reminisce.stats.server

import java.util.concurrent.TimeUnit

import akka.actor._
import akka.event.LoggingAdapter
import akka.http.scaladsl.model.StatusCodes.{BadRequest, InternalServerError, NotFound}
import akka.http.scaladsl.server.Directives._
import akka.http.scaladsl.server._
import akka.pattern.ask
import akka.util.Timeout
import com.github.nscala_time.time.Imports._
import me.reminisce.database._
import me.reminisce.stats.inserting.InsertionService
import me.reminisce.stats.model.InsertionMessages._
import me.reminisce.stats.model.RetrievingMessages._
import me.reminisce.stats.model.StatsResults
import me.reminisce.stats.retrieving.RetrievingService
import me.reminisce.stats.server.GameEntities._
import me.reminisce.stats.server.domain.{RESTHandler, RestMessage}
import me.reminisce.stats.server.jsonserializer.JSONSupport
import reactivemongo.api.{DefaultDB, MongoConnection, MongoDriver}

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.Future
import scala.util.Try

object StatsService

/**
  * Defines a GameCreatorService with the handled routes.
  */
class StatsService(mongoHost: String, mongoDbName: String, system: ActorSystem) extends RESTHandler with JSONSupport {

  implicit val timeout: Timeout = Timeout(10L, TimeUnit.SECONDS)

  val driver = new MongoDriver
  val dbName: String = mongoDbName
  val dbConnection: MongoConnection = driver.connection(List(mongoHost))
  val log: LoggingAdapter = system.log

  val statsRoutes: Route = {

    path("insertEntity") {
      post {
        extract(_.request.headers)
        entity(as[RawGame]) {
          rawGame => {
            insertDB(Game.fromRaw(rawGame))
          }
        }
      }
    } ~ path("stats") {
      get {
        parameterSeq {
          params =>
            parseParameters(params) match {
              case Some(rs) =>
                log.info(s"Getting stats from ${rs.from} to ${rs.to} with limit ${rs.limit} for user ${rs.userID}.")
                retrieveStats(rs)
              case None =>
                log.error(s"Could not parse parameters.")
                complete(BadRequest, "Unknown or malformed request")
            }
        }
      }
    } ~ path("info") {
      get {
        parameters("unused" ? "") {
          //ugly fix
          (_: String) =>
            // IntelliJ does not manage to find the reference to BuildInfo which is a class generated by
            // the sbtBuildInfo package (https://github.com/sbt/sbt-buildinfo) at compile time but sbt finds it,
            // do not import what IntelliJ suggests to import
            complete(BuildInfo.toMap)
        }
      }
    }
  }

  def parseParameters(params: Seq[(String, String)]): Option[RetrieveStats] = {
    lazy val formatter = DateTimeFormat.forPattern("dd-MM-yyyy")

    val (userId, from, to, limit) = params.foldLeft(("", List[DateTime](), List[DateTime](), 0)) {
      case ((id, f, t, l), (key, value)) =>
        key match {
          case "userId" if id.isEmpty => (id + value, f, t, l)
          case "from" =>
            Try {
              val date = DateTime.parse(value, formatter)
              (id, f :+ date, t, l)
            }.fold(_ => (id, f, t, l), identity)
          case "to" =>
            Try {
              val date = DateTime.parse(value, formatter)
              (id, f, t :+ date, l)
            }.fold(_ => (id, f, t, l), identity)
          case "limit" =>
            (id, f, t, value.toInt)
          case _ => (id, f, t, l)
        }
    }
    val optFrom = from.headOption
    val optTo = to.headOption
    val optLimit = if (limit != 0) Some(limit) else None

    Some(RetrieveStats(userId, optFrom, optTo, optLimit))
  }

  private def insertDB(game: Game): Route = {
    handleWithDb {
      (db, ctx) =>
        val message = InsertEntity(game)
        val insertionService = system.actorOf(InsertionService.props(db))
        ctx.complete((insertionService ? message).mapTo[RestMessage])
    }
  }

  private def retrieveStats(message: RetrieveStats): Route = {
    handleWithDb {
      (db, ctx) =>
        val retrievingService = system.actorOf(RetrievingService.props(db))
        (retrievingService ? message).mapTo[StatsResults].flatMap {
          case UserNotFound(msg) =>
            ctx.complete(NotFound, msg)
          case retrieved: StatsRetrieved =>
            ctx.complete(retrieved)
        }
    }
  }

  private def handleWithDb(handler: (DefaultDB, RequestContext) => Future[RouteResult]): Route = {
    ctx =>
      routeWithDb(dbConnection, dbName) {
        db =>
          handler(db, ctx)
      } {
        e =>
          log.error(s"Could not reach database: ${e.getMessage}.")
          ctx.complete(InternalServerError, s"Could not reach database: ${e.getMessage}.")
      }
  }

  def terminate(): Unit = {
    dbConnection.close()
    driver.system.terminate()
    driver.close()
  }
}
