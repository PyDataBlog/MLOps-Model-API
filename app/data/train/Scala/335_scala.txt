package chapter22

import java.awt._
import java.awt.event._
import javax.swing._
import scala.util.continuations._

/*
The example in Section 22.8, “Undoing Inversion of Control,” on page 329 is a bit unsightly —
the application programmer sees the reset statement.

Move reset from the run method to the button listener.

Is the application programmer now blissfully unaware of continuations?
 */
object Exercise4 extends App {

  val frame = new JFrame

  val button = new JButton("Next")
  setListener(button) {
    reset { // MOVED
      run()
    }
  }

  val textField = new JTextArea(10, 40)
  textField.setEnabled(false)

  val label = new JLabel("Welcome to the demo app")

  frame.add(label, BorderLayout.NORTH)
  frame.add(textField)

  val panel = new JPanel
  panel.add(button)

  frame.add(panel, BorderLayout.SOUTH)
  frame.pack()
  frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE)
  frame.setVisible(true)

  def run() = {
    val response1 = getResponse("What is your first name?")
    val response2 = getResponse("What is your last name?")
    textField.setText("")
    textField.setEnabled(false)

    process(response1, response2)
  }

  def process(s1: String, s2: String) {
    label.setText("Hello, " + s1 + " " + s2)
  }

  var cont: Unit => Unit = null

  def getResponse(prompt: String): String@cps[Unit] = {
    label.setText(prompt)
    setListener(button) {cont(())}
    textField.setEnabled(true)
    textField.setText("")

    shift {
      k: (Unit => Unit) => {
        cont = k
      }
    }
    setListener(button) {}
    textField.getText
  }

  def setListener(button: JButton)(action: => Unit) {
    for (l <- button.getActionListeners) button.removeActionListener(l)
    button.addActionListener(new ActionListener {
      override def actionPerformed(event: ActionEvent) {
        action
      }
    })
  }
}
