/*
 * ============= Ryft-Customized BSD License ============
 * Copyright (c) 2015, Ryft Systems, Inc.
 * All rights reserved.
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software must display the following acknowledgement:
 *   This product includes software developed by Ryft Systems, Inc.
 * 4. Neither the name of Ryft Systems, Inc. nor the names of its contributors may be used
 *   to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY RYFT SYSTEMS, INC. ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL RYFT SYSTEMS, INC. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * ============
 */

package com.ryft.spark.connector.query.value

import com.ryft.spark.connector.domain.RyftValueOperator
import com.ryft.spark.connector.exception.RyftSparkException
import com.ryft.spark.connector.query.value.model.{FullParams, Params, ShortParams, Currency}
import org.apache.spark.Logging

/**
  * Implementation of Ryft currency search
  */
case class CurrencyValue(valueA: Option[Currency] = None,
    operatorA: Option[RyftValueOperator] = None,
    operatorB: RyftValueOperator,
    valueB: Currency,
    sign: String,
    subitizer: Option[String],
    decimal: String) extends RyftQueryValue {

  if (valueA.isDefined)
    require(valueA.get.isValid(subitizer.getOrElse(""), decimal), s"Currency ${valueA.get} is invalid")
  require(valueB.isValid(subitizer.getOrElse(""), decimal), s"Currency $valueB is invalid")

  if (subitizer.isDefined)
    require(subitizer.get != decimal, s"Subitizer and decimal must be different")

  override def toString: String = {
    val expression = if (valueA.isDefined && operatorA.isDefined) {
      s""""${valueA.get}" ${operatorA.get.value} CUR ${operatorB.value} "$valueB""""
    } else {
      s"""CUR ${operatorB.value} "$valueB""""
    }
    if (subitizer.isDefined) {
      s"""CURRENCY($expression, "$sign", "${subitizer.get}", "$decimal")"""
    } else {
      s"""CURRENCY($expression, "$sign", "", "$decimal")"""
    }
  }
}

object CurrencyValue extends Logging {
  def apply(operator: RyftValueOperator,
      value: Currency,
      sign: String,
      subitizer: Option[String],
      decimal: String) = new CurrencyValue(None, None, operator, value, sign, subitizer, decimal)

  def apply(valueA: Currency,
      operatorA: RyftValueOperator,
      operatorB: RyftValueOperator,
      valueB: Currency,
      sign: String,
      subitizer: Option[String],
      decimal: String) = new CurrencyValue(Some(valueA), Some(operatorA), operatorB, valueB, sign, subitizer, decimal)

  def apply(params: Params,
      sign: String,
      subitizer: Option[String],
      decimal: String): CurrencyValue = params match {
    case shortParams: ShortParams =>
      apply(shortParams.operator,
        shortParams.value.asInstanceOf[Currency],
        sign,
        subitizer,
        decimal)
    case fullParams: FullParams =>
      apply(fullParams.valueA.asInstanceOf[Currency],
        fullParams.operatorA,
        fullParams.operatorB,
        fullParams.valueB.asInstanceOf[Currency],
        sign,
        subitizer,
        decimal)
    case unknown =>
      val msg = s"Unknown query value parameters: $unknown"
      logWarning(msg)
      throw RyftSparkException(msg)
  }

  def apply(params: Params,
      sign: String,
      subitizer: String,
      decimal: String): CurrencyValue = apply(params, sign, Some(subitizer), decimal)

  def apply(params: Params,
      sign: String,
      decimal: String): CurrencyValue = apply(params, sign, None, decimal)
}
