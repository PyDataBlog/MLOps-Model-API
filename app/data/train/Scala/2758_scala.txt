package fr.ramiro.sfuzzy.dsl

import fr.ramiro.sfuzzy._
import org.scalatest.FunSuite
import MembershipFunctions.{ piecewiseLinear => l }

class TipperTest extends FunSuite {
  //noinspection TypeAnnotation
  case object food extends FuzzyVar {
    val rancid: FuzzyTerm = l((0, 1), (1, 1), (3, 0))
    val delicious: FuzzyTerm = l((7, 0), (9, 1))
  }

  //noinspection TypeAnnotation
  case object service extends FuzzyVar {
    val poor: FuzzyTerm = l((0, 1), (4, 0))
    val good: FuzzyTerm = l((1, 0), (4, 1), (6, 1), (9, 0))
    val excellent: FuzzyTerm = l((6, 0), (9, 1))
  }

  //noinspection TypeAnnotation
  case object tip extends DefuzzyVar {
    val cheap: DefuzzyTerm = l((0, 0), (5, 1), (10, 0))
    val average: DefuzzyTerm = l((10, 0), (15, 1), (20, 0))
    val generous: DefuzzyTerm = l((20, 0), (25, 1), (30, 0))

    val method = FunctionsUtils.cog(0, 30, 1e-2d)
    val default = 0
  }

  import food._
  import service._
  import tip._
  import FunctionsUtils._
  private implicit val fuzzyEvaluationEquality = Utils.tolerantFuzzyEvaluationTypeEquality(1e-2d)

  test("tipper") {
    assertDoesNotCompile("val rule0: FuzzyRule = Fuzzy IF service IS rancid")

    implicit val config = FuzzyConfiguration(
      andMethod = min,
      orMethod = max,
      activation = min,
      accumulation = max
    )
    import Rule._

    val fuzzyRules1 = FuzzyFunction(
      IF((service IS poor) OR (food IS rancid)) THEN (tip IS cheap),
      IF(service IS good) THEN (tip IS average),
      IF((service IS excellent) AND (food IS delicious)) THEN (tip IS generous)
    )

    val fuzzyRules2 = FuzzyFunction(
      IF((service IS poor) OR (food IS rancid)) THEN (tip IS cheap WITH 0.8),
      IF(service IS good) THEN (tip IS average WITH 0.5),
      IF((service IS excellent) AND (food IS delicious)) THEN (tip IS generous WITH 0.9)
    )

    for ((serviceValue, foodValue, expected) <- data.map { transformData }) {
      //val resultMap = fuzzyRules eval(service -> serviceValue, food -> foodValue)
      //assert(actual === expected)
    }
  }

  val data = Seq(
    (100, 100, 500),
    (100, 200, 500),
    (100, 300, 500),
    (100, 400, 500),
    (100, 500, 500),
    (100, 600, 500),
    (100, 700, 500),
    (100, 800, 500),
    (100, 900, 500),
    (100, 1000, 500),
    (200, 100, 857),
    (200, 200, 926),
    (200, 300, 926),
    (200, 400, 926),
    (200, 500, 926),
    (200, 600, 926),
    (200, 700, 926),
    (200, 800, 926),
    (200, 900, 926),
    (200, 1000, 926),
    (300, 100, 971),
    (300, 200, 1042),
    (300, 300, 1170),
    (300, 400, 1170),
    (300, 500, 1170),
    (300, 600, 1170),
    (300, 700, 1170),
    (300, 800, 1170),
    (300, 900, 1170),
    (300, 1000, 1170),
    (400, 100, 1000),
    (400, 200, 1071),
    (400, 300, 1500),
    (400, 400, 1500),
    (400, 500, 1500),
    (400, 600, 1500),
    (400, 700, 1500),
    (400, 800, 1500),
    (400, 900, 1500),
    (400, 1000, 1500),
    (500, 100, 1000),
    (500, 200, 1071),
    (500, 300, 1500),
    (500, 400, 1500),
    (500, 500, 1500),
    (500, 600, 1500),
    (500, 700, 1500),
    (500, 800, 1500),
    (500, 900, 1500),
    (500, 1000, 1500),
    (600, 100, 1000),
    (600, 200, 1071),
    (600, 300, 1500),
    (600, 400, 1500),
    (600, 500, 1500),
    (600, 600, 1500),
    (600, 700, 1500),
    (600, 800, 1500),
    (600, 900, 1500),
    (600, 1000, 1500),
    (700, 100, 990),
    (700, 200, 1061),
    (700, 300, 1500),
    (700, 400, 1500),
    (700, 500, 1500),
    (700, 600, 1500),
    (700, 700, 1500),
    (700, 800, 1867),
    (700, 900, 1867),
    (700, 1000, 1867),
    (800, 100, 957),
    (800, 200, 1028),
    (800, 300, 1500),
    (800, 400, 1500),
    (800, 500, 1500),
    (800, 600, 1500),
    (800, 700, 1500),
    (800, 800, 1972),
    (800, 900, 2014),
    (800, 1000, 2014),
    (900, 100, 890),
    (900, 200, 960),
    (900, 300, 1500),
    (900, 400, 1500),
    (900, 500, 1500),
    (900, 600, 1500),
    (900, 700, 1500),
    (900, 800, 2040),
    (900, 900, 2110),
    (900, 1000, 2110),
    (1000, 100, 765),
    (1000, 200, 824),
    (1000, 300, 1500),
    (1000, 400, 1500),
    (1000, 500, 1500),
    (1000, 600, 1500),
    (1000, 700, 1500),
    (1000, 800, 2176),
    (1000, 900, 2235),
    (1000, 1000, 2235)
  )

  private def transformData(line: (Int, Int, Int)) = line match {
    case (serviceValue, foodValue, expectedTip) =>
      val hundred: FuzzyEvaluationType = 100.0
      ((serviceValue: FuzzyEvaluationType) / hundred, (foodValue: FuzzyEvaluationType) / hundred, (expectedTip: FuzzyEvaluationType) / hundred)
  }
}
