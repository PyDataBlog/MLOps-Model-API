/*
 * Copyright 2013 Akiyoshi Sugiki, University of Tsukuba
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package kumoi.shell.ps

import kumoi.shell.aaa._
import kumoi.shell.aaa.ops._
import kumoi.shell.aaa.resource._
import kumoi.shell.cache._
import scala.actors._

//import kumoi.core.aaa.CA._


/**
 * 
 * @author Akiyoshi SUGIKI
 */
@proctype
trait ColdProcess extends Serializable {
	import ColdProcess._
	
	private var pname = "unnamed"
	@transient private var cont = true
	
	@invalidate(Array("name", "toString")) @nocache @update def name_=(n: String) { pname = n }
	@persistcache @read def name = pname 
	
	/**
	 * act() 
	 */
	@nocache @exec def act()
	@nocache @delete def exit() { cont = false }
	
	@persistcache @read override def toString = pname

	def loop(body: => Unit) = {	while (cont) { body } }
}

object ColdProcess {
	def receive(f: PartialFunction[Any, Unit]): Unit = { // TODO: [R]
		val t: PartialFunction[Any, Unit] = { 
			case SigTerm(reason) => Actor.exit(reason)
			case SigStop(reason) => Actor.exit(reason)
			case SigCont(reason) =>
		}
		Actor.receive(t orElse f)
	}
	
	def receiveWithin(msec: Long)(f: PartialFunction[Any, Unit]): Unit = { // TODO: [R]
		val t: PartialFunction[Any, Unit] = { 
		  	case SigTerm(reason) => Actor.exit(reason) 
			case SigStop(reason) => Actor.exit(reason)
			case SigCont(reason) =>
	  	}
	  	Actor.receiveWithin(msec)(t orElse f)
	}
	
	def react(handler: PartialFunction[Any, Unit]): Nothing = {
	  	val t: PartialFunction[Any, Unit] = { 
	  		case SigTerm(reason) => Actor.exit(reason) 
			case SigStop(reason) => Actor.exit(reason)
			case SigCont(reason) =>
	  	} 
	  	Actor.react(t orElse handler)
	}
	
	def reactWithin(msec: Long)(handler: PartialFunction[Any, Unit]): Nothing = {
	  	val t: PartialFunction[Any, Unit] = { 
	  		case SigTerm(reason) => Actor.exit(reason) 
			case SigStop(reason) => Actor.exit(reason)
			case SigCont(reason) =>
	  	} 
	  	Actor.reactWithin(msec)(t orElse handler)
	}
}