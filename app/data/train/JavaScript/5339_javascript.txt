// Idea and initial code from https://github.com/aomra015/ember-cli-chart
import Ember from 'ember';

export default Ember.Component.extend({
  tagName: 'canvas',
  attributeBindings: ['width', 'height'],

  onlyValues: false,
  chartData: {},

  didInsertElement: function(){
    var context = this.get('element').getContext('2d');
    var type = Ember.String.classify(this.get('type'));
    var options = {
      responsive: true,
      showTooltips: true,
      pointDot: true,
      pointDotRadius: 3,
      pointHitDetectionRadius: 8,
      bezierCurve: false,
      barValueSpacing: 1,
      datasetStrokeWidth: 3
    };

    // animation is very sexy, but it hogs browser. Waiting for chart.js 2.0
    // https://github.com/nnnick/Chart.js/issues/653
    options.animation = false;

    if (this.get("onlyValues")) {
      options.showScale = false;
    }

    var data = {labels: [], datasets: []};

    this.get("chartData.labels").forEach((l) => {
      data.labels.push(l);
    });
    this.get("chartData.datasets").forEach((ds) => {
      var dataSet = this._chartColors(ds.label);
      dataSet.data = ds.data.map((v) => { return v; });
      data.datasets.push(dataSet);
    });

    var chart = new Chart(context)[type](data, options);
    this.set('chart', chart);
  },

  willDestroyElement: function(){
    this.get('chart').destroy();
  },

  updateChart: function() {
    //// redraw
    // this.willDestroyElement();
    // this.didInsertElement();
    
    var chart = this.get("chart");

    while (chart.scale.xLabels.length && chart.scale.xLabels[0] !== this.get("chartData.labels")[0]) {
      chart.removeData();
    }

    this.get("chartData.labels").forEach((label, i) => {
      if (i < chart.scale.xLabels.length) {
        this.get("chartData.datasets").forEach((ds, j) => {
          if (this.get("type") === "Line") {
            chart.datasets[j].points[i].value = ds.data[i];
          } else {
            chart.datasets[j].bars[i].value = ds.data[i];
          }
        });
      } else {
        var values = [];
        this.get("chartData.datasets").forEach((ds) => {
          values.push(ds.data[i]);
        });
        chart.addData(values, label);
      }
    });
    chart.update();
  }.observes("chartData", "chartData.[]"),


  _chartColors: function(label) {
    if (label === "count") {
      return {
        fillColor: "rgba(151,187,205,1)",
        strokeColor: "rgba(151,187,205,1)"
      };
    } else {
      var base = {
        max: "203,46,255",
        up: "46,255,203",
        avg: "46,203,255",
        min: "46,98,255",
        sum: "98,56,255",
      }[label] || "151,187,205";
      return {
        fillColor: "rgba(" + base + ",0.03)",
        strokeColor: "rgba(" + base + ",0.5)",
        pointColor: "rgba(" + base + ",0.5)",
        // pointStrokeColor: "red", //"rgba(" + base + ")",
        // pointHighlightFill: "green", //"rgba(" + base + ")",
        // pointHighlightStroke: "blue",// "rgba(" + base + ")",
        // pointStrokeColor: "#fff",
        // pointHighlightFill: "#fff",
        // pointHighlightStroke: "rgba(220,220,220,1)",
      };
    }
  }
});
