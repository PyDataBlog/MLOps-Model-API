using System;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System.Collections.Generic;

namespace Bakalog.Tests
{
    [TestClass]
    public class BakalogTests
    {
        [TestMethod]
        public void SimpleTerms()
        {
            var p = new Bakalog();

            p.Def("parent", "John", "Peter");
            p.Def("parent", "John", "Lara");
            p.Def("brother", "Walter", "John");
            p.Def("brother", "John", "Walter");

            var C = (Variable)p.DefVar();
            var possibilities = p.Ask("parent", "John", C);

            Assert.AreEqual(2, possibilities.Count());
            Assert.IsTrue(possibilities.Any(d => d.ContainsKey(C) && d[C].Equals("Peter")));
            Assert.IsTrue(possibilities.Any(d => d.ContainsKey(C) && d[C].Equals("Lara")));
        }

        [TestMethod]
        public void Rules()
        {
            var p = new Bakalog();

            p.Def("parent", "John", "Peter");
            p.Def("parent", "John", "Lara");
            p.Def("brother", "Walter", "John");
            p.Def("brother", "John", "Walter");

            var X = p.DefVar();
            var Y = p.DefVar();
            var Z = p.DefVar();

            p.If(() => p.Ask("parent", Y, Z) && p.Ask("brother", X, Y)).Then("uncle", X, Z);

            var O = (Variable)p.DefVar();
            var possibilities = p.Ask("uncle", O, "Lara");

            Assert.AreEqual(1, possibilities.Count());
            Assert.AreEqual("Walter", possibilities.First()[O]);

            var N = (Variable)p.DefVar();
            possibilities = p.Ask("uncle", "Walter", N);

            Assert.AreEqual(2, possibilities.Count());
            Assert.IsTrue(possibilities.Any(d => d.ContainsKey(N) && d[N].Equals("Peter")));
            Assert.IsTrue(possibilities.Any(d => d.ContainsKey(N) && d[N].Equals("Lara")));
        }

        [TestMethod]
        public void RecursiveRules()
        {
            var p = new Bakalog();

            var X = p.DefVar();
            var Y = p.DefVar();
            var Z = p.DefVar();

            p.If("parent", X, Y).Then("ancestor", X, Y);
            p.If(() => p.Ask("parent", X, Z) && p.Ask("ancestor", Z, Y)).Then("ancestor", X, Y);

            p.Def("parent", "John", "Smith");
            p.Def("parent", "David", "John");
            p.Def("parent", "Chuck", "David");
            p.Def("parent", "Arnold", "Chuck");

            var A = p.DefVar();
            var possibilities = p.Ask("ancestor", A, "Smith");
            Assert.AreEqual(4, possibilities.Count());
            Assert.IsTrue(possibilities.Any(d => d.ContainsKey(A) && d[A].Equals("John")));
            Assert.IsTrue(possibilities.Any(d => d.ContainsKey(A) && d[A].Equals("David")));
            Assert.IsTrue(possibilities.Any(d => d.ContainsKey(A) && d[A].Equals("Chuck")));
            Assert.IsTrue(possibilities.Any(d => d.ContainsKey(A) && d[A].Equals("Arnold")));
        }

        [TestMethod]
        public void NegationRules()
        {
            var p = new Bakalog();

            p.Def("friend", "John", "Smith");

            var X = p.DefVar();
            var Y = p.DefVar();

            p.If(() => p.Permutations(X, Y) && !p.Ask("friend", X, Y) && !p.Ask("friend", Y, X)).Then("enemy", X, Y);

            var E = p.DefVar();
            var possibilities = p.Ask("enemy", E, "Hector");
            Assert.AreEqual(2, possibilities.Count());
            Assert.IsTrue(possibilities.Any(d => d.ContainsKey(E) && d[E].Equals("John")));
            Assert.IsTrue(possibilities.Any(d => d.ContainsKey(E) && d[E].Equals("Smith")));
        }

        [TestMethod]
        public void RuleWithValue()
        {
            var p = new Bakalog();

            p.Def("p", "a", "b");

            var X = p.DefVar();
            p.If(() => p.Ask("p", X, "b")).Then("test", X, "y");

            var D = p.DefVar();
            var E = p.DefVar();
            var possibilities = p.Ask("test", D, E).ToArray();
            Assert.IsTrue(possibilities.Any(d => d.ContainsKey(D) && d[D].Equals("a") && d.ContainsKey(E) && d[E].Equals("y")));
        }

        [TestMethod]
        public void SelfNegationRule()
        {
            var p = new Bakalog();

            p.Def("p", "a", "b");
            p.Def("p", "b", "c");
            p.Def("p", "b", "c");
            p.Def("p", "c", "d");

            var X = p.DefVar();
            var Y = p.DefVar();

            X.Name = "X";
            Y.Name = "Y";

            p.If(() => p.Ask("p", X, Y) && !p.Ask("distinct", X)).Then("distinct", X);
            p.If(() => p.Ask("p", X, Y) && !p.Ask("distinct", Y)).Then("distinct", Y);

            var D = p.DefVar();
            var possibilities = p.Ask("distinct", D).ToArray();
            Assert.AreEqual(4, possibilities.Count());
            Assert.IsTrue(possibilities.Any(d => d.ContainsKey(D) && d[D].Equals("a")));
            Assert.IsTrue(possibilities.Any(d => d.ContainsKey(D) && d[D].Equals("b")));
            Assert.IsTrue(possibilities.Any(d => d.ContainsKey(D) && d[D].Equals("c")));
            Assert.IsTrue(possibilities.Any(d => d.ContainsKey(D) && d[D].Equals("d")));
        }
    }
}
