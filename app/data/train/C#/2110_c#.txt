// Decompiled with JetBrains decompiler
// Type: System.Net.Cache.MetadataUpdateStream
// Assembly: System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089
// MVID: 5ABD58FD-DF31-44FD-A492-63F2B47CC9AF
// Assembly location: C:\Windows\Microsoft.NET\Framework\v4.0.30319\System.dll

using System;
using System.Collections.Specialized;
using System.IO;
using System.Net;
using System.Runtime;
using System.Threading;

namespace System.Net.Cache
{
  internal class MetadataUpdateStream : BaseWrapperStream, ICloseEx
  {
    private RequestCache m_Cache;
    private string m_Key;
    private DateTime m_Expires;
    private DateTime m_LastModified;
    private DateTime m_LastSynchronized;
    private TimeSpan m_MaxStale;
    private StringCollection m_EntryMetadata;
    private StringCollection m_SystemMetadata;
    private bool m_CacheDestroy;
    private bool m_IsStrictCacheErrors;
    private int _Disposed;

    public override bool CanRead
    {
      get
      {
        return this.WrappedStream.CanRead;
      }
    }

    public override bool CanSeek
    {
      get
      {
        return this.WrappedStream.CanSeek;
      }
    }

    public override bool CanWrite
    {
      get
      {
        return this.WrappedStream.CanWrite;
      }
    }

    public override long Length
    {
      get
      {
        return this.WrappedStream.Length;
      }
    }

    public override long Position
    {
      get
      {
        return this.WrappedStream.Position;
      }
      set
      {
        this.WrappedStream.Position = value;
      }
    }

    public override bool CanTimeout
    {
      get
      {
        return this.WrappedStream.CanTimeout;
      }
    }

    public override int ReadTimeout
    {
      get
      {
        return this.WrappedStream.ReadTimeout;
      }
      set
      {
        this.WrappedStream.ReadTimeout = value;
      }
    }

    public override int WriteTimeout
    {
      get
      {
        return this.WrappedStream.WriteTimeout;
      }
      set
      {
        this.WrappedStream.WriteTimeout = value;
      }
    }

    [TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
    internal MetadataUpdateStream(Stream parentStream, RequestCache cache, string key, DateTime expiresGMT, DateTime lastModifiedGMT, DateTime lastSynchronizedGMT, TimeSpan maxStale, StringCollection entryMetadata, StringCollection systemMetadata, bool isStrictCacheErrors)
      : base(parentStream)
    {
      this.m_Cache = cache;
      this.m_Key = key;
      this.m_Expires = expiresGMT;
      this.m_LastModified = lastModifiedGMT;
      this.m_LastSynchronized = lastSynchronizedGMT;
      this.m_MaxStale = maxStale;
      this.m_EntryMetadata = entryMetadata;
      this.m_SystemMetadata = systemMetadata;
      this.m_IsStrictCacheErrors = isStrictCacheErrors;
    }

    private MetadataUpdateStream(Stream parentStream, RequestCache cache, string key, bool isStrictCacheErrors)
      : base(parentStream)
    {
      this.m_Cache = cache;
      this.m_Key = key;
      this.m_CacheDestroy = true;
      this.m_IsStrictCacheErrors = isStrictCacheErrors;
    }

    public override long Seek(long offset, SeekOrigin origin)
    {
      return this.WrappedStream.Seek(offset, origin);
    }

    public override void SetLength(long value)
    {
      this.WrappedStream.SetLength(value);
    }

    public override void Write(byte[] buffer, int offset, int count)
    {
      this.WrappedStream.Write(buffer, offset, count);
    }

    public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
    {
      return this.WrappedStream.BeginWrite(buffer, offset, count, callback, state);
    }

    public override void EndWrite(IAsyncResult asyncResult)
    {
      this.WrappedStream.EndWrite(asyncResult);
    }

    public override void Flush()
    {
      this.WrappedStream.Flush();
    }

    public override int Read(byte[] buffer, int offset, int count)
    {
      return this.WrappedStream.Read(buffer, offset, count);
    }

    public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
    {
      return this.WrappedStream.BeginRead(buffer, offset, count, callback, state);
    }

    public override int EndRead(IAsyncResult asyncResult)
    {
      return this.WrappedStream.EndRead(asyncResult);
    }

    [TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
    protected override sealed void Dispose(bool disposing)
    {
      this.Dispose(disposing, CloseExState.Normal);
    }

    [TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
    void ICloseEx.CloseEx(CloseExState closeState)
    {
      this.Dispose(true, closeState);
    }

    protected virtual void Dispose(bool disposing, CloseExState closeState)
    {
      try
      {
        if (Interlocked.Increment(ref this._Disposed) != 1 || !disposing)
          return;
        ICloseEx closeEx = this.WrappedStream as ICloseEx;
        if (closeEx != null)
          closeEx.CloseEx(closeState);
        else
          this.WrappedStream.Close();
        if (this.m_CacheDestroy)
        {
          if (this.m_IsStrictCacheErrors)
            this.m_Cache.Remove(this.m_Key);
          else
            this.m_Cache.TryRemove(this.m_Key);
        }
        else if (this.m_IsStrictCacheErrors)
          this.m_Cache.Update(this.m_Key, this.m_Expires, this.m_LastModified, this.m_LastSynchronized, this.m_MaxStale, this.m_EntryMetadata, this.m_SystemMetadata);
        else
          this.m_Cache.TryUpdate(this.m_Key, this.m_Expires, this.m_LastModified, this.m_LastSynchronized, this.m_MaxStale, this.m_EntryMetadata, this.m_SystemMetadata);
      }
      finally
      {
        base.Dispose(disposing);
      }
    }
  }
}
