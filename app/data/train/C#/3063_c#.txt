using System;
using System.Collections;
using System.Collections.Generic;

namespace SkidiKit.Core
{
    public class Bag<T> : ICollection<T>
    {
        private T[] _items;
        private bool _isSealed = false;

        public Bag(int capacity = 16)
        {
            _items = new T[capacity];
            Count = 0;
        }

        public Bag(Bag<T> source): this(source.Count)
        {
            foreach (var item in source)
                Add(item);
        }

        public void Seal()
        {
            Grow(Count);
            _isSealed = true;
        }

        public int Capacity => _items.Length;

        public IEnumerator<T> GetEnumerator()
        {
            return new BagEnumerator<T>(this);
        }

        public void Add(T item)
        {
            if (Count == _items.Length)
                Grow();
            _items[Count] = item;
            ++Count;
        }

        public void Add(Bag<T> range)
        {
            for (int i = 0, count = range.Count; count > i; i++)
                Add(range[i]);
        }

        public void Clear()
        {

            for (int i = Count - 1; i >= 0; i--)
                _items[i] = default(T);
            Count = 0;
        }

        public int Count { get; private set; }

        public bool IsReadOnly => false;

        public bool Contains(T item)
        {
            for (int i = Count - 1; i >= 0; i--)
                if (item.Equals(_items[i]))
                    return true;
            return false;
        }

        public int IndexOf(T item)
        {
            for (int i = Count - 1; i >= 0; --i)
                if (item.Equals(_items[i]))
                    return i;
            return -1;
        }

        public bool Remove(T item)
        {
            var idx = IndexOf(item);
            if (idx == -1)
                return false;

            Remove(idx);
            return true;
        }

        public T Remove(int index)
        {
            var result = _items[index];
            --Count;

            _items[index] = _items[Count];
            _items[Count] = default(T);

            return result;
        }

        public void Apply(params Action<T>[] actions)
        {
            if (actions.Length == 0 || Count == 0)
                return;

            Action<T> compiledAction = null;
            foreach (var action in actions)
                compiledAction += action;

            if (compiledAction == null) return;
            foreach (var item in this)
                compiledAction(item);
        }

        public T this[int index]
        {
            get { return _items[index]; }
            set
            {
                if (index >= _items.Length)
                {
                    Grow(index*2);
                    Count = index + 1;
                }
                else if (index >= Count)
                    Count = index + 1;
                _items[index] = value;
            }
        }

        private void Grow()
        {
            Grow((int) (_items.Length*1.5) + 1);
        }

        private void Grow(int newCapacity)
        {
            T[] oldItems = _items;
            _items = new T[newCapacity];
            Array.Copy(oldItems, 0, _items, 0, Count);
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        public void CopyTo(T[] array, int arrayIndex)
        {
            Array.Copy(_items, 0, array, arrayIndex, Count);
        }

        public T[] ToArray()
        {
            var result = new T[Count];
            CopyTo(result, 0);
            return result;
        }
    }
}