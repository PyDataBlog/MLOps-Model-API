using System;
using System.Collections.Generic;
using System.Linq;

namespace FinnAngelo.Sprite2DLibrary
{
	internal class Flocker
	{
		public Flocker(
			double positionX = 1, double positionY = 1,
			double vectorX = 1, double vectorY = 1,

			double momentum = 50,
			double separation = -3,
			double alignment = 1,
			double cohesion = .1,

			double maxSpeed = .2,
			double minSpeed = .05
			)
		{
			Position = new Point(positionX, positionY);
			Vector = new Point(vectorX, vectorY);

			Momentum = momentum;
			Separation = separation;
			Alignment = alignment;
			Cohesion = cohesion;

			MaxSpeed = maxSpeed;
			MinSpeed = minSpeed;
		}

		public Point Position { get; set; }
		public Point Vector { get; set; }

		public double Momentum { get; set; }
		public double Separation { get; set; }
		public double Alignment { get; set; }
		public double Cohesion { get; set; }
		public double MaxSpeed { get; set; }
		public double MinSpeed { get; set; }

		public Sprite Sprite { get; set; }

	}

	internal static class FlockerExtensions
	{
		//TODO: not yet used, and doesn't belong here
		private static double AddIfBetween(double firstValue, double secondValue, double min, double max)
		{
			var sum = firstValue + secondValue;
			var result = (sum.Between(min, max) ? sum : firstValue);
			return result;
		}

		public static Flocker UpdatePosition(this Flocker source, Universe universe)
		{
			var pos = (source.Position + source.Vector + (universe.Dimensions * 5)) % universe.Dimensions;
			//var newPosX = this.Position.x + this.Vector.x;
			//var newPosY = this.Position.y + this.Vector.y;
			//if (newPosX.Between(0, this.Universe.Dimensions.x))
			//{
			//    this.Position.x = newPosX;
			//}
			//if (newPosY < this.Universe.Dimensions.y && newPosY > 0)
			//{
			//    this.Position.y = newPos.y;
			//}
			source.Position = pos;
			return source;
		}

		public static Flocker UpdateVector(this Flocker source, List<Flocker> allFlockers)
		{
			var newVector = source.GetMomentumVector();
			newVector += source.GetSeparationVector(allFlockers);
			newVector += source.GetAlignmentVector(allFlockers);
			newVector += source.GetCohesionVector(allFlockers);

			var direction = newVector / newVector.Length;
			//var maxSpeed = .5;
			var actualSpeed = (newVector.Length < source.MaxSpeed ? newVector.Length : source.MaxSpeed);

			source.Vector = direction * actualSpeed;
			return source;
		}

		public static Point GetMomentumVector(this Flocker source)
		{
			return source.Vector * source.Momentum;
		}

		public static Point GetSeparationVector(this Flocker source, List<Flocker> allFlockers)
		{
			var reletivePositions = (
										from f in allFlockers
										select new
										{
											position = (f.Position - source.Position),
											sep = source.Separation
										}).ToList();

			var influences = (
								 from p in reletivePositions
								 where p.position.Length != 0
								 select new
								 {
									 direction = p.position / p.position.Length,
									 influence = p.sep / p.position.Length
								 }).ToList();

			Point result = new Point(0, 0);
			influences.ForEach(i =>
			{
				result += i.direction * i.influence;
			});
			return result;
		}

		public static Point GetAlignmentVector(this Flocker source, List<Flocker> allFlockers)
		{
			var reletivePositions = (
										from f in allFlockers
										select new
										{
											direction = (f.Vector)
										}).ToList();

			Point result = new Point(0, 0);
			reletivePositions.ForEach(i =>
			{
				result += i.direction;
			});

			return result * source.Alignment / allFlockers.Count;
		}

		public static Point GetCohesionVector(this Flocker source, List<Flocker> allFlockers)
		{
			var reletivePositions = (
				from f in allFlockers
				select new { direction = (f.Position - source.Position) }
				).ToList();

			Point result = new Point(0, 0);
			reletivePositions.ForEach(i =>
			{
				result += i.direction;
			});

			return result * source.Cohesion / allFlockers.Count;
		}
	}

}

