// Decompiled with JetBrains decompiler
// Type: System.Threading.TimerQueue
// Assembly: mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089
// MVID: 255ABCDF-D9D6-4E3D-BAD4-F74D4CE3D7A8
// Assembly location: C:\Windows\Microsoft.NET\Framework\v4.0.30319\mscorlib.dll

using Microsoft.Win32;
using Microsoft.Win32.SafeHandles;
using System;
using System.Runtime;
using System.Runtime.ConstrainedExecution;
using System.Runtime.InteropServices;
using System.Security;

namespace System.Threading
{
  internal class TimerQueue
  {
    private static TimerQueue s_queue = new TimerQueue();
    [SecurityCritical]
    private TimerQueue.AppDomainTimerSafeHandle m_appDomainTimer;
    private bool m_isAppDomainTimerScheduled;
    private int m_currentAppDomainTimerStartTicks;
    private uint m_currentAppDomainTimerDuration;
    private TimerQueueTimer m_timers;
    private static WaitCallback s_fireQueuedTimerCompletion;

    public static TimerQueue Instance
    {
      [TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")] get
      {
        return TimerQueue.s_queue;
      }
    }

    private static int TickCount
    {
      [SecuritySafeCritical] get
      {
        if (!Environment.IsWindows8OrAbove)
          return Environment.TickCount;
        ulong UnbiasedTime;
        if (!Win32Native.QueryUnbiasedInterruptTime(out UnbiasedTime))
          throw Marshal.GetExceptionForHR(Marshal.GetLastWin32Error());
        return (int) (uint) (UnbiasedTime / 10000UL);
      }
    }

    private TimerQueue()
    {
    }

    [SecuritySafeCritical]
    internal static void AppDomainTimerCallback()
    {
      TimerQueue.Instance.FireNextTimers();
    }

    [SuppressUnmanagedCodeSecurity]
    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    [SecurityCritical]
    [DllImport("QCall", CharSet = CharSet.Unicode)]
    private static extern bool DeleteAppDomainTimer(IntPtr handle);

    public bool UpdateTimer(TimerQueueTimer timer, uint dueTime, uint period)
    {
      if ((int) timer.m_dueTime == -1)
      {
        timer.m_next = this.m_timers;
        timer.m_prev = (TimerQueueTimer) null;
        if (timer.m_next != null)
          timer.m_next.m_prev = timer;
        this.m_timers = timer;
      }
      timer.m_dueTime = dueTime;
      timer.m_period = (int) period == 0 ? uint.MaxValue : period;
      timer.m_startTicks = TimerQueue.TickCount;
      return this.EnsureAppDomainTimerFiresBy(dueTime);
    }

    public void DeleteTimer(TimerQueueTimer timer)
    {
      if ((int) timer.m_dueTime == -1)
        return;
      if (timer.m_next != null)
        timer.m_next.m_prev = timer.m_prev;
      if (timer.m_prev != null)
        timer.m_prev.m_next = timer.m_next;
      if (this.m_timers == timer)
        this.m_timers = timer.m_next;
      timer.m_dueTime = uint.MaxValue;
      timer.m_period = uint.MaxValue;
      timer.m_startTicks = 0;
      timer.m_prev = (TimerQueueTimer) null;
      timer.m_next = (TimerQueueTimer) null;
    }

    [SecuritySafeCritical]
    private bool EnsureAppDomainTimerFiresBy(uint requestedDuration)
    {
      uint dueTime = Math.Min(requestedDuration, 268435455U);
      if (this.m_isAppDomainTimerScheduled)
      {
        uint num1 = (uint) (TimerQueue.TickCount - this.m_currentAppDomainTimerStartTicks);
        if (num1 >= this.m_currentAppDomainTimerDuration)
          return true;
        uint num2 = this.m_currentAppDomainTimerDuration - num1;
        if (dueTime >= num2)
          return true;
      }
      if (this.m_appDomainTimer == null || this.m_appDomainTimer.IsInvalid)
      {
        this.m_appDomainTimer = TimerQueue.CreateAppDomainTimer(dueTime);
        if (this.m_appDomainTimer.IsInvalid)
          return false;
        this.m_isAppDomainTimerScheduled = true;
        this.m_currentAppDomainTimerStartTicks = TimerQueue.TickCount;
        this.m_currentAppDomainTimerDuration = dueTime;
        return true;
      }
      if (!TimerQueue.ChangeAppDomainTimer(this.m_appDomainTimer, dueTime))
        return false;
      this.m_isAppDomainTimerScheduled = true;
      this.m_currentAppDomainTimerStartTicks = TimerQueue.TickCount;
      this.m_currentAppDomainTimerDuration = dueTime;
      return true;
    }

    [SecurityCritical]
    [SuppressUnmanagedCodeSecurity]
    [DllImport("QCall", CharSet = CharSet.Unicode)]
    private static extern TimerQueue.AppDomainTimerSafeHandle CreateAppDomainTimer(uint dueTime);

    [SuppressUnmanagedCodeSecurity]
    [SecurityCritical]
    [DllImport("QCall", CharSet = CharSet.Unicode)]
    private static extern bool ChangeAppDomainTimer(TimerQueue.AppDomainTimerSafeHandle handle, uint dueTime);

    private void FireNextTimers()
    {
      TimerQueueTimer timerQueueTimer = (TimerQueueTimer) null;
      lock (this)
      {
        try
        {
        }
        finally
        {
          this.m_isAppDomainTimerScheduled = false;
          bool local_1 = false;
          uint local_2 = uint.MaxValue;
          int local_3 = TimerQueue.TickCount;
          TimerQueueTimer local_4 = this.m_timers;
          while (local_4 != null)
          {
            uint local_5 = (uint) (local_3 - local_4.m_startTicks);
            if (local_5 >= local_4.m_dueTime)
            {
              TimerQueueTimer local_6 = local_4.m_next;
              if ((int) local_4.m_period != -1)
              {
                local_4.m_startTicks = local_3;
                local_4.m_dueTime = local_4.m_period;
                if (local_4.m_dueTime < local_2)
                {
                  local_1 = true;
                  local_2 = local_4.m_dueTime;
                }
              }
              else
                this.DeleteTimer(local_4);
              if (timerQueueTimer == null)
                timerQueueTimer = local_4;
              else
                TimerQueue.QueueTimerCompletion(local_4);
              local_4 = local_6;
            }
            else
            {
              uint local_7 = local_4.m_dueTime - local_5;
              if (local_7 < local_2)
              {
                local_1 = true;
                local_2 = local_7;
              }
              local_4 = local_4.m_next;
            }
          }
          if (local_1)
            this.EnsureAppDomainTimerFiresBy(local_2);
        }
      }
      if (timerQueueTimer == null)
        return;
      timerQueueTimer.Fire();
    }

    [SecuritySafeCritical]
    private static void QueueTimerCompletion(TimerQueueTimer timer)
    {
      WaitCallback callBack = TimerQueue.s_fireQueuedTimerCompletion;
      if (callBack == null)
        TimerQueue.s_fireQueuedTimerCompletion = callBack = new WaitCallback(TimerQueue.FireQueuedTimerCompletion);
      ThreadPool.UnsafeQueueUserWorkItem(callBack, (object) timer);
    }

    private static void FireQueuedTimerCompletion(object state)
    {
      ((TimerQueueTimer) state).Fire();
    }

    [SecurityCritical]
    private class AppDomainTimerSafeHandle : SafeHandleZeroOrMinusOneIsInvalid
    {
      public AppDomainTimerSafeHandle()
        : base(true)
      {
      }

      [SecurityCritical]
      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
      protected override bool ReleaseHandle()
      {
        return TimerQueue.DeleteAppDomainTimer(this.handle);
      }
    }
  }
}
