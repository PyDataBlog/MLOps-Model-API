using System.Collections.Generic;
using System.Runtime.Serialization;
using System.Text;

namespace Agebull.EntityModel.RobotCoder.CodeTemplate
{
    /// <summary>
    ///     ±íÊ¾Ò»¸ö»ù´¡µ¥´Ê
    /// </summary>
    public class WordUnit : AnalyzeUnitBase
    {
        #region ·½·¨

        /// <summary>
        ///     ¹¹Ôì
        /// </summary>
        internal WordUnit()
        {
            Line = -1;
            Column = -1;
            Start = -1;
            End = -1;
        }

        /// <summary>
        ///     ¹¹Ôì
        /// </summary>
        internal WordUnit(char ch)
        {
            Line = -1;
            Column = -1;
            Start = -1;
            End = -1;
            Append(-1, ch);
        }

        /// <summary>
        ///     ×·¼Ó×Ö·û
        /// </summary>
        /// <param name="idx">ÎÄ¼þÎ»ÖÃ</param>
        /// <param name="ch">×Ö·û</param>
        public void Append(int idx, char ch)
        {
            if (Start < 0)
                Start = idx;
            if (idx >= 0)
                End = idx;
            Chars.Add(ch);
            if (ItemType == CodeItemType.String)
            {
                return;
            }
            if (UnitType == TemplateUnitType.Content)
            {
                if (ch == '\n')
                    IsLine = true;
                return;
            }
            if (UnitType < TemplateUnitType.Content )
            {
                return;
            }
            IsPunctuate = !(ch >= 128
                            || ch >= '0' && ch <= '9' //Êý×Ö
                            || ch == '_'
                            || ch >= 'A' && ch <= 'Z' //×ÖÄ¸
                            || ch >= 'a' && ch <= 'z');
            if (!IsPunctuate)
                return;
            switch (ch)
            {
                case '\n':
                    IsLine = true;
                    IsSpace = true;
                    SetRace(CodeItemRace.Assist, CodeItemFamily.Space, CodeItemType.Line);
                    break;
                case '\r':
                case '\t':
                case ' ':
                case '\u2028':
                case '\u2029':
                case '\u000B':
                case '\u000C':
                    IsSpace = true;
                    SetRace(CodeItemRace.Assist, CodeItemFamily.Space, CodeItemType.Space);
                    break;
                    //    //case ';':
                    //    //    IsLine = true;
                    //    //    IsSpace = true;
                    //    //    SetRace(CodeItemRace.Assist, CodeItemFamily.Space, CodeItemType.Line);
                    //    //    break;
            }
        }

        /// <summary>
        ///     ×·¼Ó×Ö·û
        /// </summary>
        /// <param name="unit">×Ö·û</param>
        public void Append(WordUnit unit)
        {
            if (unit == null)
                return;
            Chars.AddRange(unit.Chars);
            if (unit.End >= 0)
                End = unit.End;
        }

        public void Clear()
        {
            Chars.Clear();
            Start = -1;
            End = -1;
            _cusWord = null;
        }

        public override bool IsEmpty => Start < 0 || End < 0 || _cusWord == null && Chars.Count == 0;

        #endregion

        #region ÄÚÈÝ

        /// <summary>
        /// ÊÇ·ñ»ù´¡µ¥Ôª
        /// </summary>
        public override bool IsUnit => true;

        /// <summary>
        ///     ÎªÖ÷¿Ø·ûµÄµÈ¼¶
        /// </summary>
        [DataMember]
        public int PrimaryLevel { get; set; } = 32;


        /// <summary>
        /// Êý×ÖÀàÐÍ,0²»ÊÇ,1ÕûÊý,2Ð¡Êý
        /// </summary>
        public int NumberType { get; set; }

        /// <summary>
        ///     ¹Ø¼ü×Ö
        /// </summary>
        public bool IsKeyWord { get; set; }

        /// <summary>
        ///     ÊÇ·ñ±êµã
        /// </summary>
        public bool IsPunctuate { get; private set; }

        /// <summary>
        ///     ÊÇ·ñ¿Õ°×
        /// </summary>
        public bool IsSpace { get; private set; }

        /// <summary>
        ///     ÊÇ·ñ»»ÐÐ
        /// </summary>
        public bool IsLine { get; private set; }

        /// <summary>
        ///     ×Ö·ûÄÚÈÝ
        /// </summary>
        public List<char> Chars { get; } = new List<char>();

        private string _cusWord;
        /// <summary>
        ///     ÊÇ·ñ¿ÉÒÔµ±³Éµ¥´Ê
        /// </summary>
        [DataMember]
        public override bool IsWord => true;

        /// <summary>
        ///     µ±Ç°µÄµ¥´Ê
        /// </summary>
        public sealed override string Word
        {
            get => _cusWord ?? (Chars.Count == 0 ? string.Empty : string.Concat(Chars));
            set => _cusWord = value;
        }


        /// <summary>
        ///     µ±Ç°µÄµ¥´Ê
        /// </summary>
        public char Char => Chars.Count == 1 ? Chars[0] : '\0';

        /// <summary>
        ///     µ±Ç°µÄµ¥´Ê
        /// </summary>
        public char FirstChar => Chars.Count == 0 ? '\0' : Chars[0];

        #endregion


        /// <summary>
        ///     ¿ªÊ¼½áÊø¸÷ÓÐ¼¸¸öÎÞÓÃ×Ö·û
        /// </summary>
        [DataMember]
        public int EmptyChar { get; set; }

        /// <summary>
        /// µ½ÎÄ±¾
        /// </summary>
        /// <returns></returns>
        public override string ToCode()
        {
            return Word;
        }

        /// <summary>
        /// µ½ÎÄ±¾
        /// </summary>
        /// <returns></returns>
        public override void ToContent(StringBuilder builder)
        {
            if (_cusWord != null)
            {
                foreach (var ch in _cusWord)
                {
                    switch (ch)
                    {
                        default:
                            builder.Append(ch);
                            break;
                        case '\'':
                            builder.Append(@"\'");
                            break;
                        case '\n':
                            builder.Append(@"\n");
                            break;
                        case '\r':
                            builder.Append(@"\r");
                            break;
                        case '\t':
                            builder.Append(@"\t");
                            break;
                        case '\\':
                            builder.Append(@"\\");
                            break;
                    }
                }
            }
            else
            {
                foreach (var ch in Chars)
                {
                    switch (ch)
                    {
                        default:
                            builder.Append(ch);
                            break;
                        case '\'':
                            builder.Append(@"\'");
                            break;
                        case '\n':
                            builder.Append(@"\n");
                            break;
                        case '\r':
                            builder.Append(@"\r");
                            break;
                        case '\t':
                            builder.Append(@"\t");
                            break;
                        case '\\':
                            builder.Append(@"\\");
                            break;
                    }
                }
            }
        }
    }
}