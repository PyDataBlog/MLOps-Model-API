MODULE neural_type
  TYPE unit
    REAL value
    REAL grad
  END TYPE unit
END MODULE

PROGRAM nn
  USE neural_type
  IMPLICIT NONE

  TYPE (unit) :: a, b, c, x, y
  TYPE (unit) :: z1, z2, z3, z4, z5

  a%value = 1.0
  b%value = 2.0
  c%value = -3.0
  x%value = -1.0
  y%value = 3.0

  ! Forward pass
  CALL mul_gate('f', a, x, z1)
  CALL mul_gate('f', b, y, z2)
  CALL add_gate('f', z1, z2, z3)
  CALL add_gate('f', z3, c, z4)
  CALL sigmoid_gate('f', z4, z5)
  PRINT *, z5

  ! Reverse pass
  z5%grad = 1.0
  CALL sigmoid_gate('r', z4, z5)
  CALL add_gate('r', z3, c, z4)
  CALL add_gate('r', z1, z2, z3)
  CALL mul_gate('r', b, y, z2)
  CALL mul_gate('r', a, x, z1)
  !PRINT *, a, b, c, x, y

  ! Descend
  CALL descend(a, b, c, x, y, 0.01)
  !PRINT *, a, b, c, x, y

  ! Forward pass
  CALL mul_gate('f', a, x, z1)
  CALL mul_gate('f', b, y, z2)
  CALL add_gate('f', z1, z2, z3)
  CALL add_gate('f', z3, c, z4)
  CALL sigmoid_gate('f', z4, z5)
  PRINT *, z5


END PROGRAM nn

SUBROUTINE mul_gate(fchar, u1, u2, u3)
  USE neural_type
  IMPLICIT NONE

  TYPE (unit), INTENT(INOUT) :: u1, u2, u3
  CHARACTER, INTENT(IN) :: fchar
  IF (fchar == 'f') THEN
    u3%value = u1%value * u2%value
    u3%grad = 0.0
  ELSE IF (fchar == 'r') THEN
    u1%grad = u1%grad + (u2%value * u3%grad)
    u2%grad = u2%grad + (u1%value * u3%grad)
  ENDIF
END SUBROUTINE mul_gate

SUBROUTINE add_gate(fchar, u1, u2, u3)
  USE neural_type
  IMPLICIT NONE

  TYPE (unit), INTENT(INOUT) :: u1, u2, u3
  CHARACTER, INTENT(IN) :: fchar
  IF (fchar == 'f') THEN
    u3%value = u1%value + u2%value
    u3%grad = 0.0
  ELSE IF (fchar == 'r') THEN
    u1%grad = u1%grad + (1.0 * u3%grad)
    u2%grad = u2%grad + (1.0 * u3%grad)
  ENDIF
END SUBROUTINE add_gate

SUBROUTINE sigmoid_gate(fchar, u1, u2)
  USE neural_type
  IMPLICIT NONE

  TYPE (unit), INTENT(INOUT) :: u1, u2
  CHARACTER, INTENT(IN) :: fchar
  IF (fchar == 'f') THEN
    u2%value = 1 / (1 + exp(-u1%value))
    u2%grad = 0.0
  ELSE IF (fchar == 'r') THEN
    u1%grad = u1%grad + (((exp(-u1%value)) / ((1 + exp(-u1%value)) ** 2)) * u2%grad)
  ENDIF
END SUBROUTINE sigmoid_gate

SUBROUTINE descend(u1, u2, u3, u4, u5, step)
  USE neural_type
  IMPLICIT NONE

  TYPE (unit), INTENT(INOUT) :: u1, u2, u3, u4, u5
  REAL, INTENT(IN) :: step
  u1%value = u1%value + (u1%grad * step)
  u2%value = u2%value + (u2%grad * step)
  u3%value = u3%value + (u3%grad * step)
  u4%value = u4%value + (u4%grad * step)
  u5%value = u5%value + (u5%grad * step)
END SUBROUTINE descend
