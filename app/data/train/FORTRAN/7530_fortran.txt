!
! Quadratic primes
!
! Problem 27
!
! Euler discovered the remarkable quadratic formula:
!
! It turns out that the formula will produce 40 primes for the consecutive
! integer values 0 <= n <= 39. However, when n = 40,
! 40^2 + 40 + 41 = 40(40 + 1) + 41 is divisible by 41, and certainly when
! n = 41, 41^2 + 41 + 41 is clearly divisible by 41.
!
! The incredible formula n^2 - 79n + 1601 was discovered, which produces 80
! primes for the consecutive values 0 <= n <= 79. The product of the
! coefficients, −79 and 1601, is −126479.
!
! Considering quadratics of the form:
!
!       n^2 + an + b, where |a| < 1000 and |b| < 1000
!
!       where  is the modulus/absolute value of 
!       e.g. |11| = 11 and |-4| = 4
!
! Find the product of the coefficients, a and b, for the quadratic expression
! that produces the maximum number of primes for consecutive values of n,
! starting with n = 0.
!
program quadratic_primes
    use, intrinsic :: iso_fortran_env
    use :: prime_number, only: sieve_of_eratosthenes
    implicit none
    integer, parameter :: max_cofficient = 999
    logical, allocatable :: prime_table(:)
    integer :: max_value

    call main

contains

    function numof_primes(a, b) result(n)
        integer, intent(in) :: a, b
        integer :: n
        integer :: p
        n = 0
        do
            p = n ** 2 + a * n + b
            if (p < 1) exit
            if (p > ubound(prime_table, 1)) then
                write(error_unit, '(a,i0)') 'index is out of bound of prime_table(): ', p
                stop
            end if
            if (.not. prime_table(p)) exit
            n = n + 1
        end do 
    end function numof_primes

    subroutine find_max_coff(range_a, range_b, a, b, n)
        integer, intent(in) :: range_a, range_b
        integer :: a, b, n
        integer :: i, j, k, p

        !print *, range_a, range_b
        n = 0
        do i = 0, range_a, sign(1, range_a)
            do j = 0, range_b, sign(1, range_b)
                k = numof_primes(i, j)
                !print *, i, j, k
                if (n < k) then
                    n = k - 1
                    a = i
                    b = j
                    p = n ** 2 + a * n + b
                    print '("  ("i5", "i5")",i5": ",i8)', a, b, n, p
                end if
            end do
        end do
    end subroutine find_max_coff

    subroutine main
        integer :: a, b, n, save_a, save_b, save_n
        integer :: i, j

        n = max_cofficient
        max_value = n ** 2 + n * n + n
        call sieve_of_eratosthenes(max_value, prime_table)
    
        save_n = 0
        do i = 1, -1, -2
            do j = 1, -1, -2
                call find_max_coff(max_cofficient * i, max_cofficient * j, a, b, n)
                if (save_n < n) then
                    save_a = a
                    save_b = b
                    save_n = n
                end if
            end do
        end do
        a = save_a
        b = save_b
        n = save_n
        print '(5x"a ="i5", b = "i5", n = "i5)', a, b, n 
        print *, 'result =', a * b
    end subroutine main

end program quadratic_primes
