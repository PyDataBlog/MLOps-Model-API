module sphere_linear_hull1
use math
implicit none
contains
    double precision function p_sphere_lin_hull(q, p, Np)
        ! Sphere Formfacotr Amplitude
        ! Parameters: R, SLDsphere, SLDmatrix
        double precision, intent(in) :: q
        double precision, dimension(Np), intent(in) :: p
        integer, intent(in) :: Np
        
        double precision :: R1, R2, dR, SLDcore, SLDhull, SLDmatrix
        double precision :: m, qR1, qR2
        R1 = p(1)
        dR = p(2)
        SLDcore = p(3)
        SLDhull = p(4)
        SLDmatrix = p(5)

        R2 = R1 + dR
        if (dR /= 0) then
            m = (SLDhull - SLDcore) / dR
        else
            m = 0d0
        end if
        qR1 = q*R1
        qR2 = q*R2
        if (q /= 0) then
            p_sphere_lin_hull = 4d0*pi/q**3*(SLDcore - SLDmatrix)*&
                        (sin(qR2) - qR2*cos(qR2)) +&
                        4d0*pi*m/q**4*&
                        ((2*qR2 - qR1)*sin(qR2)+&
                         (qR2*(qR1-qR2) + 2d0)*cos(qR2) - qR1*sin(qR1) -&
                         2*cos(qR1))
        else
            p_sphere_lin_hull = 4d0*pi*(SLDcore - SLDmatrix)*R2**3/3 +&
                                4d0*pi*m*(R2**4/4d0 + R1**4/12d0 + R1*R2**3/6d0)
        end if     
    end function p_sphere_lin_hull

    double precision function ff_sphere_lin_hull(q, p, Np)
        double precision, intent(in) :: q
        double precision, dimension(Np), intent(in) :: p
        integer, intent(in) :: Np
        ff_sphere_lin_hull = abs(p_sphere_lin_hull(q, p, Np))**2
    end function ff_sphere_lin_hull

    subroutine formfactor(q, R1, dR, SLDcore, SLDhull, SLDmatrix, sigR1, sigdR,&
                        Nq, ff_intensity)
        double precision, dimension(Nq), intent(in) :: q
        double precision, intent(in) :: R1, dR, SLDcore, SLDhull, SLDmatrix
        double precision, intent(in) :: sigR1, sigdR
        integer, intent(in) :: Nq
        
        integer, parameter :: Np=5
        double precision, dimension(Np) :: p
        double precision, dimension(Nq), intent(out) :: ff_intensity
        integer :: iq
        double precision :: qval, R1min, R1max, dRmin, dRmax
        p = (/R1, dR, SLDcore, SLDhull, SLDmatrix/)
        call get_cutoff_lognormal(R1, sigR1, R1min, R1max) 
        call get_cutoff_lognormal(dR, sigdR, dRmin, dRmax)

        !$omp parallel
        !$omp do
        do iq=1, Nq
            call integrate_two_size_distributions(q(iq), p, Np, &
                            1, R1min, R1max, sigR1, &
                            2, dRmin, dRmax, sigdR, &
                            ff_sphere_lin_hull, lognormal, lognormal, ff_intensity(iq))
        end do
        !$omp end do
        !$omp end parallel
    end subroutine formfactor

    subroutine magnetic_formfactor(q, R1, dR, SLDcore, SLDhull, SLDmatrix,&
                        sigR1, sigdR,&
                        mag_SLDcore, mag_SLDhull, mag_SLDmatrix,&
                        xi, sin2alpha, plus_or_minus, Nq, ff_out)
        double precision, dimension(Nq), intent(in) :: q
        double precision, intent(in) :: R1, dR, SLDcore, SLDhull, SLDmatrix
        double precision, intent(in) :: sigR1, sigdR
        double precision, intent(in) :: mag_SLDcore, mag_SLDhull, mag_SLDmatrix
        double precision, intent(in) :: xi, sin2alpha, plus_or_minus
        integer, intent(in) :: Nq
        
        integer, parameter :: Np=5
        double precision, dimension(Np) :: p
        
        double precision, dimension(Nq), intent(out) :: ff_out
        
        integer :: iq
        double precision :: qval, R1min, R1max, dRmin, dRmax
        p = (/R1, dR, SLDcore, SLDhull, SLDmatrix/)
        call get_cutoff_lognormal(R1, sigR1, R1min, R1max) 
        call get_cutoff_lognormal(dR, sigdR, dRmin, dRmax)

        !$omp parallel
        !$omp do
        do iq=1, Nq
            call integrate_two_size_distributions(q(iq), p, Np, &
                        1, R1min, R1max, sigR1, &
                        2, dRmin, dRmax, sigdR, &
                        call_magnetic, lognormal, lognormal,&
                        ff_out(iq))
        end do
        !$omp end do
        !$omp end parallel
        contains
            double precision function call_magnetic(q, p, Np)
                double precision, intent(in) :: q
                double precision, dimension(Np), intent(in) :: p
                integer, intent(in) :: Np
                
                double precision, dimension(Np) :: p_mag
                p_mag = (/p(1), p(2), mag_SLDcore, mag_SLDhull, mag_SLDmatrix/)
                call magnetic_scattering(q, xi, sin2alpha, plus_or_minus, p,&
                    p_mag, p_sphere_lin_hull, p_sphere_lin_hull,&
                    Nq, Np, Np, call_magnetic)
            end function call_magnetic
    end subroutine magnetic_formfactor
    
    double precision function sld_sphere_lin_hull_value(x, p, Np)
        double precision, intent(in) :: x
        double precision, dimension(Np), intent(in) :: p
        integer, intent(in) :: Np
        
        double precision :: R1, R2, dR, SLDcore, SLDhull, SLDmatrix
        R1 = p(1)
        dR = p(2)
        SLDcore = p(3)
        SLDhull = p(4)
        SLDmatrix = p(5)
        
        R2 = R1 + dR
        if (x < R1) then
            sld_sphere_lin_hull_value = SLDcore
        else if (x < R2) then
            sld_sphere_lin_hull_value = SLDcore + (SLDhull-SLDcore)/dR*(x-R1)
        else
            sld_sphere_lin_hull_value = SLDmatrix
        end if
    end function sld_sphere_lin_hull_value

    subroutine sld(x, R1, dR, SLDcore, SLDhull, SLDmatrix, sigR1, sigdR,&
                        Nx, sld_array)
        double precision, dimension(Nx), intent(in) :: x
        double precision, intent(in) :: R1, dR, SLDcore, SLDhull, SLDmatrix
        double precision, intent(in) :: sigR1, sigdR
        integer, intent(in) :: Nx
        double precision, dimension(Nx), intent(out) :: sld_array
        
        integer, parameter :: Np=5
        double precision, dimension(Np) :: p

        integer :: ix
        double precision :: R1min, R1max, dRmin, dRmax
        
        p = (/R1, dR, SLDcore, SLDhull, SLDmatrix/)
        call get_cutoff_lognormal(R1, sigR1, R1min, R1max) 
        call get_cutoff_lognormal(dR, sigdR, dRmin, dRmax) 
        !$omp parallel
        !$omp do
        do ix=1, Nx
            call integrate_two_size_distributions(x(ix), p, Np,&
                        1, R1min, R1max, sigR1,&
                        2, dRmin, dRmax, sigdR,&
                        sld_sphere_lin_hull_value, lognormal, lognormal,&
                        sld_array(ix))
        end do
        !$omp end do
        !$omp end parallel
    end subroutine sld
end module sphere_linear_hull1
