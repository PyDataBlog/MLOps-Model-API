module testTrapzLognormal
implicit none
double precision, parameter :: pi = acos(-1d0)
double precision, parameter :: sq2pi = sqrt(2d0*pi)
contains
  subroutine lognormal(x, mu, sig, lognormalval)
    double precision, intent(in) :: x, mu, sig
    double precision, intent(out) :: lognormalval
    lognormalval = 1d0 / (sq2pi*sig*x) * dexp(-0.5d0*(dlog(x/mu) / sig)**2)
  end subroutine lognormal

  subroutine trapzLognormal(x, p, Np, &
        pInt, pMin, pMax, pNum, pSig,&
        funcIntegrand, trapzResult)
  !trapezoid integrate lognormal*function for one parameter
  !f(x;p) * L(x, muP, sigP)
  !x -- at which value of f
  !p -- parameters of function
  !Np -- number of parameters
  !pInt -- which parameter to integrate
  !pMin -- from
  !pMax -- to
  !pNum -- how many steps
  !pSig -- width of lognormal function
    double precision, intent(in) :: x
    double precision, dimension(Np), intent(in) :: p
    integer, intent(in) :: Np, pInt, pNum
    double precision, intent(in) :: pMin, pMax, pSig
    external funcIntegrand
    double precision, intent(out) :: trapzResult
    
    interface
      double precision function funcIntegrand(q, p, Np)
        double precision, intent(in) :: q
        double precision, dimension(Np), intent(in) :: p
        integer, intent(in) :: Np
      end function
    end interface
    
    if (psig > 0d0) then
      trapzResult = funcIntegrand(x, p, Np)
    else
      trapzResult = funcIntegrand(x, p, Np)
    end if
    
    contains
      double precision function size_dist_function(x)
        double precision :: x
        double precision, dimension(Np) :: hp
        double precision :: prob, funcVal
        hp = p
        hp(pInt) = x
        funcVal = funcIntegrand(x, hp, Np)
        call lognormal(x, p(pInt), psig, prob)
        
        size_dist_function = funcVal * prob
      end function size_dist_function
  end subroutine trapzLognormal

  double precision function p_sphere(q, p, Np)
    ! Sphere Formfacotr Amplitude
    ! Parameters: R, SLDsphere, SLDmatrix
    double precision, intent(in) :: q
    double precision, dimension(Np), intent(in) :: p
    integer, intent(in) :: Np
    
    double precision :: qR, R, SLDsphere, SLDmatrix
    R = p(1)
    SLDsphere = p(2)
    SLDmatrix = p(3)
    
    qR = q*R
    if (qR /= 0) then
      p_sphere = 4d0*pi*R**3*(SLDsphere - SLDmatrix)*&
                 (sin(qR) - qR*cos(qR))/qR**3
    else
      p_sphere = 4d0/3d0*pi*R**3*(SLDsphere - SLDmatrix)
    end if
  end function p_sphere

  double precision function ff_sphere(q, p, Np)
    double precision, intent(in) :: q
    double precision, dimension(Np), intent(in) :: p
    integer, intent(in) :: Np
    ff_sphere = abs(p_sphere(q, p, Np))**2
  end function ff_sphere

  subroutine test(x, trapzResult)
    double precision, intent(in) :: x
    double precision, intent(out) :: trapzResult
    double precision, dimension(3) :: p
    integer :: Np=3
    integer :: pInt, pNum
    double precision :: pMin, pMax, pSig
    p = (/200d0, 50d-6, 10d-6/)
    pInt = 1
    pNum = 30
    pMin = 0
    pMax = 100
    pSig = 0.5

    call trapzLognormal(x, p, Np, &
        pInt, pMin, pMax, pNum, pSig,&
        ff_sphere, trapzResult)

  end subroutine test
end module testTrapzLognormal