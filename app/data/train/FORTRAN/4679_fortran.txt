      SUBROUTINE PLYSMP(IA,NPIXA,NLINEA,INVALA,ASCALE,AZERO,
     +			X,Y,NXY,IB,NPIXB,NLINEB,INVALB,BSCALE,BZERO,
     +			LIMIT,IERR)
*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*PURPOSE
*	TO COPY A POLYGONAL REGION OF ONE IMAGE INTO THE CORRESPONDING
*	PIXELS OF ANOTHER
*
*METHOD
*	FIND THE SMALLEST RECTANGLE WHICH ENCOMPASSES THE POLYGON. FOR
*	EACH IMAGE LINE IN THE RECTANGLE, FIND ALL THE INTERSECTIONS
*	WITH POLYGON EDGES. SORT THE INTERSECTIONS INTO INCREASING X
*	POSITION ORDER. COPY ALTERNATE REGIONS BETWEEN THESE INTERSECT-
*	IONS, ALLOWING FOR INVALID PIXELS AND DIFFERING SCALE FACTORS
*	IN THE 2 IMAGES
*
*ARGUMENTS
*	IA (IN)
*	INTEGER*2(NPIXA,NLINEA)
*		THE IMAGE TO BE COPIED FROM
*	NPIXA,NLINEA (IN)
*	INTEGER
*		THE DIMENSIONS OF IA
*	INVALA (IN)
*	INTEGER
*		INVALID PIXEL FLAG FOR IA
*	ASCALE,AZERO (IN)
*	REAL
*		SCALE AND ZERO LEVEL FOR IA
*	X,Y (IN)
*	REAL(NXY)
*		THE POSITIONS OF THE POLYGON VERTICES
*	NXY (IN)
*	INTEGER
*		THE NUMBER OF POLYGON VERTICES
*	IB (IN/OUT)
*	INTEGER*2(NPIXB,NLINEB)
*		THE IMAGE TO BE COPIED INTO
*	NPIXB,NLINEB (IN)
*	INTEGER
*		THE DIMENSIONS OF IB
*	INVALB (IN)
*	INTEGER
*		INVALID PIXEL FLAG FOR IB
*	BSCALE,BZERO (IN)
*	REAL
*		SCALE AND ZERO LEVEL FOR IB
*	LIMIT (OUT)
*	INTEGER(4)
*		THE LIMITS XMIN,XMAX,YMIN,YMAX OF THE SMALLEST RECTANGLE
*		ENCLOSING THE POLYGON
*	IERR (OUT)
*	INTEGER
*		ERROR FLAG: ZERO FOR SUCCESS
*
*CALLS
*	NONE
*
*NOTES
*	USES INTEGER*2 ARRAYS
*
*WRITTEN BY
*	R.F. WARREN-SMITH
*-----------------------------------------------------------------------
C
C
      INTEGER*2 IA(NPIXA,NLINEA),IB(NPIXB,NLINEB)
      INTEGER LIMIT(4)
      LOGICAL EXIT
      REAL X(NXY),Y(NXY)
C
C SET MAXIMUM ALLOWABLE NUMBER OF LINE CROSSINGS
C
      PARAMETER (MXCRS=100)
      REAL XCROSS(MXCRS)
C
C CHECK ARGUMENT VALIDITY
C
      IF(NXY.LT.3) THEN
        IERR=1
      ELSE
	IERR=0
C
C FIND THE MAX AND MIN X AND Y RANGE OF THE X,Y POSITIONS
C
	XMIN=1.0E20
	XMAX=-1.0E20
	YMIN=1.0E20
	YMAX=-1.0E20
	DO 1 N=1,NXY
	  XMIN=MIN(X(N),XMIN)
	  XMAX=MAX(X(N),XMAX)
	  YMIN=MIN(Y(N),YMIN)
	  YMAX=MAX(Y(N),YMAX)
    1	CONTINUE
C
C CONVERT RANGES TO INTEGER LIMITS RESTRICTED TO THE OUTPUT
C IMAGE SIZE
C
	MINX=INT(MIN(MAX(-1.0E8,XMIN),1.0E8))
	IF(REAL(MINX).LT.XMIN) MINX=MINX+1
	LIMIT(1)=MAX(MINX,1)
	LIMIT(2)=MIN(INT(MIN(MAX(-1.0E8,XMAX),1.0E8)),NPIXB)
	MINY=INT(MIN(MAX(-1.0E8,YMIN),1.0E8))
	IF(REAL(MINY).LT.YMIN) MINY=MINY+1
	LIMIT(3)=MAX(MINY,1)
	LIMIT(4)=MIN(INT(MIN(MAX(-1.0E8,YMAX),1.0E8)),NLINEB)
C
C CALCULATE SCALE FACTORS TO APPLY TO IA TO CONVERT TO IB
C
	BS=BSCALE
	IF(ABS(BS).LT.1.0E-20) BS=SIGN(1.0E-20,BS)
	SCALEF=ASCALE/BS
	ZEROL=(AZERO-BZERO)/BS
C
C SCAN THE RANGE OF OUTPUT LINES AFFECTED
C
	DO 200 J=LIMIT(3),LIMIT(4)
	  YL=J
C
C PROBLEMS OCCUR IN COUNTING THE NUMBER OF INTERSECTIONS IF ANY
C IMAGE LINE PASSES EXACTLY THROUGH A POLYGON VERTEX. THEREFORE
C THE LINE POSITIONS ARE SHIFTED BY A NEGLIGIBLE AMOUNT PERT
C TO ENSURE THIS DOES NOT HAPPEN
C
	  PERT=0.0001
   54	  NCROSS=0
C
C SCAN THROUGH THE X,Y POSITIONS, TESTING IF EACH POLYGON SIDE
C INTERSECTS THE IMAGE LINE
C
	  DO 99 N1=1,NXY
	    N2=N1+1
C
C POLYGON VERTICES CYCLE BACK TO THE START
C
	    IF(N2.GT.NXY) N2=1
	    TEST=((Y(N1)-YL)-PERT)*((YL-Y(N2))+PERT)
C
C IF TEST IS ZERO, THE LINE PASSES THROUGH A VERTEX... CHANGE PERT
C AND START AGAIN
C
	    IF(TEST.EQ.0.0) THEN
	      PERT=PERT+0.0001
	      GO TO 54
C
C IF TEST IS POSITIVE, ADJACENT VERTICES LIE ON OPPOSITE SIDES
C OF THE IMAGE LINE... CALCULATE THE POINT OF INTERSECTION AND
C STORE IT
C
	    ELSE IF(TEST.GT.0) THEN
	      NCROSS=NCROSS+1
	      IF(NCROSS.LE.MXCRS) THEN
		DY=Y(N2)-Y(N1)
		IF(ABS(DY).LT.1.0E-20) DY=SIGN(1.0E-20,DY)
		XCROSS(NCROSS)=X(N1)+((YL-Y(N1))*(X(N2)-X(N1))/DY)
	      ELSE
C
C IF STORAGE FOR INTERSECTIONS IS EXCEEDED, RETURN WITH IERR=2
C
		IERR=2
		GO TO 999
	      ENDIF
	    ENDIF
   99	  CONTINUE
C
C IF LINE INTERSECTS THE POLYGON, SORT INTERSECTIONS INTO X ORDER
C
	  IF(NCROSS.GT.1) THEN
	    EXIT=.FALSE.
	    NTOP=NCROSS
   56       IF(.NOT.EXIT) THEN
	      EXIT=.TRUE.
	      NTOP=NTOP-1
	      DO 100 N=1,NTOP
C
C SWAP ADJACENT VALUES IF IN WRONG ORDER
C
		IF(XCROSS(N).GT.XCROSS(N+1)) THEN
		  XT=XCROSS(N+1)
		  XCROSS(N+1)=XCROSS(N)
		  XCROSS(N)=XT
		  EXIT=.FALSE.
		ENDIF
  100	      CONTINUE
C
C LOOP WHILE INTERCHANGE WAS NECESSARY
C
	      GO TO 56
	    ENDIF
C
C SCAN THROUGH THE ORDERED INTERSECTIONS IN PAIRS
C
	    DO 61 N=2,NCROSS,2
	      XMIN=XCROSS(N-1)
	      MINX=INT(MIN(MAX(-1.0E8,XMIN),1.0E8))
	      IF(REAL(MINX).LT.XMIN) MINX=MINX+1
	      MINX=MAX(LIMIT(1),MINX)
	      MAXX=MIN(LIMIT(2),INT(MIN(MAX(-1.0E8,XCROSS(N)),1.0E8)))
C
C COPY PIXELS LYING BETWEEN EACH PAIR OF INTERSECTIONS FROM IA
C INTO IB, ALLOWING FOR INVALID VALUES, THE SIZE OF IMAGE A AND
C THE DIFFERING SCALE FACTORS
C
	      DO 60 I=MINX,MAXX
	        IF(I.LE.NPIXA.AND.J.LE.NLINEA) THEN
		  IF(IA(I,J).EQ.INVALA) THEN
		    IB(I,J)=INVALB
		  ELSE
		    BVAL=IA(I,J)*SCALEF+ZEROL
		    IF(BVAL.GT.32767.0.OR.BVAL.LT.-32767.0) THEN
		      IB(I,J)=INVALB
		    ELSE
		      IB(I,J)=NINT(BVAL)
		    ENDIF
		  ENDIF
		ELSE
		  IB(I,J)=INVALB
		ENDIF
   60	      CONTINUE
   61	    CONTINUE
	  ENDIF
  200   CONTINUE
      ENDIF
  999 RETURN
      END
