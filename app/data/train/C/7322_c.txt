/*
 ============================================================================
 Name        : settings.c
 Author      : B. Eschrich
 Version     : 1.00
 Copyright   : Copyright (c) 2016-2017 by B. Eschrich (EoF)
 Description : Global settings and command line options
 ============================================================================
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <errno.h>
#include <getopt.h>

#include <sys/types.h>
#include <sys/stat.h>

#include "settings.h"

// global settings
settings_t g_settings =
{
    .run_mode	= RUN_MODE_DAEMON,
    .pid_file 	= PID_FILE_NAME,
    .log_file 	= LOG_FILE_NAME,
    .socket_file= UDS_FILE_NAME,
    .foreground = 0,
};

/**
 *
 */
static void print_usage(const char* prog)
{
    printf("Usage: %s [-dvlps]\n", prog);
    puts("  -d --daemon     Run as daemon process (default behavior)");
    puts("  -v --view       Run as data view UI (requires running daemon)");
    puts("  -c --check      Check daemon is running");
    puts("  -f --foreground Run daemon code in foreground (for debug purposes)");
    puts("  -r --reload     Reload daemon settings");
    puts("  -l --log        Logger output file name (only as daemon, default: " LOG_FILE_NAME ")");
    puts("  -p --pidfile    PID output file name (only as daemon, default: " PID_FILE_NAME ")");
    puts("  -s --socket     Unix socket file name (default: " UDS_FILE_NAME ")");
    exit(EXIT_FAILURE);
}

/**
 *
 */
void parse_opts(int argc, char* argv[])
{
    while(1)
    {
        static const struct option opts[] =
        {
            { "daemon",      no_argument,       0, 'd'},
            { "view",        no_argument,       0, 'v'},
            { "check",       no_argument,       0, 'c'},
            { "reload",      no_argument,       0, 'r'},
            { "foreground",  no_argument,       0, 'f'},
            { "socket",      required_argument, 0, 's'},
            { "pidfile",     required_argument, 0, 'p'},
            { "log",         required_argument, 0, 'l'},
            { 0, 0, 0, 0 }, // end of list
        };

        /* getopt_long stores the option index here. */
        int option_index = 0;
        int c;

        c = getopt_long(argc, argv, "dfvcrl:p:s:", opts, &option_index);

        /* Detect the end of the options. */
        if(c == -1)
        {
            break;
        }

        switch(c)
        {
            case 'd':
                g_settings.run_mode = RUN_MODE_DAEMON;
                break;
            case 'f':
                g_settings.run_mode = RUN_MODE_DAEMON;
                g_settings.foreground = 1;
                break;
            case 'v':
                if(g_settings.foreground == 0)
                {
                    g_settings.run_mode = RUN_MODE_VIEW;
                }
                break;
            case 'r':
                puts("Reload settings...");
                break;
            case 'c':
                puts("Check running...");
                break;
            case 's':
                g_settings.socket_file = optarg;
                break;
            case 'p':
                g_settings.pid_file = optarg;
                break;
            case 'l':
                g_settings.log_file = optarg;
                break;
            case '?':
                print_usage(argv[0]);
                break;
            default:
                print_usage(argv[0]);
                break;
        }

    }
}


