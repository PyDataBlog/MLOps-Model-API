

/*****************************************************************************
   1 Í·ÎÄ¼þ°üº¬
*****************************************************************************/
#include "product_config.h"
#include "vos.h"
#include "Taf_Tafm_Remote.h"
#include "UsimPsInterface.h"
#include "Ssa_Define.h"
#include "MnCall.h"
#include "Taf_Aps.h"
/* É¾³ýExtAppMmcInterface.h*/
#include "TafMmcInterface.h"
#include "MnMsgExt.h"
#include "UsimPsInterface.h"
#include "MnComm.h"
#include "siapppih.h"
#include "MnCallTimer.h"
#include "RabmTafInterface.h"
#include "MmaAppLocal.h"
#include "TafDrvAgentMain.h"
#include "MnCallReqProc.h"
#include "TafApsMain.h"
#include "MnCallCtx.h"
#include "MnCallProcNvim.h"

#include "NasUtranCtrlCommFunc.h"
#include "NasUtranCtrlInterface.h"

#include "TafMtaMain.h"

#include "TafSdcCtx.h"
#include "TafSpmMain.h"
#include "MnMsgSmCommProc.h"

#include "NasUsimmApi.h"

#include "TafCbaProcUsim.h"

#include "MnCallImsaProc.h"
#include "TafMntn.h"

#ifdef  __cplusplus
#if  __cplusplus
extern "C"{
#endif
#endif

extern VOS_VOID R_ITF_InitFlowCtrl(VOS_VOID);


#define    THIS_FILE_ID        PS_FILE_ID_MNCALL_TASK_C

VOS_VOID MN_MSG_RecurDataRestore(
    struct MsgCB                        *pstAppMsg
);

VOS_UINT8                               g_ucMnOmConnectFlg       = VOS_FALSE;   /* UEÓëPC¹¤¾ßµÄÁ¬½Ó±êÖ¾, VOS_TRUE: ÒÑÁ¬½Ó; VOS_FALSE: Î´Á¬½Ó */
VOS_UINT8                               g_ucMnOmPcRecurEnableFlg = VOS_FALSE;   /* PC¹¤¾ßÅäÖÃµÄ·¢ËÍNAS PC»Ø·ÅÏûÏ¢µÄÊ¹ÄÜ±êÖ¾ */
MN_STK_MSG_FUNC_MAP_STRU                g_astTafStkMsgFuncMap[] =
{
    {STK_MSG_SEND_REQ,         MN_MSG_MSGTYPE_SEND_RPDATA_DIRECT, MN_MSG_ProcAppSend},
    {STK_CALL_START_DTMF_REQ,  MN_CALL_APP_START_DTMF_REQ,        TAF_CALL_RcvStartDtmfReq},
    {STK_CALL_STOP_DTMF_REQ,   MN_CALL_APP_STOP_DTMF_REQ,         TAF_CALL_RcvStopDtmfReq},
    {STK_CALL_CALLORIG_REQ,    MN_CALL_APP_ORIG_REQ,              MN_CALL_StkCallOrigReqProc},
    {STK_CALL_SUPS_CMD_REQ,    MN_CALL_APP_SUPS_CMD_REQ,          MN_CALL_CallSupsCmdReqProc},
    {STK_SS_REGISTERSS_REQ,    TAF_MSG_REGISTERSS_MSG,            MN_SndAppMsgToSs},
    {STK_SS_ERASESS_REQ,       TAF_MSG_ERASESS_MSG,               MN_SndAppMsgToSs},
    {STK_SS_ACTIVATESS_REQ,    TAF_MSG_ACTIVATESS_MSG,            MN_SndAppMsgToSs},
    {STK_SS_DEACTIVATESS_REQ,  TAF_MSG_DEACTIVATESS_MSG,          MN_SndAppMsgToSs},
    {STK_SS_INTERROGATESS_REQ, TAF_MSG_INTERROGATESS_MSG,         MN_SndAppMsgToSs},
    {STK_SS_REGPWD_REQ,        TAF_MSG_REGPWD_MSG,                MN_SndAppMsgToSs},
    {STK_SS_USSD_REQ,          TAF_MSG_PROCESS_USS_MSG,           MN_SndAppMsgToSs},
    {PS_USIM_ENVELOPE_CNF,     PS_USIM_ENVELOPE_CNF,              TAF_ProcStkEnvelopeCnf}
};

/*****************************************************************************
   2 º¯ÊýÊµÏÖ
*****************************************************************************/


VOS_UINT32  MN_Init(enum VOS_INIT_PHASE_DEFINE  ip)
{
    TAF_SDC_CTX_STRU                    *pstSdcCtx = VOS_NULL_PTR;

    switch( ip )
    {
    case VOS_IP_INITIAL:

        NAS_PIHAPI_RegCardRefreshIndMsg(WUEPS_PID_TAF);

        pstSdcCtx = TAF_SDC_GetSdcCtx();
        TAF_SDC_InitCtx(TAF_SDC_INIT_CTX_STARTUP, pstSdcCtx);

        /* ³õÊ¼»¯CCA */
        MN_CALL_Init(MN_CALL_POWER_STATE_ON);

        /* ³õÊ¼»¯SMA */
        MN_MSG_Init();

        /* ³õÊ¼»¯APS */
        Aps_Init();

        TAF_SPM_Init();

        /* ³õÊ¼»¯SSA */
        SSA_Init();
        /* ³õÊ¼»¯GNA */

        /* ÒÑ¾­Óëlijun,hefeng,xiamiaofangÈ·ÈÏ£¬¿ÉÒÔÉ¾³ýÁ÷¿Ø³õÊ¼»¯ */

        break;

    default:
        break;
    }

    return VOS_OK;
}

VOS_VOID Taf_ProcCallCtrlAllowNoModification(struct MsgCB * pstMsg)
{
/*
    switch ²Ù×÷ÀàÐÍ
        case ºô½Ð:
        if (ÕÒµ½´¦ÓÚCCA_CALL_CTRL_PROCEEDING×´Ì¬µÄºô½ÐÊµÌå)
        {
            ½«Call Control×´Ì¬¸üÐÂÎªCCA_CALL_CTRL_END
            µ÷ÓÃCca_CallOrigReqProc
        }
        break;

        #if 0
        case ²¹³äÒµÎñ:
        ÔÝÂÔ
        break;

        case Êý´«:
        ÔÝÂÔ
        break;
        #endif

        default:
        break;
*/
}


VOS_VOID Taf_ProcCallCtrlNotAllow(struct MsgCB * pstMsg)
{
/*
    switch ²Ù×÷ÀàÐÍ
        case ºô½Ð:
            Çå³ý¶ÔÓ¦µÄCCA×´Ì¬»ú:
            ÉÏ±¨ÊÂ¼þ£¬´íÎóÖµÎªTAF_ERR_CALL_CONTROL_REJECTED
            break;

        case ²¹³äÒµÎñ:
        case USSDÒµÎñ:
            Çå³ý¶ÔÓ¦µÄSSA×´Ì¬»ú
            ÉÏ±¨ÊÂ¼þ£¬´íÎóÖµÎªTAF_ERR_CALL_CONTROL_REJECTED
            break;

        case Êý´«:
            Çå³ý¶ÔÓ¦µÄAPS×´Ì¬»ú
            ÉÏ±¨ÊÂ¼þ£¬´íÎóÖµÎªTAF_ERR_CALL_CONTROL_REJECTED
            break;

        default:
            break;

*/

}

VOS_VOID Taf_ProcCallCtrlAllowWithModification(struct MsgCB * pstMsg)
{

/*
    µ÷ÓÃÊý¾Ý×ª»»º¯Êý

    switch ²Ù×÷ÀàÐÍ
        case ºô½Ð:
            if (ÕÒµ½´¦ÓÚCCA_CALL_CTRL_PROCEEDING×´Ì¬µÄºô½ÐÊµÌå)
            {
                ¸üÐÂ¶ÔÓ¦ÊµÌåµÄ×´Ì¬ÐÅÏ¢
                µ÷ÓÃCca_CallOrigReqProc
            }
            break;

        case ²¹³äÒµÎñ:
        case USSDÒµÎñ:
            if (Ö®Ç°µÄ²Ù×÷ÊÇ²¢²»ÊÇSSA·¢ÆðµÄCall control²Ù×÷)
            {
                Çå¿Õ¶ÔÓ¦·¢Æð²Ù×÷ÊµÌåµÄ×´Ì¬(CCA»òÕßAPS)
            }

            µ÷ÓÃ¹«¹²´¦Àíº¯Êý(MMI×Ö´®½âÎöº¯Êý£¬¸Ãº¯ÊýµÄÊµÏÖ·½Ê½´ý¶¨,
                             µÈCCA±àÂëÍê³Éºó£¬ÔÙÐÐÈ·¶¨)
            µ÷ÓÃSSAµÄ½Ó¿Ú(´Ë´¦»¹ÐèÒªÒÀ¾ÝÐÂ°æµÄSSAµÄÊµÏÖ·½Ê½À´È·¶¨)
            break;

        case Êý´«:
            µ÷ÓÃAPSµÄPDP¼¤»î½Ó¿Ú(´Ë´¦»¹ÐèÒªÒÀ¾ÝÐÂ°æµÄAPSµÄÊµÏÖ·½Ê½À´È·¶¨)
            break;

        default:
            break;

    ÉÏ±¨ÊÂ¼þ£¬¸æÖªÓ¦ÓÃÓÉÓÚcall controlµÄÔ­Òò£¬ºô½Ð·¢ÉúÁË¸Ä±ä

*/
}

/*****************************************************************************
 º¯ Êý Ãû  : Taf_ProcSimaMsg
 ¹¦ÄÜÃèÊö  : ´¦ÀíÀ´×ÔSimaµÄÏûÏ¢
 ÊäÈë²ÎÊý  : pstMsg - ÊÕµ½µÄÏûÏ¢
 ·µ »Ø Öµ  : ÎÞ
 µ÷ÓÃº¯Êý  :
 ±»µ÷º¯Êý  :

 ÐÞ¸ÄÀúÊ·      :
  1.ÈÕ    ÆÚ   : 2008Äê1ÔÂ10ÈÕ
    ×÷    Õß   : ¶¡Çì 49431
    ÐÞ¸ÄÄÚÈÝ   : ÐÂÉú³Éº¯Êý
*****************************************************************************/
VOS_VOID  Taf_ProcSimaMsg (struct MsgCB * pstMsg)
{
/*
    switch (ÃüÁîÀàÐÍ)
        #ifdef hw_feature_call_control
        case ÀàÐÍÎªcall control:
        {
            switch (result)
            {
                case ÔÊÐíÎÞÐÞ¸Ä:
                    µ÷ÓÃTaf_ProcCallCtrlAllowNoModification
                    break;

                case ²»ÔÊÐí:
                    µ÷ÓÃTaf_ProcCallCtrlNotAllow
                    break;

                case ÔÊÐíµ«ÐÞ¸Ä:
                    µ÷ÓÃTaf_ProcCallCtrlAllowWithModification
                    break;

                default:
                    break;
            }
        }
        break;
        #endif

        default:
        break;

*/
}


VOS_VOID  MN_ProcTimerMsg (struct MsgCB * pstMsg)
{
    REL_TIMER_MSG * pstTmrMsg = (REL_TIMER_MSG *)pstMsg;

    switch (pstTmrMsg->ulName & MN_TIMER_CLASS_MASK)
    {
    case MN_TIMER_CLASS_CCA:
        /* µ÷ÓÃCCAµÄ¶¨Ê±Æ÷ÏûÏ¢´¦Àíº¯Êý */
        MN_CALL_ProcTimeoutMsg((REL_TIMER_MSG *)pstMsg);
        break;

    case MN_TIMER_CLASS_MSG:
        /* µ÷ÓÃSMAµÄ¶¨Ê±Æ÷ÏûÏ¢´¦Àíº¯Êý */
        MN_MSG_ProcTimeoutMsg((REL_TIMER_MSG *)pstMsg);
        break;

    case MN_TIMER_CLASS_SSA:
        /* µ÷ÓÃSSAµÄ¶¨Ê±Æ÷ÏûÏ¢´¦Àíº¯Êý */
        break;

    case MN_TIMER_CLASS_MMA:
        /* µ÷ÓÃMMAµÄ¶¨Ê±Æ÷ÏûÏ¢´¦Àíº¯Êý */
        break;

    case MN_TIMER_CLASS_APS:
        TAF_APS_ProcMsg(pstMsg);
        break;

    default:
        MN_ERR_LOG("MN_ProcTimerMsg: Unknown timer class.");
        break;
    }
}

/* É¾³ýÔ­ MN_GetUsimMsgClient½Ó¿Úº¯Êý */

VOS_UINT32 MN_GetUsimMsgServerType(struct MsgCB * pstMsg)
{
    VOS_UINT32                          ulServerType;
    PS_USIM_ENVELOPE_CNF_STRU          *pstEnvelope;

    /*´ÓUSIM¹ýÀ´µÄÏûÏ¢ÖÐ³éÈ¡ÒµÎñÀàÐÍ,ÆäÖÐFDN INDÏûÏ¢ÐèÒª MSG ºÍ CALLÄ£¿é´¦Àí*/
    switch (((MSG_HEADER_STRU *)pstMsg)->ulMsgName)
    {
        /* ÐÞ¸ÄÁËFDN¼ì²é»Ø¸´µÄ½á¹¹,SSÊ¹ÓÃclient ID,CALL/MSGÐèÒªÊ¹ÓÃclient IDÅÐ¶Ï */
        case PS_USIM_FDN_CHECK_CNF:
            ulServerType  = TAF_SERVICE_TYPE_UNASSIGNED;
            break;

        case PS_USIM_ENVELOPE_CNF:
            pstEnvelope = (PS_USIM_ENVELOPE_CNF_STRU *)pstMsg;
            if (SI_STK_ENVELOPE_CALLCRTL == pstEnvelope->ucDataType)
            {
                ulServerType  = TAF_SERVICE_TYPE_CALL;
            }
            else
            {
                ulServerType  = TAF_SERVICE_TYPE_MSG;
            }
            break;
        default:
            ulServerType  = TAF_SERVICE_TYPE_MSG;
            break;
    }
    return ulServerType;
}

VOS_VOID  MN_ProcUsimMsg (struct MsgCB * pstMsg)
{
    VOS_UINT32                          ulServerType;

    ulServerType = MN_GetUsimMsgServerType(pstMsg);

    /* ¸ù¾ÝulClient½«USIMÏûÏ¢·Ö·¢µ½¸÷ÒµÎñ´¦Àí£¬Ä¿Ç°ÓÐÁ½¸öÒµÎñ´¦ÀíÄ£¿é */
    switch(ulServerType)
    {
        case TAF_SERVICE_TYPE_MSG:
            MN_MSG_DispatchUsimMsg(pstMsg);
            break;

        case TAF_SERVICE_TYPE_CALL:
            MN_CALL_DispatchUsimMsg(pstMsg);
            break;

        case TAF_SERVICE_TYPE_UNASSIGNED:
            MN_MSG_DispatchUsimMsg(pstMsg);
            MN_CALL_DispatchUsimMsg(pstMsg);
            break;

        default:
            MN_WARN_LOG("MN_ProcUsimMsg: Rcv Invalid ulClient.");
            break;

    }
    return;
}
VOS_VOID  MN_ProcPihMsg (struct MsgCB * pstMsg)
{
    MSG_HEADER_STRU                    *pstMsgHeader = VOS_NULL_PTR;

    pstMsgHeader = (MSG_HEADER_STRU *)pstMsg;

    if (PS_USIM_REFRESH_IND == pstMsgHeader->ulMsgName)
    {
        TAF_CBA_ProcRefreshInd((PS_USIM_REFRESH_IND_STRU *)pstMsgHeader);
        MN_MSG_RcvUsimRefreshInd((PS_USIM_REFRESH_IND_STRU *)pstMsgHeader);
    }

    return;
}


VOS_VOID  MN_ProcMmcMsg (struct MsgCB * pstMsg)
{
    switch (((MSG_HEADER_STRU *)pstMsg)->ulMsgName)
    {
#if ((FEATURE_ON == FEATURE_GCBS) || (FEATURE_ON == FEATURE_WCBS))
        case TAFMMC_CBS_NO_NETWORK_IND:
        case TAFMMC_CBS_CURR_NET_MODE_IND:
            TAF_CBA_MsgProc(pstMsg);
            break;
#endif

        case TAFMMC_APS_SERVICE_STATE_IND:
            TAF_APS_ProcMsg(pstMsg);
            break;

        default:
            MN_WARN_LOG("MN_ProcMmcMsg:Rcv Invalid Msg Type");
            break;
    }
}


VOS_VOID  MN_ProcOmMsg (struct MsgCB * pstMsg)
{
    ID_NAS_OM_INQUIRE_STRU              *pstOmInquire;

    pstOmInquire = (ID_NAS_OM_INQUIRE_STRU *)pstMsg;

    switch ( pstOmInquire->usPrimId )
    {
        case ID_NAS_OM_SET_CODEC_TYPE_REQUIRE :
        case ID_NAS_OM_CODEC_TYPE_INQUIRE :
            MN_CALL_ProcOmMsg(pstMsg);
            break;
        case ID_NAS_OM_SET_DSFLOW_RPT_REQ :
            TAF_APS_ProcMsg(pstMsg);
            break;
        default:
            MN_NORM_LOG("MN_CALL_ProcOmMsg:wrong PrimId!");
            break;
    }

    return;
}

/* begin V7R1 PhaseI Modify */

VOS_VOID MN_ProcUsimStatus(
    struct MsgCB                        * pstMsg
)
{
    MNPH_USIM_STATUS_IND_STRU           *pstUsimStatus;
    MN_CALL_CUSTOM_CFG_INFO_STRU        *pstCustomCfgAddr;

    /* »ñÈ¡ÌØÐÔ¿ØÖÆNVµØÖ· */
    pstCustomCfgAddr                    = MN_CALL_GetCustomCfgInfo();

    MN_MSG_SetSmsFileRefreshFlag(EF_SMS_SMSS_ID, VOS_TRUE);
    MN_MSG_SetSmsFileRefreshFlag(EF_SMS_SMS_ID, VOS_TRUE);
    MN_MSG_SetSmsFileRefreshFlag(EF_SMS_SMSP_ID, VOS_TRUE);
    MN_MSG_SetSmsFileRefreshFlag(EF_SMS_SMSR_ID, VOS_TRUE);


    pstUsimStatus = (MNPH_USIM_STATUS_IND_STRU *)pstMsg;
    MN_MSG_CfgDataInit(pstUsimStatus->enUsimStatus);

#if ((FEATURE_ON == FEATURE_GCBS) || (FEATURE_ON == FEATURE_WCBS))

    TAF_CBA_MsgProc(pstMsg);

#endif

    if (MN_CALL_NV_ITEM_ACTIVE == pstCustomCfgAddr->ucAlsSupportFlg )
    {
        MN_CALL_LineInfo(pstUsimStatus->enUsimStatus);
    }

    /* ÔÚPID init¶ÁÈ¡ºô½ÐÖØ½¨nvµÄÊ±ºòÅÐ¶ÏÊÇ·ñÊÇ²âÊÔ¿¨£¬µ«¿ÉÄÜÓÉÓÚÊ±ÐòÎÊÌâµ¼ÖÂÅÐ¶Ï½á¹û´íÎó£¬
       Òò´ËÔÚÔËÐÐÊ±ÔÙ¶Áµ÷ÓÃÒ»´Î¶ÁÈ¡NVµÄº¯Êý£¬ÔÚº¯ÊýÖÐÅÐ¶ÏÊÇ·ñÊÇ²âÊÔ¿¨ */
    MN_CALL_ReadCallRedialCfgNvim();

    /* ÔÚPID init¶ÁÈ¡ssÖØ½¨nvµÄÊ±ºòÅÐ¶ÏÊÇ·ñÊÇ²âÊÔ¿¨£¬µ«¿ÉÄÜÓÉÓÚÊ±ÐòÎÊÌâusimÎ´³õÊ¼»¯½áÊøµ÷ÓÃusim½Ó¿Ú
       »ñÈ¡ÊÇ·ñÊÇ²âÊÔ¿¨·µ»Ø²»×¼µ¼ÖÂÅÐ¶Ï½á¹û´íÎó£¬Òò´ËÔÚÔËÐÐÊ±ÔÙ¶Áµ÷ÓÃÒ»´Î¶ÁÈ¡NVµÄº¯Êý£¬
       ÔÚº¯ÊýÖÐÅÐ¶ÏÊÇ·ñÊÇ²âÊÔ¿¨ */
    TAF_SSA_ReadSsRetryCfgNvim();

}
/* end V7R1 PhaseI Modify */

#ifndef __PS_WIN32_RECUR__
VOS_VOID TAF_RcvMmaOmMaintainInfoInd(
    struct MsgCB                       *pstMsg
)
{
    MMCM_OM_MAINTAIN_INFO_IND_STRU     *pstOmMaintainInfo;

    pstOmMaintainInfo = (MMCM_OM_MAINTAIN_INFO_IND_STRU*)pstMsg;

    /* ±£´æÈ«¾Ö±äÁ¿µÄÖµ */
    g_ucMnOmConnectFlg       = pstOmMaintainInfo->ucOmConnectFlg;
    g_ucMnOmPcRecurEnableFlg = pstOmMaintainInfo->ucOmPcRecurEnableFlg;

    if ( (VOS_TRUE == g_ucMnOmConnectFlg)
      && (VOS_TRUE == g_ucMnOmPcRecurEnableFlg) )
    {
        NAS_MSG_SndOutsideContextData_Part1();
        NAS_MSG_SndOutsideContextData_Part2();
        NAS_MSG_SndOutsideContextData_Part3();
    }
}
#endif
VOS_VOID  MN_ProcMmaMsg (
    struct MsgCB                        *pstMsg
)
{
    switch (((MSG_HEADER_STRU *)pstMsg)->ulMsgName)
    {
/* begin V7R1 PhaseI Modify */
    case MN_USIM_STATUS_IND:
        MN_ProcUsimStatus(pstMsg);
        break;

#ifndef __PS_WIN32_RECUR__
        case MMCM_OM_MAINTAIN_INFO_IND:
            TAF_RcvMmaOmMaintainInfoInd(pstMsg);

            break;
#endif
/* end V7R1 PhaseI Modify */

        case ID_MMA_MSG_CS_SERVICE_CHANGE_NOTIFY:
            TAF_MSG_RcvMmaCsServiceChangeNotify(pstMsg);
            break;

        case MMA_TAF_POWER_OFF_IND:
            Aps_PowerOff();
            break;

        default:
            MN_WARN_LOG("MN_ProcMmaMsg:Rcv Invalid Msg Type");
            break;
    }
}
VOS_VOID  MN_SndAppMsgToSs (struct MsgCB *pstMsg)
{
    MN_APP_REQ_MSG_STRU                *pstSsMsg    = VOS_NULL_PTR;
    VOS_UINT32                          ulRet;
    VOS_UINT32                          ulMsgLen;
    MN_APP_REQ_MSG_STRU                *pstAppMsg = VOS_NULL_PTR;

    pstAppMsg   = (MN_APP_REQ_MSG_STRU *)pstMsg;
    ulMsgLen    = pstAppMsg->ulLength;

    /* ÉêÇëÏûÏ¢ */
    pstSsMsg = (MN_APP_REQ_MSG_STRU *)PS_ALLOC_MSG(WUEPS_PID_TAF, ulMsgLen);

    if (VOS_NULL_PTR == pstSsMsg)
    {
        MN_WARN_LOG("MN_SndAppMsgToSs: alloc msg fail!");

        return;
    }

    PS_MEM_CPY( ((VOS_UINT8 *)pstSsMsg + VOS_MSG_HEAD_LENGTH), ((VOS_UINT8 *)pstAppMsg+ VOS_MSG_HEAD_LENGTH), ulMsgLen);

    /* Ìî³äÏûÏ¢Í· */
    pstSsMsg->ulReceiverPid = WUEPS_PID_SS;

    ulRet = PS_SEND_MSG(WUEPS_PID_TAF, pstSsMsg);

    if (VOS_OK != ulRet)
    {
        MN_WARN_LOG("MN_SndAppMsgToSs: send msg fail!");
        return;
    }

    return;
}



VOS_VOID TAF_ProcStkEnvelopeCnf(struct MsgCB * pstMsg)
{
    PS_USIM_ENVELOPE_CNF_STRU          *pstEnvelope = VOS_NULL_PTR;

    pstEnvelope = (PS_USIM_ENVELOPE_CNF_STRU *)pstMsg;

    if (SI_STK_ENVELOPE_CALLCRTL != pstEnvelope->ucDataType)
    {
        MN_MSG_RcvUsimEnvelopeCnf(pstMsg);
    }

    return;
}


VOS_VOID MN_DispatchStkMsg(struct MsgCB * pstMsg)
{
    VOS_UINT32                          ulLoop;
    VOS_UINT32                          ulFuncNum;
    MSG_HEADER_STRU                    *pstMsgHeader = VOS_NULL_PTR;
    TAF_STK_MSG_FUNC_MAP                pStkMsgFunc = VOS_NULL_PTR;

    pstMsgHeader = (MSG_HEADER_STRU *)pstMsg;

    ulFuncNum = sizeof(g_astTafStkMsgFuncMap) / sizeof(g_astTafStkMsgFuncMap[0]);

    for (ulLoop = 0; ulLoop < ulFuncNum; ulLoop ++ )
    {
        if (pstMsgHeader->ulMsgName == g_astTafStkMsgFuncMap[ulLoop].ulMsgName)
        {
            pStkMsgFunc             = g_astTafStkMsgFuncMap[ulLoop].pStkMsgFunc;

            /*
                 ´¦Àíº¯Êý²»Çø·ÖÇëÇóµÄÔ´PID£¬¶øSTKµÄÒµÎñÇëÇó½á¹¹ÓëATµÄÒ»ÖÂ£¬ÏûÏ¢Ãû²»Ò»ÖÂ£¬
                 ÒòÎª´¦Àíº¯ÊýÅÐ¶ÏµÄÏûÏ¢Ãû¶¼ÊÇATµÄÏûÏ¢Ãû£¬ÕâÀï½«STKµÄÏûÏ¢Ãû¸üÐÂÎªAPPµÄÏûÏ¢Ãû
              */
            pstMsgHeader->ulMsgName = g_astTafStkMsgFuncMap[ulLoop].ulAppMsgName;
            break;
        }
    }

    if (VOS_NULL_PTR == pStkMsgFunc)
    {
        MN_WARN_LOG("MN_DispatchStkMsg: Invalid Msg Name");
        return;
    }

    pStkMsgFunc(pstMsg);

    return;

}


VOS_VOID  MN_DispatchTafMsg (struct MsgCB * pstMsg)
{
    /* TAF->TAFµÄÏûÏ¢¶¨ÒåÒ»¸öÍ³Ò»µÄ½á¹¹Ìå,È¡³öÏûÏ¢·Ö¶Î */
    TAF_INTERNAL_MSG_STRU              *pstTafMsg = VOS_NULL_PTR;

    pstTafMsg = (TAF_INTERNAL_MSG_STRU *)pstMsg;

    switch (pstTafMsg->ulMsgId & ID_TAF_MNTN_MSG_MASK)
    {
        /* À´×ÔAPS APIµÄÏûÏ¢½»¸øAPS´¦Àí */
        case ID_TAF_APS_INTERNAL_BASE:
            TAF_APS_ProcMsg(pstMsg);
            break;

        /* ·¢ËÍ¸øMSGµÄÏûÏ¢µ½MSG´¦Àí */
        /* Ä¿Ç°Ö»ÓÐID_TAF_SPM_SMMA_REQ,MSGÏÈ·¢ËÍµ½SPM½øÐÐÓòÑ¡Ôñ,ÓòÑ¡ÔñÖ®ºóÔÙµ½MSG´¦Àí */
        case ID_TAF_MSG_INTERNAL_BASE:
            TAF_MSG_ProcTafMsg(pstMsg);
            break;

        /* ÆäËûÏûÏ¢²»ÐèÒª´¦Àí */
        default:
            MN_NORM_LOG("MN_DispatchTafMsg: Unknown message type.");
            break;
    }

    return;
}
VOS_VOID  MN_DispatchAppMsg (struct MsgCB * pstMsg)
{
    MN_APP_REQ_MSG_STRU * pstAppMsg = (MN_APP_REQ_MSG_STRU *)pstMsg;

    switch (pstAppMsg->usMsgName & MN_APP_MSG_CLASS_MASK)
    {
    case MN_APP_MSG_CLASS_CALL:
        /* À´×ÔCCA APIµÄÏûÏ¢£¬½»¸øCCA´¦Àí */
        MN_CALL_ProcAppReqMsg(pstAppMsg);
        break;

    case MN_APP_MSG_CLASS_MSG:
        /* À´×ÔSMA APIµÄÏûÏ¢£¬½»¸øSMA´¦Àí */
        MN_MSG_ProcAppReqMsg(pstAppMsg);
        break;

    case MN_APP_MSG_CLASS_SSA:
        /* À´×ÔSSA APIµÄÏûÏ¢£¬½»¸øSSA´¦Àí */
        MN_SndAppMsgToSs(pstMsg);
        break;

    case MN_APP_MSG_CLASS_MMA:
        /* À´×ÔMMA APIµÄÏûÏ¢£¬½»¸øMMA´¦Àí */
        break;

    /* ÒÆµ½MN_DispatchTafMsgÖÐ´¦Àí */

    case MN_APP_MSG_CLASS_QRY:
        /* ATÓëMNÄ£¿é¼ä²éÑ¯²Ù×÷Ïà¹ØÏûÏ¢ */

        break;

    default:
        MN_ERR_LOG("MN_DispatchAppMsg: Unknown message type.");
        break;
    }
}




VOS_VOID  MN_DispatchRabmMsg (
    VOS_VOID                            *pstMsg
)
{
    MN_RABM_IND_MSG_STRU                *pstRabmMsg;

    pstRabmMsg = (MN_RABM_IND_MSG_STRU *)pstMsg;

    /* ÓÉÓÚRABM·¢µÄÏûÏ¢¸øAPSºÍCALLÁ½¸öÄ£¿é½øÐÐ´¦Àí£¬µ±MsgNameµÄÈ¡Öµ·¶Î§
       ÔÚRABMºÍCALLÖ®¼äµÄ¶¨ÒåµÄÊ±ºò£¬ÓÉÐÂÔöº¯Êý´¦Àí£¬·ñÔòÓÉÔ­ÓÐº¯Êý´¦Àí */
    if (pstRabmMsg->usMsgName > RABM_CALL_MSG_CLASS_BASE)
    {
        MN_CALL_ProcRabmCallPrimitive(pstRabmMsg);
        return;
    }

    TAF_APS_ProcMsg((struct MsgCB *)pstMsg);

}

#if (FEATURE_IMS == FEATURE_ON)

VOS_VOID MN_DispatchImsaMsg (
    VOS_VOID                           *pMsg
)
{
    MSG_HEADER_STRU                   *pstImsaMsg = VOS_NULL_PTR;

    pstImsaMsg = (MSG_HEADER_STRU *)pMsg;

    switch (pstImsaMsg->ulMsgName & TAF_IMSA_MSG_MASK)
    {
        case TAF_MSG_IMSA_MSG_BASE:
            /* ´¦ÀíÀ´×ÔIMSAµÄSMSµÄMSG */
            TAF_MSG_ProcImsaMsg(pstImsaMsg);
            break;

        case TAF_CALL_IMSA_MSG_BASE:
            TAF_CALL_ProcImsaMsg(pstImsaMsg);
            break;

        default:
            break;
    }
}
#endif



VOS_VOID  MN_DispatchMsg (struct MsgCB * pstMsg)
{
    struct MsgCB                      *pstSrcMsg = VOS_NULL_PTR;
    struct MsgCB                      *pstDestMsg = VOS_NULL_PTR;

    if (VOS_NULL_PTR == pstMsg)
    {
        return;
    }

    if (VOS_TRUE == TAF_SDC_GetSvlteSupportFlag())
    {
        /* svlteÌØÐÔ¿ªÆôÊ±£¬modem1¿ÉÄÜÊÕµ½usim0µÄÏûÏ¢£¬ÐèÒª½«ÏûÏ¢ÖÐsend pid½øÐÐ×ª»» */
        pstMsg->ulSenderPid = TAF_SDC_ConvertOamSendPid(pstMsg->ulSenderPid);
    }


    /* Ö§³ÖTD-SCDMAÌØÐÔÊ±£¬Ðè¶ÔÏûÏ¢½øÐÐÊÊÅä´¦Àí */
    if ( VOS_TRUE == NAS_UTRANCTRL_MsgProc(pstMsg, &pstDestMsg) )
    {
        /* ÏûÏ¢ÔÚUTRANCTRLÄ£¿é´¦ÀíÍê³É£¬Ö±½Ó·µ»Ø£¬²»½øÈëºóÐø´¦Àí */
        return;
    }

    pstSrcMsg = pstDestMsg;

    if (VOS_TRUE == TAF_SPM_MsgProc(pstSrcMsg, &pstDestMsg))
    {
        /* ÏûÏ¢ÔÚSPMÄ£¿é´¦ÀíÍê³É,Ö±½Ó·µ»Ø,²»ÐèÒª½øÈëºóÐø´¦Àí */
        return;
    }

    /* Ìæ»»ÏûÏ¢Ö¸Õë */
    switch (pstDestMsg->ulSenderPid)
    {
    case VOS_PID_TIMER:
        MN_ProcTimerMsg(pstDestMsg);
        break;

    case UEPS_PID_CST:
        MN_CALL_ProcCstCallPrimitive(pstDestMsg);
        break;

    case MAPS_STK_PID:
        MN_DispatchStkMsg(pstDestMsg);
        break;

    case WUEPS_PID_TAF:
        MN_DispatchTafMsg(pstDestMsg);
        break;

    case WUEPS_PID_AT:
        MN_DispatchAppMsg(pstDestMsg);
        break;

    case WUEPS_PID_CC:
        MN_CALL_ProcMnccPrimMsg(pstDestMsg);
        break;

    case WUEPS_PID_MMC:
        MN_ProcMmcMsg(pstDestMsg);
        break;

    case WUEPS_PID_MMA:
        MN_ProcMmaMsg(pstDestMsg);
        break;

    case WUEPS_PID_MM:
        break;

    case WUEPS_PID_SS:
        break;

    case WUEPS_PID_SMS:
        MN_MSG_ProcSmsMsg((VOS_VOID*)pstDestMsg);
        break;

#if (FEATURE_IMS == FEATURE_ON)
    case PS_PID_IMSA:
        MN_DispatchImsaMsg((VOS_VOID*)pstDestMsg);
        break;
#endif

    case WUEPS_PID_SM:
        TAF_APS_ProcMsg(pstDestMsg);
        break;

#if (FEATURE_ON == FEATURE_LTE)
    case PS_PID_ESM:
        TAF_APS_ProcMsg(pstDestMsg);
        break;

    case MSP_L4_L4A_PID:
        TAF_APS_ProcMsg(pstDestMsg);
        break;

#endif

    case WUEPS_PID_RABM:
        MN_DispatchRabmMsg(pstDestMsg);
        break;

    case UEPS_PID_SN:
        TAF_APS_ProcMsg(pstDestMsg);
        break;

    case WUEPS_PID_USIM:
    case MAPS_PB_PID:
        MN_ProcUsimMsg(pstDestMsg);
        break;
    case MAPS_PIH_PID:
        MN_ProcPihMsg(pstDestMsg);
        break;

    case WUEPS_PID_OM:
        MN_ProcOmMsg(pstDestMsg);
        break;

    case WUEPS_PID_VC:

         MN_CALL_ProcVCMsg(pstDestMsg);
        break;


#if ((FEATURE_ON == FEATURE_GCBS) || (FEATURE_ON == FEATURE_WCBS))
    case UEPS_PID_GAS:
    case WUEPS_PID_BMC:
#if (FEATURE_ON == FEATURE_LTE)
    case PS_PID_ERRC:
#endif
    case WUEPS_PID_WRR:
        TAF_CBA_MsgProc(pstDestMsg);
        break;

#endif

    case UEPS_PID_NDCLIENT:
        TAF_APS_ProcMsg(pstDestMsg);
        break;

    case ACPU_PID_TAFAGENT:
        TAF_APS_ProcMsg(pstDestMsg);
        break;

    default:
        MN_ERR_LOG1("MN_DispatchMsg: Unknown message sender, SenderPid, ", (VOS_INT32)pstMsg->ulSenderPid);
        break;
    }
}


/*****************************************************************************
 º¯ Êý Ãû  : WuepsTafFidInit
 ¹¦ÄÜÃèÊö  : ³õÊ¼»¯TAF FID
 ÊäÈë²ÎÊý  : ÂÔ
 ·µ »Ø Öµ  : ÂÔ
 µ÷ÓÃº¯Êý  :
 ±»µ÷º¯Êý  :

 ÐÞ¸ÄÀúÊ·      :
  1.ÈÕ    ÆÚ   : 2008Äê1ÔÂ10ÈÕ
    ×÷    Õß   : ¶¡Çì 49431
    ÐÞ¸ÄÄÚÈÝ   : ÐÂÉú³Éº¯Êý
*****************************************************************************/
extern VOS_UINT32 WuepsAdminPidInit ( enum VOS_INIT_PHASE_DEFINE ip );
extern VOS_VOID Admin_TaskEntry  (struct MsgCB * pRcvMsg);
extern VOS_UINT32 WuepsVCPidInit ( enum VOS_INIT_PHASE_DEFINE ip );
extern VOS_VOID  APP_VC_MsgProc(MsgBlock* pMsg);

#if (VOS_WIN32 == VOS_OS_VER)
extern VOS_VOID   At_MsgProc(MsgBlock* pMsg);
extern VOS_UINT32 At_PidInit(enum VOS_INIT_PHASE_DEFINE enPhase);
#endif


VOS_UINT32 WuepsTafFidInit ( enum VOS_INIT_PHASE_DEFINE ip )
{

    VOS_UINT32 ulRslt = VOS_OK;

    switch( ip )
    {
        case   VOS_IP_LOAD_CONFIG:
            ulRslt = VOS_RegisterPIDInfo(WUEPS_PID_ADMIN,
                                        (Init_Fun_Type) WuepsAdminPidInit,
                                        (Msg_Fun_Type) Admin_TaskEntry  );
            if( VOS_OK != ulRslt )
            {
                return VOS_ERR;
            }

            ulRslt = VOS_RegisterPIDInfo(WUEPS_PID_TAF,
                                        (Init_Fun_Type) MN_Init,
                                        (Msg_Fun_Type) MN_DispatchMsg  );
            if( VOS_OK != ulRslt )
            {
                return VOS_ERR;
            }

            ulRslt = VOS_RegisterPIDInfo(WUEPS_PID_VC,
                                         (Init_Fun_Type)WuepsVCPidInit,
                                         (Msg_Fun_Type)APP_VC_MsgProc  );
            if( VOS_OK != ulRslt )
            {
                return VOS_ERR;
            }

            ulRslt = VOS_RegisterPIDInfo(WUEPS_PID_DRV_AGENT,
                                         (Init_Fun_Type)DRVAGENT_Init,
                                         (Msg_Fun_Type)DRVAGENT_DispatchMsg  );
            if( VOS_OK != ulRslt )
            {
                return VOS_ERR;
            }


            #if (VOS_WIN32 == VOS_OS_VER)
            ulRslt = VOS_RegisterPIDInfo(WUEPS_PID_AT,
                                         (Init_Fun_Type)At_PidInit,
                                         (Msg_Fun_Type)At_MsgProc);

            if (VOS_OK != ulRslt)
            {
                return VOS_ERR;
            }
            #endif


            ulRslt = VOS_RegisterMsgTaskPrio(WUEPS_FID_TAF, VOS_PRIORITY_M5);
            if( VOS_OK != ulRslt )
            {
                return VOS_ERR;
            }

            ulRslt = VOS_RegisterPIDInfo(UEPS_PID_MTA,
                                        (Init_Fun_Type)TAF_MTA_InitPid,
                                        (Msg_Fun_Type)TAF_MTA_ProcMsg );
            if( VOS_OK != ulRslt )
            {
                return VOS_ERR;
            }
            break;

        case   VOS_IP_FARMALLOC:
        case   VOS_IP_INITIAL:
        case   VOS_IP_ENROLLMENT:
        case   VOS_IP_LOAD_DATA:
        case   VOS_IP_FETCH_DATA:
        case   VOS_IP_STARTUP:
        case   VOS_IP_RIVAL:
        case   VOS_IP_KICKOFF:
        case   VOS_IP_STANDBY:
        case   VOS_IP_BROADCAST_STATE:
        case   VOS_IP_RESTART:
        case   VOS_IP_BUTT:
            break;
    }

    return VOS_OK;
}


#ifdef  __cplusplus
#if  __cplusplus
}
#endif
#endif

