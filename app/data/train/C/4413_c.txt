#ifndef edan_internal_variant_layout_base_h_
#define edan_internal_variant_layout_base_h_

#include<utility>
#include<memory>
#include<vector>
#include<variant>
#include<string>

namespace edan {

template < //class Self,
           class Tb_
         >
class basic_layout_dataset_variant_base
{
public:
  std::variant < std::vector<int>,
                 std::vector<double>,
                 std::vector<std::string>
               > __data;
public:
  basic_layout_dataset_variant_base() noexcept
  { }

  basic_layout_dataset_variant_base(Tb_&& data) noexcept
   : __data(std::move(data))
  { }

  basic_layout_dataset_variant_base(const Tb_& data) noexcept
   : __data(data)
  { }

  /*
  basic_layout_dataset_variant_base(std::vector<Tp_> vec) noexcept
  : __data(vec)
  { }
  */

  /*
  auto& operator[](int idx)
  {
    std::variant < int,
                   double,
                   std::string
                 > my_variant(__data[]);

    if(__data.index()==0)
    {
      my_variant = std::get<0>(__data)[idx];
      return std::get<0>(my_variant);
    }
    else if(__data.index()==1)
    {
      my_variant = std::get<1>(__data)[idx];
      return std::get<1>(my_variant);
    }
    else if(__data.index()==2)
    {
      my_variant = std::get<2>(__data)[idx];
      return std::get<2>(my_variant);
    }
  }

  const auto& operator[](int _idx) const
  {
    return std::get<0>(__data)[_idx];
  }
  */

  /*
  basic_layout_dataset_variant_base(const Self& other) noexcept
   : __data(other.__data)
  { }

  basic_layout_dataset_variant_base(const Self&& other) noexcept
   : __data(std::move(other.__data))
  { }

  Self& operator=(const Self& other) noexcept
  {
    __data = other.__data;
    return *this;
  }

  Self& operator=(const Self&& other) noexcept
  {
    __data = std::move(other.__data);
    return *this;
  }
  */

  // Need to rewrite function
  auto& data() const noexcept
  {
    return __data;
  }

  auto& data() noexcept
  {
    return __data;
  }
  // overloading == operator?
  //


};
}
#endif
