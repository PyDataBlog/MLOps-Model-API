/***
* Inferno Engine v4 2015-2017
* Written by Tomasz "Rex Dex" Jonarski
*
* [# filter: actions #]
***/

#pragma once

#include "sceneEditorStructure.h"
#include "sceneEditorStructureNode.h"
#include "sceneEditorStructureLayer.h"
#include "sceneEditorStructureGroup.h"
#include "sceneEditorStructureWorldRoot.h"
#include "sceneEditorStructurePrefabRoot.h"

namespace ed
{
    namespace world
    {
        /// context for selection
        class SelectionContext : public base::SharedFromThis<SelectionContext>
        {
            RTTI_DECLARE_VIRTUAL_ROOT_CLASS(SelectionContext);

        public:
            SelectionContext(ContentStructure& content, const base::Array<ContentElementPtr>& selection);
            SelectionContext(ContentStructure& content, const ContentElementPtr& selectionOverride);
            ~SelectionContext();

            //--

            // is the selection empty
            FORCEINLINE const Bool empty() const { return m_selection.empty(); }

            // is the a single object selection
            FORCEINLINE const Bool single() const { return m_selection.size() == 1; }

            // get number of objects in the selection
            FORCEINLINE const Uint32 size() const { return m_selection.size(); }

            // get content we operate on
            FORCEINLINE ContentStructure& getContent() const { return m_content; }

            // all selected objects
            FORCEINLINE const base::Array<ContentElementPtr>& getAllSelected() const { return m_selection; }

            // get unique selection
            FORCEINLINE ContentElementType getUnifiedSelectionType() const { return m_unifiedSelectionType; }

            // get list of unified elements
            FORCEINLINE const base::Array<ContentElementPtr>& getUnifiedSelection() const { return m_unifiedSelection; }

            // get typed list of unified elements
            template< typename T >
            FORCEINLINE const base::Array<T>& getUnifiedSelection() const { return (const base::Array<base::SharedPtr<T>>&) m_selection; }

            // get "or" mask (at least one node has it) of all "features" of selection - unified selection only 
            FORCEINLINE const ContentElementMask getUnifiedOrMask() const { return m_unifiedOrMask; }

            // get "and" mask (all nodes have it) of all "features" of selection - unified selection only 
            FORCEINLINE const ContentElementMask& getUnifiedAndMask() const { return m_unifiedAndMask; }

        private:
            // content
            ContentStructure& m_content;

            // all selected objects
            base::Array<ContentElementPtr> m_selection;

            // unique selection - best 
            ContentElementType m_unifiedSelectionType; // type of the unique selection
            base::Array<ContentElementPtr> m_unifiedSelection; // part of selection that has unified type
            ContentElementMask m_unifiedOrMask;
            ContentElementMask m_unifiedAndMask;

            //--

            void filterSelection();
        };

    } // world
} // ed