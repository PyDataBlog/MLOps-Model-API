// Name:        cat2.c
// Author:      Matayoshi
// Version:     2.1.0
// Last Update: 2011/03/09 Wed
/*
History-----------------------
[+] add; [-] remove; [x] bug fix; [=] optimize;

--Ver.2.1.0(2011/03/09 Wed)
a æØè¶Ìwè@\ðÇÁ

--Ver.2.0.2(2010/06/18 Fri)
x wvbZ[WðC³
= ÇÝÝ@\ðüÇ

--Ver.2.0.1(2010/06/17 Thu)
x tabÌu·@\ÌoOðC³
= t@CüÍpÆWüÍpÌR[hðê

--Ver.2.0.0(2010/06/16 Wed)
+ sÔ\¦@\ðÇÁ
+ tabÌu·@\ðÇÁ
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
//#include <unistd.h>

#define DIGIT_MIN 1
#define DIGIT_MAX 10
#define DIGIT_DEFAULT 5
#define SPACE_MIN 1
#define SPACE_MAX 8
#define SPACE_DEFAULT 4
#define BUFFER_MAX_LEN 64

// IvVÝèp
struct options {
	int lines;		// sÔ\¦
	int num;		// ^uðóÉu«·¦é©?
	char padding;	// óðlßé©A0ðlßé©
	char delimiter;	// æØè¶
};

void help(void);
void show_ver(void);
void disp(struct options option, char *filename);
int replace_print(int num, int count, char *buf);

int main(int argc,char *argv[]) {
//	int c = 0;
	int i = 0;
	int no_options = 0;
//	int use_default = 0;
	struct options option = {
		0,
		0,
		' ',
		' '
	};

	// øÌ`FbN
	for(i = 1; i < argc; i++) {
		if(strcmp(argv[i], "-v") == 0) {			// o[W\¦
			show_ver();
		} else if(strcmp(argv[i], "-h") == 0) {		// wv\¦
			help();
		} else if(strcmp(argv[i], "-z") == 0) {		// óÌãíèÉ0gp
			option.padding = '0';
		} else if(strcmp(argv[i], "-n") == 0) {		// sÔ\¦
			// Ýè
			if(i+1 < argc && sscanf(argv[i+1], "%d", &option.lines) == 1) {
				char buf[BUFFER_MAX_LEN];
				sprintf(buf, "%d", option.lines);// øÍlÅ éÌ©
				if(strcmp(argv[i+1], buf) == 0) {// lÉÏ·µ½ãA¶ñÉß·
					i++;
					if(option.lines < DIGIT_MIN) {	// ÍÍàÉ[ßé
						option.lines = DIGIT_MIN;
					} else if(option.lines > DIGIT_MAX) {
						option.lines = DIGIT_MAX;
					}
				} else {
					option.lines = DIGIT_DEFAULT;
				}
			} else {
				option.lines = DIGIT_DEFAULT;
			}
		} else if(strcmp(argv[i], "-t") == 0) {		// óÌðÝè
			// Ýè
			if(i+1 < argc && sscanf(argv[i+1], "%d", &option.num) == 1) {
				char buf[BUFFER_MAX_LEN];
				sprintf(buf, "%d", option.num);		// øÍlÅ éÌ©
				if(strcmp(argv[i+1], buf) == 0) {// lÉÏ·µ½ãA¶ñÉß·
					i++;
					if(option.num < SPACE_MIN) {	// ÍÍàÉ[ßé
						option.num = SPACE_MIN;
					} else if(option.num > SPACE_MAX) {
						option.num = SPACE_MAX;
					}
				} else {
					option.num = SPACE_DEFAULT;
				}
			} else {
				option.num = SPACE_DEFAULT;
			}
		} else if(strcmp(argv[i], "-d") == 0) {		// æØè¶Ìwè
			if(i < argc) {
				i++;
				option.delimiter = argv[i][0];		// "-d ?"
			} else {
				fprintf(stdout, "delimiter use ' '(space)\n");
			}
		} else if(strncmp(argv[i], "-", 1) == 0) {
			fprintf(stderr, "usage: mycat2 [-h][-v][-n digit][-t num][-d delimiter][-z] [file..]\n");
			exit(1);
		} else {
			no_options++;
		}
	}
/*
	// IvVðÍ
	while((c = getopt(argc, argv, "hvzn:")) != -1) {
		switch (c) {
			case 'h':
				// wvÄÑoµ
				help();
				break;
			case 'v':
				show_ver();
				break;
			case 'n':
				if(sscanf(optarg, "%d", &option.lines) == 1) {
					if(option.lines < DIGIT_MIN) {
						option.lines = DIGIT_MIN;
					} else if(option.lines > DIGIT_MAX) {
						option.lines = DIGIT_MAX;
					}
				} else {
					use_default = 1;
					option.lines = DIGIT_DEFAULT;
				}
				break;
			case 'z':
				option.padding = '0';
				break;
// Rg
			// u-fvIvVªwè³ê½ê f:
			case 'f':
				fprintf( stdout, "-fIvV: %s\n", optarg );
				break;
			// »êÈOÌIvVªwè³ê½ê
// ±±ÜÅ
			default:
				fprintf(stderr, "usage: %s [-h][-v][-n digit][-z] [file..]\n", argv[0]);
				exit(1);
		}
	}
	// -n IvVÅøðwèµÈ©Á½B
	if(use_default == 1) {
		optind--;
	}
	// IvVÈOÌøÉÎ·é
	while(optind < argc) {
		disp(option, argv[optind++]);
	}
*/
	i -= no_options;
	if(i == argc) {
		// t@Cªwè³êÄ¢È¢êÍAWüÍ©çÇÝÞ
		disp(option, NULL);
	} else {
		// t@CðÇÝñÅ\¦
		while(i < argc) {
			disp(option, argv[i++]);
			if(i < argc) {
				fprintf(stdout, "\n");
			}
		}
	}
	return 0;
}

// t@CðÇÝñÅ\¦·é
void disp(struct options option, char *filename) {
	char buf[BUFFER_MAX_LEN] = "\0";	// ÇÝÝobt@
//	int i = 0;
	int count   = 0;					// sÔ
	int newline = 1;					// üs
	int len     = 0;					// 
	char format[16] = "\0";				// sÔptH[}bg
	FILE *fp = stdin;					// t@C|C^

	if(option.lines > 0) {
		// sÔptH[}bgì¬
		sprintf(format, "%%%c%dd%c ", option.padding, option.lines, option.delimiter);
	}

	// t@C¼ªwè³êÄ¢éÈçt@CI[v
	if(filename != NULL && (fp = fopen(filename, "r")) == NULL) {
		// ÇÝæè¸s
		fprintf(stderr,"The file was not able to be opened.");
		return;
	} else {
		// bufferTCYªÇÝoµ
		while(fgets(buf, BUFFER_MAX_LEN, fp) != NULL) {
			// üsã& -n ÈçsÔð\¦
			if(option.lines > 0 && newline == 1) {
				fprintf(stdout, format, ++count);
				newline = 0;
			}
			// üs¶ªÜÜêÄ¢é©ÌmF
			if(strchr(buf, '\n') != NULL) {
				newline = 1;
			}
			if(option.num > 0) {
				len = replace_print(option.num, len, buf);
			} else {
				fprintf(stdout, "%s", buf);
			}
		}
/*
		// ê¶¸ÂoÍ(^uàoÍÂ\)
		while ((i = fgetc(fp)) != EOF) {
			fputc(i, stdout);
		}
*/
		if(filename != NULL) {
			// t@CÌN[Y
			fclose(fp);
			if(len != 0) {
				fprintf(stdout, "\n");
			}
		}
	}
}

int replace_print(int num, int count, char *buf) {
	int i = 0;

	// ê¶¸Â^uðu·µÈªçoÍ
	while(*buf != '\0') {
		switch(*buf) {
			case '\t':
				for(i=0; i<num - (count % num); i++) {
					fputc(' ', stdout);
				}
				count += num - (count % num);
				break;
			case '\n':
				count = -1;
			default:
				count++;
				fputc(*buf, stdout);
				break;
		}
		buf++;
	}
	return count;
}

// o[W\¦
void show_ver(void) {
	fprintf(stdout, "Version.2.1.0\n");
	fprintf(stdout, "Copyright(C)2010-2011. Matayoshi.\n");
	exit(0);
}

// wv\¦
void help(void) {
	fprintf(stdout, "Help\n");
	fprintf(stdout, "This command is an imitation of the cat command of linux.\n\n");
	fprintf(stdout, "format: [-h][-v][-n digit(%d-%-d)][-t num(%d-%d)][-z] [file..]\n",
			 DIGIT_MIN, DIGIT_MAX, SPACE_MIN, SPACE_MAX);
	fprintf(stdout, "-h           : Help is displayed.\n");
	fprintf(stdout, "-v           : Version information is displayed.\n");
	fprintf(stdout, "-n digit     : Show line number. digit default is %d.\n",
			 DIGIT_DEFAULT);
	fprintf(stdout, "-t num       : 1 tab = num spaces. num default is %d.\n",
			 SPACE_DEFAULT);
	fprintf(stdout, "-d delimiter : The line number and text delimiter. default is ' '(space).\n");
	fprintf(stdout, "-z           : Line number padding. 0 is used instead of the space.\n");
	fprintf(stdout, "-h option and -v option are exclusive.\n");
	exit(0);
}
