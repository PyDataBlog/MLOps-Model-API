# author: jet chen
# date: 08/30/2018
#
# make all
# make main
#   make: `./build/main' is up to date.
#
# GNU make的执行过程：
# 1. 编写Makefile, Makefile的本质是定义目标的依赖关系
# 2. GNU make依据在Makefile中定义的目标依赖关系，计算更新路径，更新路径可能有多条或0条，每条路径边由2个target_node定义
# 3. 按所有更新路径，按从支target节点到根target节点进行target节点更新
#
# 整个目标依赖关系的结构为树状，树中有两种节点
#
# NODE_type_1: TARGET Node
# -------------------------------------------------
# | TARGET_NAME_a | TARGET_BLOCK_a | FILE_NAME_a  |
# -------------------------------------------------
# -- TARGET_NAME_a is not null, its type can be root target or non-root target
# -- FILE_NAME_a's file name is the same as full TARGET_NAME_a's target name, but FILE_NAME_a can be existing file or not existing file
#    how to search file with filename==FILE_NAME_a? GNU make will search under VPATH/vpath first, then current dir .
# -- if TARGET_NAME_a is determined need to be updated, then the path from TARGET_NAME_a backtracing to TARGET_root is marked as NEED-TO-BE-UPDATED
# -- how to determin if a TARGET_NAME_a node need to be updated?
#    the method is: for a dependency |TARGET_NAME_a <--- NODE_b|, NODE_b can be TARGET node or pure file NODE

#    term assume:
#      isPhonyTarget(TARGET_NAME_a): return true if TARGET_a been defined as .PHONY target; else return false
#      TimestampOf(TARGET_NAME_a): if file don't exist, then return 0, else return the last generated timestamp of the file
#      MarkAsNeedUpdate(TARGET_NAME_a): mark TARGET_a to be NEED-TOBE-UPDATED, execute all of the commands in TARGET_BLOCK_a
#
#    if(isPhonyTarget(TARGET_NAME_a)) {
#      MarkAsNeedUpdate(TARGET_NAME_a);
#    }
#    else if(TimestampOf(TARGET_NAME_a)==0) {
#      MarkAsNeedUpdate(TARGET_NAME_a);
#    }
#    else if(TimestampOf(TARGET_NAME_a) < TimestampOf(NODE_b)) { //TimestampOf(NODE_b) can be 0
#      MarkAsNeedUpdate(TARGET_NAME_a);
#    }
#    else {
#      //NOT MARK TARGET_NAME_a
#    }
#
#
# NODE_type_2: not TARGET Node, pure file; TARGET node can be leaf or non-leaf, but non target node(pure file node) can only be leaf
# ---------------------------
# |        FILE_NAME_b      |
# ---------------------------
#

CC = gcc
CXX = g++

CCFLAG = -std=gnu99 -g
CXXFLAG = -std=c++11 -g

INCLUDES := -I./\
	-I./common/ \
	-I./add/ \
	-I./minus/ \
	-I./multiply/ \
	-I./devide/

SRCS := $(wildcard ./*.cc)
SRCS += $(wildcard ./*.c)
SRCS += $(wildcard ./add/*.cc)
SRCS += $(wildcard ./minus/*.cc)
SRCS += $(wildcard ./multiply/*.cc)
SRCS += $(wildcard ./devide/*.cc)
SRCS := $(notdir $(SRCS))
$(info "SRC list="$(SRCS))

OBJS = $(SRCS:%.cc=%.o)
OBJS := $(OBJS:%.c=%.o)
$(info "OBJ list="$(OBJS))

BUILD_DIR := ./build

VPATH = ./add:./minus:./multiply:./devide:$(BUILD_DIR) #there is no need to add current dir . into VPATH, because current dir . is in search path by default
$(info "VPATH="$(VPATH))


# targets
# main file can exist, so do not set main as PHONY
.PHONY: pre all clean

_default: pre main

pre:
	@test -e $(BUILD_DIR) || mkdir -p $(BUILD_DIR)

main: $(OBJS)
	$(CXX) -o $(BUILD_DIR)/$@ $(addprefix $(BUILD_DIR)/, $(OBJS))
	@echo "build done"

%.o: %.cc
	@echo "CXX; src=$<, obj=$@"
	$(CXX) $(CXXFLAG) $(INCLUDES) -o $(BUILD_DIR)/$@ -c $<

%.o: %.c
	@echo "CC; src=$<, obj=$@"
	$(CC) $(CCFLAG) $(INCLUDES) -o $(BUILD_DIR)/$@ -c $<

clean:
	@rm -rf $(BUILD_DIR)
