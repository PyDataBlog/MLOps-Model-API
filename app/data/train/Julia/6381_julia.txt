using Distributions

# the dgp. tau quantile of epsilon is 0,
# so tau quantile of y is x*beta
function makeQIVdata(beta::Array{Float64,1}, tau::Float64, n::Int64)
    alpha = [0.0, 0.5, 0.5, -1.0]
    z = [ones(n,1) randn(n,3)]
    P = chol([1.0 0.5; 0.5 1.0])
    ev = randn(n,2)*P
    epsilon = ev[:,1]
    V = ev[:,2]
    D = z*alpha + V
    x = [ones(n,1) D]
    y = x*beta + epsilon
    sig = (tau*(1.0-tau)*(z'z/n))
    siginv = inv(sig)
    cholsig = Array(chol(sig))
    return y,x,z,cholsig,siginv
end

# the moments
function aux_stat(beta::Array{Float64,1}, y::Array{Float64,1}, x::Array{Float64,2},
    z::Array{Float64,2}, tau::Float64)
    n = size(x,1)
    m = mean(z.*(tau .- (y .<= x*beta)),1)
    return m
end

# this function generates a draw from the prior
function sample_from_prior()
	theta = rand(2)
    lb = [-6.0, 0.0]
    ub = [6.0, 4.0]
    theta = (ub-lb).*theta + lb
end

function check_in_support(theta::Array{Float64,1})
    lb = [-6.0, 0.0]
    ub = [6.0, 4.0]
    ok = all((theta .>= lb) .& (theta .<= ub))
    return ok, lb, ub
end


# uniform random walk, with bounds check
function proposal(current, tuning)
    ok = false
    trial = similar(current)
    while ok != true
        trial = current + tuning.*randn(2)
        ok, junk, junk = check_in_support(trial)
    end    
    return trial
end

function likelihood(theta, y, x, z, tau, cholsig, W)
    ghat = aux_stat(theta, y, x, z, tau)
    n = size(x,1)
    lnL = (-0.5*n*ghat*W*ghat')[1,1]
    ghat += randn(size(ghat))*cholsig/sqrt(n) # used for nonparametric fitting
    return lnL, ghat
end

