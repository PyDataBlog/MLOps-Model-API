# *****************************************************************************
# Written by Ritchie Lee, ritchie.lee@sv.cmu.edu
# *****************************************************************************
# Copyright Ã£ 2015, United States Government, as represented by the
# Administrator of the National Aeronautics and Space Administration. All
# rights reserved.  The Reinforcement Learning Encounter Simulator (RLES)
# platform is licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License. You
# may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0. Unless required by applicable
# law or agreed to in writing, software distributed under the License is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the specific language
# governing permissions and limitations under the License.
# _____________________________________________________________________________
# Reinforcement Learning Encounter Simulator (RLES) includes the following
# third party software. The SISLES.jl package is licensed under the MIT Expat
# License: Copyright (c) 2014: Youngjun Kim.
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED
# "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
# NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
# PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
# *****************************************************************************

"""
Create a decision tree to recursively split encounters in the ACASX Problem. GP algorithm.
Example usage: config=configure(ACASX_GP_Tree,"normal","nvn_dasc"); acasx_gp_tree(;config...)
"""
module ACASX_GP_Tree

export configure, acasx_gp_tree, avg_tokens

using ScikitLearn #for metrics
@sk_import metrics: (accuracy_score, f1_score, precision_score, recall_score)

using StatsBase
using ExprSearch.GP
using Datasets
using RLESUtils, Configure, Loggers, LogSystems
using RLESTypes.SymbolTable
using JLD


using GrammarExpts, GBDTs, ACASXProblem, DecisionTreeVis, DecisionTrees
import Configure.configure

const CONFIGDIR = joinpath(dirname(@__FILE__), "..", "config")
const RESULTDIR = joinpath(dirname(@__FILE__), "..", "..", "..", "results")
const T1 = Bool #predict_type
const T2 = Int64 #label_type

configure(::Type{Val{:ACASX_GP_Tree}}, configs::AbstractString...) = 
    configure_path(CONFIGDIR, configs...)

"""
Example call:
config=configure(ACASX_GP_Tree, "nvn_dasc", "normal")
acasx_gp_tree(; config...)
"""
function acasx_gp_tree(;outdir::AbstractString=joinpath(RESULTDIR, "./ACASX_GP_Tree"),
                        seed=1,
                        logfileroot::AbstractString="acasx_gp_tree_log",

                        #dataset
                        data::AbstractString="dascfilt",
                        grammar_version::Symbol=:no_flags,

                        #decision tree
                        max_gbdt_depth::Int64=1,

                        #GP
                        pop_size::Int64=100,
                        max_deriv_tree_depth::Int64=10,
                        iterations::Int64=10,
                        tournament_size::Int64=20,
                        top_keep::Float64=0.1,
                        crossover_frac::Float64=0.3,
                        mutate_frac::Float64=0.3,
                        rand_frac::Float64=0.2,
                        default_code::Any=:(eval(false)),

                        #ACASX Problem
                        w_metric::Float64=ACASXProblem.W_METRIC,
                        w_num_nodes::Float64=ACASXProblem.W_NUM_NODES,

                        train_frac::Float64=0.7,
        
                        #DT vis
                        vis::Bool=true,
                        plotpdf::Bool=true,
                        limit_members::Int64=10,

                        #save tree
                        b_jldsave::Bool=true
                        )

    srand(seed)
    mkpath(outdir)

    problem = ACASXClustering(data, grammar_version, w_metric, w_num_nodes)
    all_data = problem.data
    train_data, test_data = split_data(all_data, train_frac)
    train_inds = train_data.data.meta[:id]
    problem.data = train_data

    gp_logsys = GP.logsystem()
    send_to!(STDOUT, gp_logsys, ["verbose1", "current_best_print"])
    gp_paramfile = open(joinpath(outdir, "gp_params.txt"), "w")
    send_to!(gp_paramfile, gp_logsys, ["parameters"])
    gp_params = GPESParams(pop_size, max_deriv_tree_depth, iterations, tournament_size, top_keep,
        crossover_frac, mutate_frac, rand_frac, default_code, gp_logsys)
    gbdt_logsys = GBDTs.logsystem()
    send_to!(STDOUT, gbdt_logsys, ["verbose1", "split_result_print"])
    logs = TaggedDFLogger()
    send_to!(logs, gbdt_logsys, ["computeinfo", "parameters", "elapsed_cpu_s", 
        "members", "classifier_metrics", "interpretability_metrics", "split_result"])

    gbdt_params = GBDTParams(problem, length(problem.data), gp_params, max_gbdt_depth, 
        T1, T2, gbdt_logsys)
  
    result = induce_tree(gbdt_params)

    close(gp_paramfile)

    #test
    test_labels = classify(result, getrecords(test_data))
    y_pred, y_true = test_labels, labels(test_data)
    acc = accuracy_score(y_true, y_pred)
    f1 = f1_score(y_true, y_pred; average=:macro)
    precision = precision_score(y_true, y_pred; average=:macro)
    recall = recall_score(y_true, y_pred; average=:macro)

    ##################################
    #add local items to log -- this is messy, revamp this.
    push!(logs, "parameters", ["seed", seed])
    push!(logs, "parameters", ["grammar_version", string(grammar_version)])
    push!(logs, "parameters", ["data", data])
    push!(logs, "parameters", ["train_frac", train_frac])
    push!(logs, "parameters", ["train_inds", train_inds])

    push!(logs, "parameters", ["pop_size", pop_size])
    push!(logs, "parameters", ["max_deriv_tree_depth", max_deriv_tree_depth])
    push!(logs, "parameters", ["iterations", iterations])
    push!(logs, "parameters", ["tournament_size", tournament_size])
    push!(logs, "parameters", ["top_keep", top_keep])
    push!(logs, "parameters", ["crossover_frac", crossover_frac])
    push!(logs, "parameters", ["mutate_frac", mutate_frac])
    push!(logs, "parameters", ["rand_frac", rand_frac])
    push!(logs, "parameters", ["default_code", string(default_code)])
    push!(logs, "parameters", ["w_metric", w_metric])
    push!(logs, "parameters", ["w_num_nodes", w_num_nodes])

    add_folder!(logs, "classifier_test_metrics", [Float64, Float64, Float64, Float64], 
        ["accuracy", "f1_score", "precision", "recall"])
    push!(logs, "classifier_test_metrics", [acc, f1, precision, recall])

    outfile = joinpath(outdir, "$(logfileroot).txt")
    save_log(LogFile(outfile), logs)
    ##################################

    #visualize
    if vis
        problem.data = all_data
        userargs = SymbolTable(:params=>gbdt_params)
        members = collect(1:length(problem.data))
        update_members!(result.decision_tree, members, userargs) 
        decisiontreevis(result.decision_tree, problem.data, 
            joinpath(outdir, "$(logfileroot)_vis"), limit_members, FMT_PRETTY, 
            FMT_NATURAL, :encounter_id; plotpdf=plotpdf, level_dist_cm=5.0)
    end
    
    if b_jldsave
        jldfile = joinpath(outdir, "save.jld")
        save(jldfile, "dtree", result.decision_tree)
    end
    result
end

using AbstractTrees
using RLESUtils, StringUtils, FileUtils
units=[" ft/s", " deg/s", " ft", " deg", " s"] #longer overlapping units first
function avg_tokens(jldfile::AbstractString)
    dtree = load(jldfile, "dtree")
    strs = String[]
    for node in PreOrderDFS(dtree.root)
        if node.split_rule != nothing
            s = pretty_string(node.split_rule.tree,FMT_PRETTY)
            push!(strs, s)
        end
    end
    textfile(joinpath(dirname(jldfile),"split_rules_pretty.txt"), strs...)
    strs = map(s->replace(s, units), strs)
    return mean([length(collect(Leaves(parse(s)))) for s in strs])
end


end #module
