module Utils

using PyPlot

export
  gaussian

function lerp(x1::Float64, y1::Float64, x2::Float64, y2::Float64, x::Float64)
  y = y2
  if x2 == x1
    if y2 != y1
      throw(DivideError())
    end
  else
    y = y1 + ((y2-y1) / (x2-x1)) * (x - x1)
  end
  return y
end


function gaussian(σ::Real, l = 4*ceil(Int,σ)+1)
    isodd(l) || throw(ArgumentError("length must be odd"))
    w = l>>1
    g = [exp(-x^2/(2*σ^2)) for x=-w:w]
    g/sum(g)
end


function berp(xin::Float64, yin::Float64, x1::Float64, y1::Float64, x2::Float64, y2::Float64, z::Vector{Float64})
  if length(z) != 4
    throw(DomainError())
  end
  mul = convert(Float64, 1 / ((x2 - x1) * (y2 - y1)))
  x = [(x2 - xin), (xin - x1)]
  y = [y2 - yin, yin - y1]
  z = transpose(reshape(z,(2,2)))
  z_out = x' * z * y * mul
  return z_out
end

function simplelpfilter(a, x::Float64, y::Float64)
  return a * x + (1 - a)*y
end

function convolution!(u::Array{Float64, 1}, v::Array{Float64, 1})
    v = reverse(v)
    nu = length(u)
    nv = length(v)
    y = Float64[]
    n = nu + nv - 1
    for i=1:n

      push!(y, p)
    end
end

function mygauss!(A, b)
    brow, bcol = size(b)
    arow, acol = size(A)

    if brow != arow
        throw(ArgumentError("Wrong dimension of b args"))
    end

    Ab = [A b]
    abrow, abcol = size(Ab)

    for k=1:min(abrow, abcol)

        # find maximaum value in this column
        maxval, imax = findmax(Ab[k:arow, k])
        imaxr, imaxc = ind2sub(Ab, imax)

        if maxval > Ab[k, k]
            tmp = Ab[k, :]
            Ab[k, :] = Ab[imaxr, :]
            Ab[imaxr, :] = tmp
        end

        for i=k+1:abrow
            l = -Ab[i, k] / Ab[k, k]
            for j=1:abcol
                Ab[i, j] = Ab[i, j] + Ab[k, j] * l
            end
        end
    end

    x = zeros(abrow)
    for i=abrow:-1:1
        x[i] = Ab[i, abcol] / Ab[i, i]
        for j=i:-1:1
            Ab[j, abcol] -= Ab[j, i] * x[i]
        end
    end

    return Ab, x
end


realmin2(::Type{Float32}) = reinterpret(Float32, 0x26000000)
realmin2(::Type{Float64}) = reinterpret(Float64, 0x21a0000000000000)
realmin2{T}(::Type{T}) = (twopar = 2one(T); twopar^trunc(Integer,log(realmin(T)/eps(T))/log(twopar)/twopar))

function givensAlgo(f::AbstractFloat, g::AbstractFloat)
    r = sqrt(f*f + g*g)
    c = f/r
    s = g/r
    return c, s, r
end

"""
Rotationsmatrix
"""
function rotation_matrix{T<:AbstractFloat}(f::T, g::T, i1::Integer, i2::Integer, size::Integer)
    c, s, r = givensAlgo(f, g)
    R = eye(size)
    R[i1, i1] = c
    R[i1, i2] = s
    R[i2, i1] = -s
    R[i2, i2] = c
    return R
end

function exp_r(a, n)
    ret = 1
    if n > 0
        ret = a^n/factorial(n) + exp_r(a, n-1)
    end
    return ret
end

"""
QR-Faktorisierung mittels Givens Rotationsmatrix
"""
function qr_givens_rotation(A)
    m, n = size(A) # m Rows and n Columns

    Q = eye(n)
    R = copy(A)

    for i=1:n
        for j=1+i:m

            if R[i, j] == 0
                continue
            end

            G = rotation_matrix(R[i, i], R[j, i], i, j, n)
            R = G*R
            Q = Q*G'
        end
    end
    return Q, R
end

function maxelem(a, tol)1/500
    m, n = size(a)

    if m != n
        throw(ArgumentError("Not symmetric matrix passed!"))
    end

    amax = 0.0
    k = l = 0
    for i=1:n
        for j=i+1:n
            if abs(a[i,j]) >= amax
                amax = abs(a[i,j])
                k = i
                l = j
            end
        end
    end
    return (amax, k, l)
end

function get_jacobi_rotation_matrix(a, p, q)
    R = eye(size(a)[1])

    D = (a[q,q] - a[p,p]) / (2*a[p,q])
    t = sign(D) * 1/(abs(D) + sqrt((D*D) + 1))

    c = 1 / sqrt(1+(t*t))
    s = t*c

    R[p,p] = c
    R[q,q] = c
    R[p,q] = s
    R[q,p] = -s
    return R
end
#
function jacobi_eigensystem(a, tol)
    e = copy(a)
    R = eye(size(a)[1])
    E = copy(R)
    while true
        amax, p, q = maxelem(e, tol)
        if amax <= tol
            break
        end

        R = get_jacobi_rotation_matrix(e, p, q)
        e = R'*e*R
        E = E*R
        # print("e=$A; R=$R")
    end
    return e, E
end

function ind2subi(A, i)
    n, m = size(A)
    r = i % n
    c = convert(Int , floor((i / n) + 0.5))
    return r,c
end

end # module Utils
