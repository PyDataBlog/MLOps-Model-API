#Compute first few periodic orbits of Lorenz system.

using PyPlot
using ODE

#construct Lorenz system

function lorenzmap(time, pos)

	#constants

	sigma 	 = 10.0
	beta 	 = 8.0 / 3.0
	rho  	 = 28.0

	#store position as 3-tuple

	x, y, z	 = pos

	# Lorenz equations

	lorenz1  = sigma * (y - x) 
	lorenz2	 = x * (rho - z) - y
	lorenz3  = - beta * z - x * y
	lorenz   = [lorenz1; lorenz2; lorenz3]

	return lorenz

end

# Compute Lorenz trajectory over a given time range for a given initial condition

function lorenzintegrate(initcond, endtime, timestep)

	timespan = collect( 0.0 : timestep : endtime)

		
	(~, pos) = ode45(lorenzmap, initialcondition, timespan)

	x = map(v -> v[1], pos)
	y = map(v -> v[2], pos)
	z = map(v -> v[3], pos)

	return (timespan, x, y, z)

end

# plot computed trajectory

function rosslerplot(initialcondition, endtime, timestep)

	clf()

	timespan = collect(0 : timestep : endtime)

	(~, x, y, z) = collect(0 : timestep : endtime)

	plot3D(x, y, z)
		xlabel("x")
		ylabel("y")
		zlabel("z") 
		axis("tight")


end

function lorenzreturn(etastep, timestep, endtime)

	# construct approximate poincare section
	# parametrize 0 <= eta <= 1

	eta = collect( -1 : etastep : 1)
	poincare = zeros(3, length(eta))

	for i in collect(1 : 1 : length(eta))

		xj = 8 * eta[j]

		poincare[1, j] = xj
		poincare[2, j] = xj - 0.01 * xj * (xj - 8) * (x + 8)
		poincare[3, j] = 13 + 0.118 * x^2
		
	end	

	# integrate lorenz equations starting at each point on poincare section

	feta = zeros(2, tf / dt)
	index = 1

	for j in collect(1 : 1 : length(eta) - 1)

		initcond = poincare[:, j]
		~, x, y, z = lorenzintegrate(initcond, endtime, timestep) 

	end
