function poo_binary(
        objective::Function, horizon::Int, nu::Float64, rho::Float64,
        max_depth::Int, K::Float64)
    d_max = log(K) / log(1./rho)
    nb_evals = 0
    nb_hoo = 1
    big_tree = Tree()
    add_depth(big_tree, [big_tree.root])
    hoo_instances = [(nu, rho)]
    empty_tree = Tree()
    add_depth(empty_tree, [empty_tree.root])
    trees::Vector{Tree} = [empty_tree]
    while nb_evals < horizon
        while (nb_evals > 1
               && nb_hoo >= 0.5 * d_max * log(nb_evals / log(nb_evals)))
            for i=1:nb_hoo
                new_rho = rho^(2.*nb_hoo / (2*i+1))
                new_params = (nu, new_rho)
                push!(hoo_instances, new_params)
                tree = Tree()
                add_depth(tree, [tree.root])
                for t=1:(convert(Float64, nb_evals)/nb_hoo)
                    tree = hoo_step(
                        objective, tree, big_tree, max_depth, nu, new_rho, t)
                end
                push!(trees, tree)
            end
            nb_evals *= 2
            nb_hoo *= 2
        end
        for (idx, params) in enumerate(hoo_instances)
            nu, rho = params
            tree = trees[idx]
            t = convert(Int, convert(Float64, nb_evals)/nb_hoo) + 1
            trees[idx] = hoo_step(
                objective, tree, big_tree, max_depth, nu, rho, t)
        end
        nb_evals += nb_hoo
    end
    means = [tree.nodes[tree.root].mean for tree in trees]
    best_hoo = indmax(means)
    # TODO return one random point from best hoo instead of best point ?
    (best_arm, max_mean) = get_best(trees[best_hoo])
    return (trees[best_hoo], best_arm, max_mean)
end
