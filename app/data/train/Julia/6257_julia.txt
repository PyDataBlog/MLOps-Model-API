function iterDeep(board::Pos, maxDepth, evalf=boardeval, output=true)
    if board.tcount[board.cmove] == 0 # player has lost no tower left
        return []
    end
    ml = possibleJumps(board)
    jumps = length(ml)
    if jumps == 0
        ml = possibleSteps(board)
    end

    if length(ml) == 0
        print("You should never see this.")
        return []
    end

    if length(ml) == 1
        # forced (only) move
        return ml.moves[1]
    end
    
    nodevalue=Vector{Int}(length(ml))
    for depth in 1:maxDepth
        if output
            print("Depth ", depth, "\n")
        end
        for i in 1:length(ml)
            nodevalue[i] = -evaluateTree( executeMove!(deepcopy(board), ml.moves[i]), depth, -Inf, Inf, boardeval   )
            if output
                print("Move: "); printMove(ml.moves[i]); print( " Value: ", nodevalue[i], "\n" )
            end
        end
    end
    return ml.moves[findmax(nodevalue)[2]]
end

function evaluateTree(board::Pos, maxDepth, alpha, beta, evalf=boardeval)
    if board.tcount[board.cmove] == 0 # player has lost no tower left
        return -100000 + maxDepth 
    end

    ml = possibleJumps(board)
    jumps = length(ml)
    if jumps == 0
        ml = possibleSteps(board)
    end

    if length(ml) == 0 # player has lost, no moves, stalemate
        return -100000 + maxDepth
    end
    
    if maxDepth > 0 # search goes deeper
        nodevalue=Vector{Int}(length(ml))
        for i in 1:length(ml)
            nodevalue[i] = -evaluateTree(executeMove!(deepcopy(board),ml.moves[i]),maxDepth-1,-beta,-alpha,evalf)
            if nodevalue[i] >= beta
                return beta
            end
            if nodevalue[i] > alpha
                alpha = nodevalue[i]
            end
        end
        return alpha
    else #leave
        if jumps > 0
            nodevalue=Vector{Int}(jumps)
            for i in 1:jumps
                nodevalue[i] = -evalQuietTree(executeMove!(deepcopy(board),ml.moves[i]),maxDepth-1,-beta,-alpha,evalf)
                if nodevalue[i] >= beta
                    return beta
                end
                if nodevalue[i] > alpha
                    alpha = nodevalue[i]
                end
            end
            return alpha
        else # quiet position
            return evalf(board)
        end
    end
end

function evalQuietTree(board::Pos, maxDepth, alpha, beta, evalf=boardeval)
    ml = possibleJumps(board)
     jumps = length(ml)
#    if jumps == 0
#        ml = possibleSteps(board) # possibleSeps durch exisitsStep ersetzten!
#    end
 
    if jumps==0
        if existsStep(board) # no jumps, but moves
            return evalf(board)
        else  #lost
            return -100000 + maxDepth
        end
    else
        nodevalue=Vector{Int}(jumps)
        for i in 1:jumps
            nodevalue[i] = -evalQuietTree(executeMove!(deepcopy(board),ml.moves[i]),maxDepth-1,-beta,-alpha,evalf)
            if nodevalue[i] >= beta
                return beta
            end
            if nodevalue[i] > alpha
                alpha = nodevalue[i]
            end
        end
        return alpha        
    end
end
