\section{Future Work}
\label{sec:future}

\paragraph{Refinement extensions.}
Although we have expanded the vocabulary of example-directed synthesis to include a far richer
and more general collection of constructs, there are a veriety of other components that we might
adopt from type theory.  Dependent types and refinements would allow us to
write more expressive specifications than those descripted in Section 2.3.  Similarly, we might
add true base types --- integers, floating point numbers, and strings --- with corresponding theories
integrated into the refinement system.


\paragraph{Library intake.}
Although we focus mainly on self-contained synthesis problems,
real-world synthesis systems need the ability to make use of libraries of existing code.
The approaches for doing so developed in this paper remain primitive, enumerating arguments
for library functions in hopes that the proper expression will eventually be discovered.
These strategies can only use libraries in cases where the candidate arguments are described
by refinements that correspond to values, since evaluating a library on any other argument
is impossible.  Furthermore, the prototype is incapable of integrating polymorphic libraries,
since doing so requires enumerating type parameters before doing the same for arguments. A more
powerful library-intake system might make use of symbolic execution (rather than evaluation)
to produce more general and descriptive refinements for libraries.

\paragraph{Intelligent proof search.}
Much of Section \ref{sec:implementation} explores methods for coping with the enormous
nondeterminism inherent in the sequent calculus even after employing focusing and
invertibility.  Strategy 0, the naive refinement-directed search, fails because the
synthesizer faces an overwhelming number of branches to explore in a breadth-first
manner.  Attempting even to visit each branch once proves prohibitively expensive.
Rather than attempting to deviate from Strategy 0, perhaps we should instead
reconsider the premise of performing breath-first search over the space of candidate
programs.  One such avenue would be to build a learning theorem-prover that intelligently
pursues particular paths first based upon context and past experience, an approach that
might make seemingly vast search spaces more tractable to traverse.  This information
could even be gleaned by examining repositories of existing code to prioritize programs
that are more likely to be written in practice.