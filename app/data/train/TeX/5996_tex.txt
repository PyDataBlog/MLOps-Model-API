% !TeX spellcheck = russian_english
% !TeX encoding = UTF-8
\documentclass[a4paper, fleqn]{article}

\usepackage{indentfirst} % Красная строка
\usepackage[T2A]{fontenc} % Поддержка русских букв
\usepackage[utf8]{inputenc} % Кодировка utf8
\usepackage[russian]{babel} % руссификация
\usepackage{amssymb} % дополнительные символы
\usepackage{textcomp} % дополнительные текстовые символы
\usepackage{amsmath} % матрицы
\usepackage{listings}
% листинги
\lstset{language=Python, tabsize=4, language=Python}


\textwidth = 16 cm
\oddsidemargin= 0 cm
\evensidemargin= 1 cm


% \abovedisplayskip = 0 pt %.2\abovedisplayskip
% \belowdisplayskip = .2\belowdisplayskip
% \abovedisplayshortskip=.2\abovedisplayshortskip
% \belowdisplayshortskip=.2\belowdisplayshortskip
% \topsep= 0 pt

% \setlength{\mathindent}{1.2 cm}
% \setlength{\topsep}{0 pt}
% \setlength{\abovedisplayskip}{0 pt}

% \clubpenalty = 5000 % запрет висячих строк
% \widowpenalty = 5000
\binoppenalty=10000
\relpenalty=10000

% собственные команды и окружения

\newenvironment{example}[1][]{\medskip \noindent \textbf{Пример. #1}\par \nopagebreak}{\medskip \par} % окружение-"пример"


\title{Лекция \textnumero\,7}
% {\huge \vspace{3 cm}}}

\author{Т.\,Ф. Хирьянов}

\date{}

\begin{document}
	\maketitle

\subsection*{Поиск корней функции}

Данная задача не является тривиальной. Например, для функции
\[f(x) = \sin{\frac{1}{x}}\]
В сколь угодно малой окрестности нуля найдется бесконечное колличество нулей. Более того, в прикладных задачах поведение функции неизвестно, а значит, между любыми двумя точками она может несколько раз пересечь ось абсцисс. Поэтому для решения данной задачи необходимо использовать выводы из математического анализа, а именно лемму о промежуточных значениях непрерывной функции. Из нее следует, что если функция непрерывна на отрезке $[a, b]$, то на нем она обязательно принимает все значения от $f(a)$ до $f(b)$ (при условии, что $f(b) > f(a)$). Поэтому если найден такой отрезок, на котором функция непрерывна и имеет противоположные по знаку значения, то на этом отрезке функция обязательно имеет корень.
% 05:18

\subsection*{Биссекция}

% 07:55
Для описанной выше ситуации существует алгоритм, который позволяет сколь угодно точно определить корень функции. Идея алгоритма биссекции заключается в следующем. Вычисляется значение функции в середине отрезка. Если оно равно нулю, то корень найден, если больше либо меньше нуля, то производится сужение отрезка, содержащего корень. Действительно из постановки задачи следует, что $f(a)*f(b) < 0$. Следовательно либо $f(a)*f(c) < 0$, либо $f(c)*f(b) < 0$. Допустим, что верно первое. Тогда нужно заменить правую границу $b$ отрезка $[a, b]$ на с. Получившийся отрезок $[a, c]$ вдвое меньше и удовлетворяет всем условиям задачи, а значит, с ним можно провести такие же действия. Из этого следует, что искомый корень после $n$ таких итераций будет находится, например, в середине текущего отрезка с точностью до половины последнего. Задание необходимой точности обеспечивает выход из цикла.
% мой листинг
%\ttfamily{
%	\begin{tabbing}
%		\hspace{8mm}\=\hspace{8mm}\=\hspace{4cm}\=\kill
%
%	\end{tabbing}
%}
\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{4cm}\=\kill
		f\_a = f(a)\\
		f\_b = f(b)\\
		while abs(b - a) > eps*2:\\
		\> c = (a + b)/2\\
		\> f\_c = f(c)\\
		\> if f\_c*f\_a < 0:\\
		\> \> b = c \> \# a = a\\
		\> elif f\_c*f\_a > 0:\\
		\> \> a = c \> \# b = b\\
		\> else:\\
		\> \> break
	\end{tabbing}
}
\subsection*{Поиск в списке}
% 17:30
Если производить поиск конкретного значения в неупорядоченном списке, то будет осуществляться последовательный перебор его элементов и количество операций будет сравнимо с $N$. Однако если список упорядочен по неубыванию, то можно воспользоваться аналогом алгоритма поиска корня функции методом деления пополам.

Сначала задаются значения индексов, ограничивающих индексы элементов списка. Затем в цикле диапазон значений индексов разделяют пополам аналогично предыдущему алгоритму (деление, конечно, целочисленное). Выход из цикла осуществляется, когда диапазон сокращается до одного элемента.
При этом возвращается номер элемента массива наиболее близкого к искомому значению, но превышающего его. Если искомое значение меньше всех элементов, то возвратится ноль, если больше  -- N.
%
% 42:00
\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{3cm}\=\kill
		def upper\_bond(key, A):\\
		\> A = sorted(A)\\
		\> l = -1\\
		\> r = len(A)\\
		\> while r > l + 1:\\
		\> \> m = (l + r)//2\\
		\> \> if A[m] > key:\\
		\> \> \> r = m\\
		\> \> else: \> \> \# A[m] $\leqslant$ key\\
		\> \> \> l = m\\
		\> return r
	\end{tabbing}
}
\subsection*{Сортировка списка}
% 48:00

Для того чтобы отсортировать список (сделать его упорядоченным) существует множество алгоритмов. Одной из самых долгих является
сортировка обезьяны.

\subsection*{Сортировка обезьяны}

Для реализации данного алгоритма необходима функция, перемешивающая элементы в массиве. В стандартной библиотеке Python есть такая функция shuffle. Ее можно подключить из модуля random следующим образом.
\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{4cm}\=\kill
		from random import shuffle
	\end{tabbing}
}
Описанная ниже функция \texttt{monkey\_sort} перемешивает список, пока он не станет отсортированным.
\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{4cm}\=\kill
		def monkey\_sort(A):\\
		\> while not is\_sorted(A):\\
		\> \> shuffle(A)
	\end{tabbing}
}
При этом вызывается функция \texttt{is\_sorted}, проверяющая, является ли текущий список упорядоченным.
\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{4cm}\=\kill
		def is\_sorted(A):\\
		\> return A == sorted(A)\\
	\end{tabbing}
}
Так как количество перестановок $n$ элементов равно $n!$,  то количество операций пропорционально $n!$.

\subsection*{Сортировка вставками}

% 54:35
Существует гораздо более быстрые алгоритмы. Одним из них является алгоритм сортировки вставками.
В нем последовательно пробегаются все элементы, правее крайнего левого. Каждый следующий элемент вставляется в уже отсортированную часть списка, расположенную левее, причем так, чтобы упорядоченность сохранилась. В приведенном ниже примере использован циклический сдвиг, и соответствующая сложность алгоритма пропорциональна $N^2$. Однако алгоритм можно улучшить, если использовать рассмотренную ранее функцию upper\_bond для поиска места, в которое необходимо переставить текущий элемент.
%
%1:05:00
\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{3cm}\=\kill
		def insertion\_sort(A):\\
		\> for i in range(1, len(A)):\\
		\> \> new\_elem = A[i]\\
		\> \> j = i - 1\\
		\> \> while j >= 0 and A[j] > new\_elem:\\
		\> \> \> A[j + 1] = A[j] \> \# сдвиг\\
		\> \> \> j -= 1\\
		\> \> A[j + 1] = new\_elem
	\end{tabbing}
}
Однако алгоритм можно улучшить, если использовать рассмотренную ранее функцию upper\_bond для поиска места, в которое необходимо переставить текущий элемент.

\end{document}
