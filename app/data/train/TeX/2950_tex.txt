\hypertarget{eval_8h}{
\section{/home/doki/AGCS/src/mmanager/eval.h File Reference}
\label{eval_8h}\index{/home/doki/AGCS/src/mmanager/eval.h@{/home/doki/AGCS/src/mmanager/eval.h}}
}


\subsection{Detailed Description}
Header for \hyperlink{eval_8c}{mmanager/eval.c}. 

\begin{Desc}
\item[Author:]Dorian Ivancic \href{mailto:dorian@linux.hr}{\tt dorian@linux.hr} \end{Desc}
\begin{Desc}
\item[Date:]2005-03-28, 2005-04-09\end{Desc}
\begin{Desc}
\item[Warning:]None so far.\end{Desc}
\begin{Desc}
\item[\hyperlink{bug__bug000048}{Bug}]There are no known bugs. \end{Desc}


Definition in file \hyperlink{eval_8h-source}{eval.h}.

{\tt \#include \char`\"{}event.h\char`\"{}}\par
{\tt \#include \char`\"{}cmdline.h\char`\"{}}\par
\subsection*{Enumerations}
\begin{CompactItemize}
\item 
enum \hyperlink{eval_8h_9e1477c20853772b8f60c1285c25978e}{ret\_\-\_\-eval\_\-event} \{ \par
\textbf{RET\_\-\_\-EVAL\_\-EVENT\_\-\_\-SUCCESS} = 1, 
\textbf{RET\_\-\_\-EVAL\_\-EVENT\_\-\_\-UNKN\_\-EVENT}, 
\textbf{RET\_\-\_\-EVAL\_\-EVENT\_\-\_\-NO\_\-SUCH\_\-CLASS}, 
\textbf{RET\_\-\_\-EVAL\_\-EVENT\_\-\_\-NOT\_\-ENOUGH\_\-MEMORY}, 
\par
\textbf{RET\_\-\_\-EVAL\_\-EVENT\_\-\_\-UNKNOWN\_\-ERROR}, 
\textbf{RET\_\-\_\-EVAL\_\-EVENT\_\-\_\-DESTINATION\_\-OBJECT\_\-DOES\_\-NOT\_\-EXIST}, 
\textbf{RET\_\-\_\-EVAL\_\-EVENT\_\-\_\-OBJECT\_\-DOES\_\-NOT\_\-EXIST}, 
\textbf{RET\_\-\_\-EVAL\_\-EVENT\_\-\_\-MEMBER\_\-DOES\_\-NOT\_\-EXIST}, 
\par
\textbf{RET\_\-\_\-EVAL\_\-EVENT\_\-\_\-STATIC\_\-CLASS\_\-DOES\_\-NOT\_\-EXIST}, 
\textbf{RET\_\-\_\-EVAL\_\-EVENT\_\-\_\-STATIC\_\-MEMBER\_\-DOES\_\-NOT\_\-EXIST}, 
\textbf{RET\_\-\_\-EVAL\_\-EVENT\_\-\_\-ARRAY\_\-DOES\_\-NOT\_\-EXIST}, 
\textbf{RET\_\-\_\-EVAL\_\-EVENT\_\-\_\-STACK\_\-OVERFLOW}, 
\par
\textbf{RET\_\-\_\-EVAL\_\-EVENT\_\-\_\-ALLOC\_\-STACK\_\-OVERFLOW}, 
\textbf{RET\_\-\_\-EVAL\_\-EVENT\_\-\_\-STACK\_\-EMPTY}, 
\textbf{RET\_\-\_\-EVAL\_\-EVENT\_\-\_\-ALLOC\_\-STACK\_\-EMPTY}, 
\textbf{RET\_\-\_\-EVAL\_\-EVENT\_\-\_\-NO\_\-SUCH\_\-MEMBER\_\-\_\-IDX\_\-ERROR}, 
\par
\textbf{RET\_\-\_\-EVAL\_\-EVENT\_\-\_\-VICTIM\_\-DOES\_\-NOT\_\-EXIST}
 \}
\begin{CompactList}\small\item\em This enum holds all possible return values for eval\_\-event. \item\end{CompactList}\end{CompactItemize}
\subsection*{Functions}
\begin{CompactItemize}
\item 
enum \hyperlink{eval_8h_9e1477c20853772b8f60c1285c25978e}{ret\_\-\_\-eval\_\-event} \hyperlink{eval_8h_6fa392ef590ca0f6d0be66f72ff7599c}{eval\_\-event} (\hyperlink{structstr____event}{str\_\-\_\-event} $\ast$event, \hyperlink{structstr____ctx}{str\_\-\_\-ctx} $\ast$ctx)
\begin{CompactList}\small\item\em This function will, depending on the event type, call subfunction that handles the event. \item\end{CompactList}\end{CompactItemize}


\subsection{Function Documentation}
\hypertarget{eval_8h_6fa392ef590ca0f6d0be66f72ff7599c}{
\index{eval.h@{eval.h}!eval\_\-event@{eval\_\-event}}
\index{eval\_\-event@{eval\_\-event}!eval.h@{eval.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}enum {\bf ret\_\-\_\-eval\_\-event} eval\_\-event ({\bf str\_\-\_\-event} $\ast$ {\em event}, \/  {\bf str\_\-\_\-ctx} $\ast$ {\em ctx})}}
\label{eval_8h_6fa392ef590ca0f6d0be66f72ff7599c}


This function will, depending on the event type, call subfunction that handles the event. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em ctx}]Simulator's context. \item[\mbox{$\leftarrow$} {\em event}]Event data read from source.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]enum ret\_\-\_\-eval\_\-event\end{Desc}
\begin{Desc}
\item[See also:]\hyperlink{structstr____ctx}{str\_\-\_\-ctx}, \hyperlink{structstr____event}{str\_\-\_\-event}, \hyperlink{eval_8h_9e1477c20853772b8f60c1285c25978e}{ret\_\-\_\-eval\_\-event}\end{Desc}
\begin{Desc}
\item[Author:]Dorian Ivancic \href{mailto:dorian.ivancic@gmail.com}{\tt dorian.ivancic@gmail.com} \end{Desc}
\begin{Desc}
\item[Date:]2005-03-27, 2005-04-09, 2009-01-20 \end{Desc}


Definition at line 2775 of file eval.c.

References fatal().

\begin{Code}\begin{verbatim}2778 {
2779     /* kaffe event */
2780     if (0 == strcmp ("kaffe", event -> label))
2781     {
2782         /* this event has no meaning for us! */
2783     }
2784 
2785     /* app event */
2786     else if (0 == strcmp ("app", event -> label))
2787     {
2788         /* this event has no meaning for us! */
2789     }
2790     
2791     /* new object event */
2792     else if (0 == strcmp ("n", event -> label))
2793     {
2794         switch (eval_event_new (event, ctx))
2795         {
2796             case RET__EVAL_EVENT_NEW__SUCCESS:
2797                 break;
2798                 
2799             case RET__EVAL_EVENT_NEW__NO_SUCH_CLASS:
2800                 return (RET__EVAL_EVENT__NO_SUCH_CLASS);
2801                 
2802             case RET__EVAL_EVENT_NEW__NOT_ENOUGH_MEMORY:
2803                 return (RET__EVAL_EVENT__NOT_ENOUGH_MEMORY);
2804 
2805             case RET__EVAL_EVENT_NEW__ALLOC_STACK_OVERFLOW:
2806                 return (RET__EVAL_EVENT__ALLOC_STACK_OVERFLOW);
2807 
2808             default:
2809                 fatal (MSG__EVAL__EVAL_EVENT__INTERNAL_ERROR
2810                     , EXIT_CODE__EVAL__EVAL_EVENT__INTERNAL_ERROR
2811                     , ctx);
2812                 break;
2813         }
2814     }
2815 
2816     /* delete an object or an array (d = unsorted, x = sorted by time)*/
2817     else if 
2818     (
2819         /* unsorted del */
2820         (0 == strcmp ("d", event -> label))
2821 
2822         /* time-sorted del */
2823         || (0 == strcmp ("x", event -> label))
2824     )
2825     {
2826         switch (eval_event_del (event, ctx))
2827         {
2828             case RET__EVAL_EVENT_DEL__SUCCESS:
2829                 break;
2830 
2831             case RET__EVAL_EVENT_DEL__VICTIM_DOES_NOT_EXIST:
2832                 return (RET__EVAL_EVENT__VICTIM_DOES_NOT_EXIST);
2833 
2834             default:
2835                 fatal (MSG__EVAL__EVAL_EVENT__INTERNAL_ERROR
2836                     , EXIT_CODE__EVAL__EVAL_EVENT__INTERNAL_ERROR
2837                     , ctx);
2838                 break;
2839         }
2840     }
2841 
2842     /* class loader event */
2843     else if (0 == strcmp ("c", event -> label))
2844     {
2845         /* this event has no meaning for us! */
2846     }
2847 
2848     /* reference modification in */
2849     else if 
2850     (
2851         /* object member */
2852         (0 == strcmp ("f", event -> label))
2853 
2854         /* or static member */
2855         || (0 == strcmp ("s", event -> label))
2856 
2857         /* or array */
2858         || (0 == strcmp ("a", event -> label))
2859 
2860         /* or local var */
2861         || (0 == strcmp ("l", event -> label))
2862     )
2863     {
2864         switch (eval_event_ref_mod (event, ctx))
2865         {
2866             case RET__EVAL_EVENT_REF_MOD__SUCCESS:
2867                 break;
2868 
2869             case RET__EVAL_EVENT_REF_MOD__DESTINATION_OBJECT_DOES_NOT_EXIST:
2870                 return (RET__EVAL_EVENT__DESTINATION_OBJECT_DOES_NOT_EXIST);
2871 
2872             case RET__EVAL_EVENT_REF_MOD__OBJECT_DOES_NOT_EXIST:
2873                 return (RET__EVAL_EVENT__OBJECT_DOES_NOT_EXIST);
2874 
2875             case RET__EVAL_EVENT_REF_MOD__MEMBER_DOES_NOT_EXIST:
2876                 return (RET__EVAL_EVENT__MEMBER_DOES_NOT_EXIST);
2877 
2878             case RET__EVAL_EVENT_REF_MOD__STATIC_CLASS_DOES_NOT_EXIST:
2879                 return (RET__EVAL_EVENT__STATIC_CLASS_DOES_NOT_EXIST);
2880 
2881             case RET__EVAL_EVENT_REF_MOD__STATIC_MEMBER_DOES_NOT_EXIST:
2882                 return (RET__EVAL_EVENT__STATIC_MEMBER_DOES_NOT_EXIST);
2883 
2884             case RET__EVAL_EVENT_REF_MOD__ARRAY_DOES_NOT_EXIST:
2885                 return (RET__EVAL_EVENT__ARRAY_DOES_NOT_EXIST);
2886 
2887             case RET__EVAL_EVENT_REF_MOD__STACK_EMPTY:
2888                 return (RET__EVAL_EVENT__STACK_EMPTY);
2889 
2890             case RET__EVAL_EVENT_REF_MOD__NO_SUCH_MEMBER__IDX_ERROR:
2891                 return (RET__EVAL_EVENT__NO_SUCH_MEMBER__IDX_ERROR);
2892 
2893             case RET__EVAL_EVENT_REF_MOD__NOT_ENOUGH_MEMORY:
2894                 return (RET__EVAL_EVENT__NOT_ENOUGH_MEMORY);
2895 
2896             default:
2897                 fatal (MSG__EVAL__EVAL_EVENT__INTERNAL_ERROR
2898                     , EXIT_CODE__EVAL__EVAL_EVENT__INTERNAL_ERROR
2899                     , ctx);
2900                 break;
2901         }
2902     }
2903 
2904     /* EXPANSION: explicit call to garbage collection */
2905     else if (0 == strcmp ("g", event -> label))
2906     {
2907         switch (eval_event_explicit_gc (event, ctx))
2908         {
2909             case RET__EVAL_EVENT_EXPLICIT_GC__SUCCESS:
2910                 break;
2911 
2912             default:
2913                 fatal (MSG__EVAL__EVAL_EVENT__INTERNAL_ERROR
2914                     , EXIT_CODE__EVAL__EVAL_EVENT__INTERNAL_ERROR
2915                     , ctx);
2916                 break;
2917         }
2918     }
2919 
2920     /* EXPANSION: stack - frame creation and destruction */
2921     else if 
2922     (
2923         /* frame creation */
2924         (0 == strcmp ("e", event -> label))
2925 
2926         /* frame destruction */
2927         || (0 == strcmp ("q", event -> label))
2928     )
2929     {
2930         switch (eval_event_stack_ops (event, ctx))
2931         {
2932             case RET__EVAL_EVENT_STACK_OPS__SUCCESS:
2933                 break;
2934 
2935             case RET__EVAL_EVENT_STACK_OPS__STACK_OVERFLOW:
2936                 return (RET__EVAL_EVENT__STACK_OVERFLOW);
2937                     
2938             case RET__EVAL_EVENT_STACK_OPS__ALLOC_STACK_OVERFLOW:
2939                 return (RET__EVAL_EVENT__ALLOC_STACK_OVERFLOW);
2940 
2941             case RET__EVAL_EVENT_STACK_OPS__STACK_EMPTY:
2942                 return (RET__EVAL_EVENT__STACK_EMPTY);
2943 
2944             case RET__EVAL_EVENT_STACK_OPS__ALLOC_STACK_EMPTY:
2945                 return (RET__EVAL_EVENT__ALLOC_STACK_EMPTY);
2946 
2947             default:
2948                 fatal (MSG__EVAL__EVAL_EVENT__INTERNAL_ERROR
2949                     , EXIT_CODE__EVAL__EVAL_EVENT__INTERNAL_ERROR
2950                     , ctx);
2951                 break;
2952         }
2953     }
2954 
2955     /* EXPANSION: request to print the internal hash table */
2956     else if (0 == strcmp ("h", event -> label))
2957     {
2958         switch (eval_event_print_hash_table (event, ctx))
2959         {
2960             case RET__EVAL_EVENT_PRINT_HASH_TABLE__SUCCESS:
2961                 break;
2962 
2963             default:
2964                 fatal (MSG__EVAL__EVAL_EVENT__INTERNAL_ERROR
2965                     , EXIT_CODE__EVAL__EVAL_EVENT__INTERNAL_ERROR
2966                     , ctx);
2967                 break;
2968         }
2969     }
2970 
2971     /* EXPANSION: request for allocator specific memory dump */
2972     else if (0 == strcmp ("m", event -> label))
2973     {
2974         switch (eval_event_alloc_mem_dump (event, ctx))
2975         {
2976             case RET__EVAL_EVENT_ALLOC_MEM_DUMP__SUCCESS:
2977                 break;
2978 
2979             default:
2980                 fatal (MSG__EVAL__EVAL_EVENT__INTERNAL_ERROR
2981                     , EXIT_CODE__EVAL__EVAL_EVENT__INTERNAL_ERROR
2982                     , ctx);
2983                 break;
2984         }
2985     }
2986 
2987     /* unknown event */
2988     else
2989     {
2990         return (RET__EVAL_EVENT__UNKN_EVENT);
2991     }
2992 
2993     /* increment instruction counter */
2994     /* ctx -> instruction_counter ++; */
2995     
2996     return (RET__EVAL_EVENT__SUCCESS);
2997 }
\end{verbatim}
\end{Code}


