\documentclass[12pt,letterpaper]{article}     % Tipo de documento y otras especificaciones
\usepackage[utf8]{inputenc}                   % Para escribir tildes y eñes
\usepackage[spanish]{babel}                   % Para que los títulos de figuras, tablas y otros estén en español
\addto\captionsspanish{\renewcommand{\tablename}{Tabla}}					% Cambiar nombre a tablas
\addto\captionsspanish{\renewcommand{\listtablename}{Índice de tablas}}		% Cambiar nombre a lista de tablas
\usepackage{geometry}                         
\geometry{left=18mm,right=18mm,top=21mm,bottom=21mm} % Tamaño del área de escritura de la página
\usepackage{ucs}
\usepackage{amsmath}      % Los paquetes ams son desarrollados por la American Mathematical Society
\usepackage{amsfonts}     % y mejoran la escritura de fórmulas y símbolos matemáticos.
\usepackage{amssymb}
\usepackage{listings}
\usepackage{graphicx}     % Para insertar gráficas
\usepackage[lofdepth,lotdepth]{subfig}	% Para colocar varias figuras
\usepackage{unitsdef}	  % Para la presentación correcta de unidades
\usepackage{pdfpages}   %incluir paginas de pdf externo, para los anexos
\usepackage{appendix}   %para los anexos
\usepackage{multirow, array}
\usepackage{booktabs}
\usepackage{mathrsfs}
\usepackage{subfig} % subfiguras
\renewcommand{\unitvaluesep}{\hspace*{4pt}}	% Redimensionamiento del espacio entre magnitud y unidad
\usepackage[colorlinks=true,urlcolor=blue,linkcolor=black,citecolor=black]{hyperref}     % Para insertar hipervínculos y marcadores
\usepackage{float}		% Para ubicar las tablas y figuras justo después del texto
\usepackage{booktabs}	% Para hacer tablas más estilizadas
\usepackage{multicol}
\batchmode
%\usepackage{apacite}
\bibliographystyle{plain} 
\pagestyle{plain} 
\pagenumbering{arabic}
\usepackage{lastpage}
\usepackage{fancyhdr}	% Para manejar los encabezados y pies de página
\pagestyle{fancy}		% Contenido de los encabezados y pies de pagina
\usepackage{listings} % Para incluir codigo fuente
\lstset{literate=
  {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
  {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
  {à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
  {À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
  {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
  {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
  {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
  {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
  {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
  {ű}{{\H{u}}}1 {Ű}{{\H{U}}}1 {ő}{{\H{o}}}1 {Ő}{{\H{O}}}1
  {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
  {€}{{\euro}}1 {£}{{\pounds}}1 {«}{{\guillemotleft}}1
  {»}{{\guillemotright}}1 {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {¿}{{?`}}1
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%No modificar las líneas anteriores

\lhead{IE0117 - Programación Bajo Plataformas Abiertas}
\chead{}
\rhead{Informe Final Proyecto 2}	% Aquí va el numero de experimento, al igual que en el titulo
\lfoot{Escuela de Ingeniería Eléctrica}
\cfoot{\thepage\ de \pageref{LastPage}}
%\cfoot{\thepage}
\rfoot{Universidad de Costa Rica}


\author{Manfred Soto Zúñiga, A96168 \\Juan Pablo Andrade González, B40375  \\ \\  {Grupo 01} \\{\small{Grupo de trabajo 7}} \\ \\Profesor: Andrés Mora Zúñiga. \vspace*{2.0in}}
\title{Universidad de Costa Rica\\{\small Facultad de Ingeniería\\Escuela de Ingeniería Eléctrica\\IE0117 – Programación Bajo Plataformas Abiertas\\III ciclo 2016\\\vspace*{0.55in} Informe Final}\\ Proyecto 2\\ Wrapper de Python capaz de comunicarse \\ con dispositivos BLE \vspace*{1.35in}}
\date{5 de marzo del 2017}
%%%%%%%%%%%%%%%%
\begin{document}	% Inicio del documento
%%%%%%%%%%%%%%%%

\pdfbookmark[1]{Portada}{portada} 	% Marcador para el título

\maketitle							% Título
\thispagestyle{empty}
\cfoot{\thepage\ de \pageref{tabs}}
\renewcommand{\thepage}{\Roman{page}}
\newpage
\tableofcontents
\newpage
\listoffigures
%\newpage
%\listoftables

\newpage
%%%%%%%%%% 
    
 
%%%%%%%%%%%%%%%%%%%
\section{Objetivos}\label{tabs}
%%%%%%%%%%%%%%%%%%%

\subsection{Objetivo general}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Diseñar e implementar un control remoto, el cual permita enviar señales que serán recibidas e interpretadas de forma compatible con tecnología bluetooth, para que actúen respecto a una serie de órdenes según la necesidad en un momento dado.
Desarrollar la tecnología necesaria que permita la comunicación con dispositivos Bluetooth Low Energy en tanto el dispositivo tenga la capacidad de utilizar esta tecnología, por medio de la utilización e implementación de bibliotecas y funciones creadas en lenguaje Python.
\subsection{Objetivos específicos}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}
\item  Investigar sobre el funcionamiento de dispositivos BLE y entender su protocolo de comunicación, así como comprender lo que son wrappers y su programación en Python.%Investigar sobre el funcionamiento de una placa arduino, la transmisi\'on de datos mediante bluetooth y el lenguaje de programaci\'on que se utiliza para hacer funcionar la placa. 
\item Diseñar la lógica y los contenidos de una FunctionWrapper utilizando las bibliotecas necesarias en lenguaje Python que permita la comunicación con dispositivos BLE. %Diseñar un control basándose en una placa arduino, con un modulo para envío de datos mediante bluetooth, de manera que este pueda enviar instrucciones de direcci\'on a un carro, adem\'as de crear el programa que va a hacer funcionar el control.
\item Implementar una Wrapper en Python capaz de comunicar dos dispositivos, de los cuales alguno no posee tecnología BLE, como un Raspberry Pi 3. %Implementar el diseño sobre una placa arduino, junto con un m\'odulo bluetooth, de manera que sea posible enviar las señales al receptor bluetooth instalado en el carro.
\item Validar que ambos dispositivos envían y reciben los datos requeridos por medio de la función desarrollada. %Validar que el control sea capaz de enviar las señales correctamente, ademas de asegurarse que el receptor capte dichas señales.
\end{itemize}


\newpage

\renewcommand{\thepage}{\arabic{page}}
\cfoot{\thepage\ de \pageref{LastPage}}
\setcounter{page}{1}
\setcounter{secnumdepth}{3}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Marco Teórico}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Function Wrappers en Python}

Para hablar sobre "Wrappers", primero es necesario definir que es un "Colsure", debido a que el closure hace referencia a una función que contiene otra función dentro de esta. Una vez realizado esto ya se puede empezar a hablar de los wrapper. La palabra wrapper en español significa envoltorio, y lleva este nombre debido a que su función es "envolver" la función sobre la que se aplica, esto para que se puedan realizar tareas de pre y post ejecución cuando se quiere utilizar una función.\\

\begin{figure}[H]
\begin{center}
\includegraphics[width=0.5\textwidth]{wrapper.jpg}
\caption{Lógica que sigue un Wrapper}
\label{wrapper}
\end{center}
\end{figure}

En la figura \ref{wrapper} se ejemplifica la lógica detrás  de un wrapper, en el que al llamar la función identity, el programa detecta que a esta función se le debe aplicar un wrapper; dentro de este, se corre un código que puede ser antes o después de que se ejecute la función, luego, el wrapper regresa una variable dependiendo de lo que se haya ejecutado dentro y el programma continua.

La estuctura de un wrapper es muy sencilla, primero es necesario importar la función wraps de la biblioteca functools.\\

\lstset{language=C, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=single]

from functools import wraps

\end{lstlisting}

\vspace{0.2 in}

Luego, se define la función decorador, que será el closure encargado de contener la función wrapper, después se escribe el código pre ejecución en el caso de que lo haya, seguidamente se llama a la función sobre la que se aplica el wrapper, esto se hace mediante el paámetro que recibe la función decorador, y por último se corre el código post ejecución si este código existe.\\

\lstset{language=C, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=single]

def funcion_decorador(var_func):
    
	#Wrapper
	@wraps(var_func)
	def wrapped(*args, **kwargs):
		
		#codigo pre-ejecucion
		print "Pre-ejecucion"
		
		#Llamada a la funcion sobre la que se aplica el wrapper
		var = var_func(*args, **kwargs)

		#codigo post-ejecucion
		print "Post-ejecucion"

        return var
    return wrapped


\end{lstlisting}

\vspace{0.2 in}

Una vez listo el código del wrapper, se puede iniciar a definir las funciones sobre las que se plicará.\\

\lstset{language=C, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=single]

@funcion_decorador
def funcion(arg):
    print "Funcion"
    print  arg + 1
    return arg

@funcion_decorador
def funcion2(arg):
    print "Funcion2"
    print  arg * 2
    return arg

@funcion_decorador
def funcion3(arg):
    print "Funcion3"
    print  arg + "Hola"
    return arg


\end{lstlisting}

\vspace{0.2 in}

Es importante notar que el decorador se puede llamar las veces que se desee, sin importar el contenido que haya en la función en la que se quiere trabajar, esto se hace todavía más sencillo en python debido a que este lenguaje no posee tipos de variables estáticos, en cambio, una variable que se utilizó para guardar un número, puede ser redefinida y darle el valor de una cadena de carácteres.

A continuación se muestra un ejemplo de un wrapper aplicado a dos funciones, junto con su respectiva salida en consola, para validar la funcionalidad del código.

\lstset{language=C, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=single]

from functools import wraps

def decorador(f):
    @wraps(f)
    def wrapped(*args, **kwargs):
        r = f(*args, **kwargs)
        print "Mi variable multiplicado por dos"
        return r * 2
    return wrapped

@decorador
def funcion(arg):
    print "Mi numero"
    print  arg
    return arg

@decorador
def funcion2(arg):
    print "Mi string"
    print  arg
    return arg

r = funcion(5)
print r

s = funcion2("Hola Mundo ")
print s

\end{lstlisting}

\vspace{0.2 in}

Cuya salida en consola es: 

\begin{figure}[H]
\begin{center}
\includegraphics[width=0.5\textwidth]{salidaWrapper.png}
\caption{Salida de la prueba de un wrapper}
\label{Salida}
\end{center}
\end{figure}

Como se aprecia en el código, hay dos funciones sobre las que se aplica el wrapper, de modo que una vez que se llama a la primera, el wrapper es corrido una vez, y la variable que se introduce como parámetro es multiplicada por dos. Del mismo modo, al llamar a la función 2, en este caso, el parámetro que recibe es un string, esto no genera problema debido a que como ya se mencionó antes, python no posee tipos de variables estáticos, de modo que al multiplicar por dos el string, simplemente se imprime dos veces el string que se dio como parámetro. Cabe destacar que aunque python no posee problemas al trabajar las variables de esta forma, sigue siendo imposible sumar una variable a la que se le dio un valor numérico, con otra variable que contenga una cadena de carácteres; lo mismo para los diferentes tipos de variables.

\newpage

\subsection{Tecnología Bluetooth Low Energy}
Bluetooth Low Energy (BLE), estandarizado con el nombre de Bluetooth Smart por Bluetooth SIG, es una tecnología inalámbrica de área personal diseñada para disminuir considerablemente el consumo de energía y bajar los costos. \cite{Blue} \\
Esta tecnología por sí sola no es compatible con Bluetooth Classic y sus protocolos, aunque usan la misma radio frecuencia de 2.4 GHz, lo que permite a dispositivos de modo dual a compartir una misma radio antena, sin embargo BLE utiliza un sistema de modulación más simple.\\
En sus inicios fue introducido por Nokia en el 2006 con el nombre de Wibree (Wireless + atajo) y fue estandarizado en el 2010.\cite{Wibree}. El primer smartphone en usar la tecnología Bluetooth Smart fue el iPhone 4s, el cual fue creado en octubre del 2011, y luego de esto varias compañías realizaron dispositivos Bluetooth Smart Ready en 2012. \cite{iphone}\\
Existen muchas aplicaciones para el Bluetooth Low Energy en diversos campos, tanto en salud, deportes, conectividad a internet, sensores de proximidad, sensores de movimiento, juegos, seguridad, etc. Entre sus usos existen aplicaciones para medir presión sanguínea, temperatura, glucosa, la velocidad de un objeto, ritmo cardiaco, peso, etc. \\
Existen tres tecnologías estandarizadas, Bluetooth Classic, Bluetooth Smart y Bluetooth Smart Ready. El estandar Classic se utiliza actualmente para datos pesado como transmisión de audio y video, incluso video HD. El Smart se utiliza en dispositivos llamados de botón, como relojes, teclados inalámbricos o datos puntuales en los cuales se necesita consumir poca energía por lo que se envían datos en paquetes de bits pequeños.
\begin{figure}[H]
\begin{center}
\includegraphics[width=0.9\textwidth]{details.jpg}
\caption{Detalles Técnicos}
\label{det}
\end{center}
\end{figure}

En la figura \ref{det} se muestra una comparación entre ciertas características de la primer tecnología, llamada Classic y de la Low Energy. Se observa como en la Classic existe una cantidad de canales que casi duplica a la de Low Energy en un ancho de banda de la mitad, y esto a pesar de que ambos utilizan modulación Gaussiana, permite que la tecnología BLE provea una señal más amplia y robusta.\\ 
Se observa tambien como el consumo de potencia en decibeles por milivatio es considerablemente menor en BLE, y más que todo en el envío de datos. Se observan datos acerca de su alcance típico y teórico el cual sabemos que en la práctica es un tanto menor.\\

\begin{figure}[H]
\begin{center}
\includegraphics[width=1\textwidth]{Smart.png}
\caption{Protocolos de tecnologías Bluetooth}
\label{pro}
\end{center}
\end{figure}

En la figura \ref{pro} se observan los protocolos que gobiernan las diferentes capas en las diversas tecnologías que se han expuesto anteriormente. Un protocolo muy característico en la tecnología Bluetooth Low Energy es el GATT (Generic Attribute Profile), el cual es un perfil genérico construido precisamente sobre el protocolo de la cualidad o atributo. Este establece operaciones comunes, o comandos en un marco para los datos transportados y almacenados, en los que se definen dos papeles, uno es el servidor y otro el cliente. Este protocolo define jerárquicamente la estructura de los datos que es expuesta para conectar dispositivos Bluetooth Low Energy.


\section{Estado de la cuestión}

Debido a que un wrapper se puede utilizar en cualquier código, y para desempeñar cualquier tipo de tarea, hablar de proyectos específicos en los que se haya utilizado wrappes puede ser muy extenso y tedioso, de manera que, para desarrollar un estado de la cuestión, se procederá a mecionar las funciones más comunes en las que se puede aplicar un wrapper.

Una de las tareas mas sencillas en las que se puede aplicar un wrapper, y en la que se pueden ahorrar muchas lineas de código, es en la validación de este mediante el uso de los try-exeption. En lugar de escribir el mismo código cada vez que se necesite validar una función, se puede aplicar el wrapper a todas las funciones que se requiera.\\

\lstinputlisting[language=Python]{prueba2.py}

\vspace{0.2 in}

Cuya salida en consola es: 

\begin{figure}[H]
\begin{center}
\includegraphics[width=0.5\textwidth]{salidaPrueba2.png}
\caption{Salida de la prueba de Try-Exeption con un wrapper}
\label{Salida2}
\end{center}
\end{figure}

Como se ve en el código y en la consola, a las dos funciones se les aplica el wrapper, y aunque la primera logra realizar la operación, la segunda función encuentra un error, debido a que en sus parámetros, se ingresa un cero como divisor. A fin de cuentas, el código se ve mucho más simple y es más pequeño que si se relizara el try catch por cada función.\\

Otro ejemplo, que aunque no es muy común, resulta extremadamente práctico el uso de un wrapper, es en el manejo de bases de datos, como se muestra en el siguiente código.

\newpage

\lstinputlisting[language=Python]{prueba3.py}

\vspace{0.2 in}

Por último, otro ejemplo de un uso muy común de un wrapper, se da en la implementación de bibliotecas de C dentro de python, aunque, debido a que este lleva un código muy extenso, y no resulta de interés para la finalidad de este proyecto, no se presentará un código que realize la tarea en este documento.

\newpage
 
\section{Justificación y Motivación}
%La implementación de un control remoto para el caso de un automóvil resulta impensable que se desarrolle utilizando algún tipo de conexión alámbrica, pues la movilidad se vería totalmente afectada. Por lo tanto se vuelve justificable la utilización de una tecnología inalámbrica que permita la comunicación entre el control y el carro, de lo contrario esto no sería posible.

%Facilitar mediante la tecnología bluetooth una comunicación eficiente entre el usuario del control o emisor y el receptor o carro, para que su operación sea lo mejor posible y lo más cercana a tiempo real.
La justificación de este proyecto está orientada a permitir la comunicación entre dispositivos bluetooth, cuando alguno de los dos utiliza tecnología BLE, procedimiento que en la actualidad no es fácilmente realizable.
La motivación radica en dar un inicio en este campo, implementando características propias del lenguaje Python, para facilitar este procedimiento para futuros usuarios de esta forma de comunicación.  
\newpage

%%%%%%%%%%%%%%%%%%%%%%
\section{Metodología}
%%%%%%%%%%%%%%%%%%%%%%

\subsection{Investigación}
Investigar sobre Wrappers en Python y tecnología BLE, sus usos y forma de aplicación y manipulación.

%El primer paso de todo proyecto es la investigaci\'on, en la que se consiguen todos los conocimientos previos para poder llevar a cabo el proyecto planteado. Esto se hace consultanto diferentes tipos de textos, desde libros, manuales, gu\'ias, publicaciones cient\'ificas, entre otros; tambi\'en se pueden consultar videos tutoriales. Al ser arduino una plataforma de c\'odigo abierto, existe mucha documentaci\'on e informacion que se puede consultar. Se crear\'a un documento con explicaci\'on m\'as a fondo del uso de una placa arduino y de la tecnolog\'ia bluetooth.
\subsection{Diseño}
Diseñar un Wrapper en Python capaz de permitir la comunicación con dispositivos BLE.

%Luego de que la parte de investigaci\'on sea colclu\'ida, el siguiente paso a tomar ser\'a crear el diseño del control, para tener una gu\'ia que seguir al moento de ensamblar las partes que le den forma al control. Se entregar\'a un documento de texto en el que se muestre este diseño adem\'as del modo en el que se espera que vaya a operar.
\subsection{Implementación}
Implementar el diseño de este Wrapper utilizando los conocimientos adquiridos en los pasos anteriores.

%Una vez terminado el dise\~no se proceder\'a a armar el control, as\'i como a crear el c\'odigo que hara que este funcione, se har\'an pruebas preeliminares para comprobar que el dise\~no vaya a funcionar. Se entregrar\'a el c\'odigo preeliminar, que puede sufrir cambios en la etapa de validaci\'on; tambi\'en se mostrar\'a el control armado, aunque no la funcionalidad de este, debido a que el c\'odigo final puede sufrir cambios dependiendo de si en la \'ultima etapa aparecen errores inesperados.
\subsection{Validación}
Validar la correcta funcionalidad del Wrapper implementado.
%Esta es la \'ultima etapa del proyecto, y en esta se har\'an las pruebas necesarias para comprobar que el control es capaz de leer las se\~ales que introduce el usuario, adem\'as de poder enviarlas por la conexi\'on bluetooth hacia el dispositivo receptor en el carro. Con esta etapa cumplida se da por finalizado el proyecto, entonces, en esta etapa se entregar\'a el informe final del proyecto, junto con la demostraci\'on de la funcionalidad del control y el c\'odigo final utilizado en el.
\newpage

\section{Resultados}

\subsection{Investigación}

\subsubsection{Fuction Wrappers en Python}

Para hablar sobre "Wrappers", primero es necesario definir que es un "Colsure", debido a que el closure hace referencia a una función que contiene otra función dentro de esta. Una vez realizado esto ya se puede empezar a hablar de los wrapper. La palabra wrapper en español significa envoltorio, y lleva este nombre debido a que su función es "envolver" la función sobre la que se aplica, esto para que se puedan realizar tareas de pre y post ejecución cuando se quiere utilizar una función.\\

\begin{figure}[H]
\begin{center}
\includegraphics[width=0.5\textwidth]{wrapper.jpg}
\caption{Lógica que sigue un Wrapper}
\label{wrapper}
\end{center}
\end{figure}

En la figura \ref{wrapper} se ejemplifica la lógica detrás  de un wrapper, en el que al llamar la función identity, el programa detecta que a esta función se le debe aplicar un wrapper; dentro de este, se corre un código que puede ser antes o después de que se ejecute la función, luego, el wrapper regresa una variable dependiendo de lo que se haya ejecutado dentro y el programma continua.

La estuctura de un wrapper es muy sencilla, primero es necesario importar la función wraps de la biblioteca functools.\\

\lstset{language=Python, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=single]

from functools import wraps

\end{lstlisting}

\vspace{0.2 in}

Luego, se define la función decorador, que será el closure encargado de contener la función wrapper, después se escribe el código pre ejecución en el caso de que lo haya, seguidamente se llama a la función sobre la que se aplica el wrapper, esto se hace mediante el paámetro que recibe la función decorador, y por último se corre el código post ejecución si este código existe.\\

\lstset{language=Python, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=single]

def funcion_decorador(var_func):
    
	#Wrapper
	@wraps(var_func)
	def wrapped(*args, **kwargs):
		
		#codigo pre-ejecucion
		print "Pre-ejecucion"
		
		#Llamada a la funcion sobre la que se aplica el wrapper
		var = var_func(*args, **kwargs)

		#codigo post-ejecucion
		print "Post-ejecucion"

        return var
    return wrapped


\end{lstlisting}

\vspace{0.2 in}

Una vez listo el código del wrapper, se puede iniciar a definir las funciones sobre las que se plicará.\\

\lstset{language=Python, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=single]

@funcion_decorador
def funcion(arg):
    print "Funcion"
    print  arg + 1
    return arg

@funcion_decorador
def funcion2(arg):
    print "Funcion2"
    print  arg * 2
    return arg

@funcion_decorador
def funcion3(arg):
    print "Funcion3"
    print  arg + "Hola"
    return arg


\end{lstlisting}

\vspace{0.2 in}

Es importante notar que el decorador se puede llamar las veces que se desee, sin importar el contenido que haya en la función en la que se quiere trabajar, esto se hace todavía más sencillo en python debido a que este lenguaje no posee tipos de variables estáticos, en cambio, una variable que se utilizó para guardar un número, puede ser redefinida y darle el valor de una cadena de carácteres.

A continuación se muestra un ejemplo de un wrapper aplicado a dos funciones, junto con su respectiva salida en consola, para validar la funcionalidad del código.

\lstinputlisting[language=Python]{prueba.py}

\vspace{0.2 in}

Cuya salida en consola es: 

\begin{figure}[H]
\begin{center}
\includegraphics[width=0.5\textwidth]{salidaWrapper.png}
\caption{Salida de la prueba de un wrapper}
\label{Salida}
\end{center}
\end{figure}

Como se aprecia en el código, hay dos funciones sobre las que se aplica el wrapper, de modo que una vez que se llama a la primera, el wrapper es corrido una vez, y la variable que se introduce como parámetro es multiplicada por dos. Del mismo modo, al llamar a la función 2, en este caso, el parámetro que recibe es un string, esto no genera problema debido a que como ya se mencionó antes, python no posee tipos de variables estáticos, de modo que al multiplicar por dos el string, simplemente se imprime dos veces el string que se dio como parámetro. Cabe destacar que aunque python no posee problemas al trabajar las variables de esta forma, sigue siendo imposible sumar una variable a la que se le dio un valor numérico, con otra variable que contenga una cadena de carácteres; lo mismo para los diferentes tipos de variables.

\newpage

\subsubsection{Python System Calls}

Python posee una carácterística muy importante, y es que permite hacer llamados al sistema, para correr comandos como si se trabajara desde una terminal, de manera que, es posible hacer la conexión necesaria con el dispositivo que se requiere utilizar en este proyecto, mediante el uso de estos llamados. La manera más sencialla de hacer esto, es mediante el uso del módulo subprocess, que puede ser accesado mediante un import al inicio del código.\\

\lstset{language=Python, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=single]

import subprocess as s

s.call(["ls", "-l"])

\end{lstlisting}
\vspace{0.2in}
La salida de este código sencillo, sería la misma que si se corriera el comando ``ls -l'' en una terminal de linux, mostraría una lista de lor directorios y archivos que existen en el directorio actual, además de mostrar el dueño, el grupo, los permisos de ejecución y la última vez que fuero modificados estos archivos.

De este modo, se puede crear facilmente la conexión con un dispositivo, debido a que sólo es necesario correr el comando para escaneo de dispositivos mediante un system call, y una vez que se encuentra el dispositivo al que se desea accesar, se introduce su dirección mac como una variable y esta se añade a la lista que se enviará como system call para crear la conexión.
\newpage

\subsubsection{Tecnología Bluetooth Low Energy}
Bluetooth Low Energy (BLE), estandarizado con el nombre de Bluetooth Smart por Bluetooth SIG, es una tecnología inalámbrica de área personal diseñada para disminuir considerablemente el consumo de energía y bajar los costos. \cite{Blue} \\
Esta tecnología por sí sola no es compatible con Bluetooth Classic y sus protocolos, aunque usan la misma radio frecuencia de 2.4 GHz, lo que permite a dispositivos de modo dual a compartir una misma radio antena, sin embargo BLE utiliza un sistema de modulación más simple.\\
En sus inicios fue introducido por Nokia en el 2006 con el nombre de Wibree (Wireless + atajo) y fue estandarizado en el 2010.\cite{Wibree}. El primer smartphone en usar la tecnología Bluetooth Smart fue el iPhone 4s, el cual fue creado en octubre del 2011, y luego de esto varias compañías realizaron dispositivos Bluetooth Smart Ready en 2012. \cite{iphone}\\
Existen muchas aplicaciones para el Bluetooth Low Energy en diversos campos, tanto en salud, deportes, conectividad a internet, sensores de proximidad, sensores de movimiento, juegos, seguridad, etc. Entre sus usos existen aplicaciones para medir presión sanguínea, temperatura, glucosa, la velocidad de un objeto, ritmo cardiaco, peso, etc. \\
Existen tres tecnologías estandarizadas, Bluetooth Classic, Bluetooth Smart y Bluetooth Smart Ready. El estandar Classic se utiliza actualmente para datos pesado como transmisión de audio y video, incluso video HD. El Smart se utiliza en dispositivos llamados de botón, como relojes, teclados inalámbricos o datos puntuales en los cuales se necesita consumir poca energía por lo que se envían datos en paquetes de bits pequeños.
\begin{figure}[H]
\begin{center}
\includegraphics[width=0.9\textwidth]{details.jpg}
\caption{Detalles Técnicos}
\label{det}
\end{center}
\end{figure}

En la figura \ref{det} se muestra una comparación entre ciertas características de la primer tecnología, llamada Classic y de la Low Energy. Se observa como en la Classic existe una cantidad de canales que casi duplica a la de Low Energy en un ancho de banda de la mitad, y esto a pesar de que ambos utilizan modulación Gaussiana, permite que la tecnología BLE provea una señal más amplia y robusta.\\ 
Se observa tambien como el consumo de potencia en decibeles por milivatio es considerablemente menor en BLE, y más que todo en el envío de datos. Se observan datos acerca de su alcance típico y teórico el cual sabemos que en la práctica es un tanto menor.\\

\begin{figure}[H]
\begin{center}
\includegraphics[width=1\textwidth]{Smart.png}
\caption{Protocolos de tecnologías Bluetooth}
\label{pro}
\end{center}
\end{figure}

En la figura \ref{pro} se observan los protocolos que gobiernan las diferentes capas en las diversas tecnologías que se han expuesto anteriormente. Un protocolo muy característico en la tecnología Bluetooth Low Energy es el GATT (Generic Attribute Profile), el cual es un perfil genérico construido precisamente sobre el protocolo de la cualidad o atributo. Este establece operaciones comunes, o comandos en un marco para los datos transportados y almacenados, en los que se definen dos papeles, uno es el servidor y otro el cliente. Este protocolo define jerárquicamente la estructura de los datos que es expuesta para conectar dispositivos Bluetooth Low Energy.

\subsubsection{Profundización Protocolo GATT}
La topología de red BLE es estrella. Esto quiere decir que los dispositivos Master pueden tener varias conexiones de capa de enlace con periféricos (Slaves) y simultáneamente realizar búsquedas de otros dispositivos. Los dispositivos esclavo solo pueden tener una conexión con un único Máaster.\\
La pila de protocolos de BLE se divide en tres partes básicas: Controller, Host y Applications. El Controller es el
dispositivo físico que permite transmitir y recibir señales radio e interpretarlas como paquetes con información. Contiene la capa física “Physical Layer”, “Direct Test Mode”, la capa de enlace “Link Layer” y la interfaz de control de host “Host Controller Interface”. \\
El Host es la pila que administra la forma como los dispositivos se comunican entre ellos. No hay definida una alguna interfaz superior para el Host, cada entorno tiene su forma de exponer API's. Esta parte contiene una capa de control de enlace lógico y de protocolo de adaptación “Logical Link Control and Adaptation Protocol”, administrador de seguridad “Security Manager”, protocolo de atributo “Attribute protocol (ATT)”, perfil de atributo genérico “Generic Attribute Profile (GATT)” y perfil de acceso genérico “Generic Access Profile (GAP)”.
\begin{figure}[H]
\begin{center}
\includegraphics[width=1\textwidth]{Protocolos.jpeg}
\caption{Separación de Protocolos de BLE}
\label{ProBle}
\end{center}
\end{figure}

La capa física es la que se encarga de enviar las señales al aire, transmitiendo y recibiendo bits usando ondas radio en la banda de frecuencia Industrial Scientific Medical (ISM) 2.4 Ghz que se extiende desde 2402 MHz hasta 2480 MHz. La separación entre los 40 canales utilizados es de 2 MHz (numerados de 0 a 39 y de 1 MHz de anchura cada uno). Existen 3 canales dedicados para el Advertising y 37 para la transmisión de datos. Los canales 37, 38, y 39 son usados solo para el envío de paquetes de Advertising. El resto son usados para el intercambio de datos durante la conexión.
\begin{figure}[H]
\begin{center}
\includegraphics[width=1\textwidth]{RangosFrecuencia.jpeg}
\caption{Distribución de canales en BLE}
\label{Frec}
\end{center}
\end{figure}

Estos tres canales de Advertising están situados estratégicamente, según se observa en la figura \ref{Frec} para evitar interferencias causadas por otras tecnologías que coexisten en el mismo espectro (IEEE 802, y ZigBee). Además, en estado de conexión, BLE utiliza la técnica de Frequency Hopping Spread Spectrum (FHSS) para reducir
interferencias.\\
BLE utiliza una modulación gaussiana con desplazamiento de frecuencia. Ésta utiliza dos frecuencias para identificar el bit ‘1’ o ‘0’. El filtro gaussiano se usa para suavizar las transiciones entre frecuencias. La especificación de BLE limita la potencia transmitida máxima a +10 dBm y la mínima en -20 dBm. La sensibilidad recibida mínima requerida para BLE es de -70 dBm, aunque la mayoría de dispositivos BLE tienen una sensibilidad menor a -85 dBm.\\

La capa de enlace es la responsable de los estados de Advertising, Scanning, creación y mantenimiento de las conexiones. Es responsable de estructura de paquetes. En la figura \ref{Roles} se observan los roles que ocupa BLE que se explicarán a continuación.

\begin{figure}[H]
\begin{center}
\includegraphics[width=0.5\textwidth]{Roles.jpeg}
\caption{Estados y Roles de BLE}
\label{Roles}
\end{center}
\end{figure}

\textbf{Standby}: básicamente el dispositivo ni transmite ni recibe. Por lo general, este estado está asociado con un sistema durmiente para conservar energía.\\
\textbf{Advertising}: el dispositivo que tiene el rol de periférico entra en estado de Advertising en el que envía paquetes de Advertising en los canales de Advertising. En este estado también escucha cualquier respuesta (solicitud) de los paquetes desde el dispositivo central. Este modo es de los más críticos para analizar desde el punto de vista de la potencia ya que el dispositivo periférico tardará más o menos un tiempo de Advertising (anunciándose) dependiendo de la aplicación. Hay que tener en cuenta que el tiempo de transmisión afecta al consumo de energía, por tanto el intervalo de Advertising afecta directamente al consumo de potencia y la vida de las baterías. \\
\textbf{Scanning}: se refiere a escuchar a paquetes de Advertising enviados a través de sus canales. Este modo se usa para explorar dispositivos.\\
\textbf{Initiating}: en general, este estado es el estado al que entra el dispositivo central antes de pasar a estado de conexión. El dispositivo central escucha los Advertising de periféricos, pero una vez recibe el Advertising el periférico deseado, el central debe conectar enviando los datos correctos.\\

La capa Host/Controller Interface define la conexión física entre el Host y el Controller vía comandos HCI. La especificación define varias interfaces físicas: UART, 3Wire UART, USB y SDIO. Algunos comandos están relacionados con la configuración del dispositivo y por lo tanto con su funcionamiento.

\newpage

\subsection{Diseño}
A continuación se presenta un código pleeliminar incompleto, sobre el que se trabajará durante la etapa de implementación, para completarlo y poder inicar pruebas de validación.\\

\lstset{language=Python, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=single]

import subprocess as s
from functools import wraps

#Primero se creara la conexion con el dispositivo ble
s.call(["hcitool", "lescan"])

#Una vez realizado el escaneo, se procede a preguntar al usuario
#con cual dispositivo desea conectarse
print ("introduzca el mac adress del dispositivo al cual desea conectarse")
dispositivo = raw_input()

#Luego se crea la conexion con ese dispositivo
s.check_output(["gatttool", "-b", dispositivo, "-I"])
#Esto se hace mediante la herramienta gatttool
#Con el -b se indica el mac adress del dispositio remoto
s.check_output(["connect"])

#Una vez conectado el dispositivo se procede a crear el wrapper que
#va a leer las entradas y luego convertirlas a algo que python pueda
#entender

def decorador(func):
    @wraps(func)
    def wrapper (*args, **kwargs):
            dato = s.call(["char-read-uuid"])
            #Aqui sigue un algoritmo para convertir la entrada hexagesimal
            #a una tipo de variable que pueda entender python
            return dato
        return wrapper

@decorador
def main():
    dato = ""
    print dato

\end{lstlisting}

\newpage

\subsection{Implementación de los códigos}
En este entregable se retomó el uso del módulo ITEAD BLE con el arduino UNO, el cual se había utilizado en el Proyecto 1. A partir de este se generó un código en el Arduino IDE con el que se envían los datos desde el módulo y el wrapper en Python a partir del cual se hacen los System Calls y se utiliza gattool. A continuación se muestran los códigos utilizados.

\subsubsection{Código del Arduino que opera el BLE}
Este código es básicamente el utilizado en la entrega del proyecto anterior. Se debe señalar que la configuración de los jumpers es importante dependiendo del caso. Existe una configuración para la conexión USB con el PC para subir el código al Arduino, ya por haber cargado el código se utiliza la configuración de jumpers UART, con la cual se envían las señales a otro dispositivo bluetooth, que en nuestro caso se utilizó una computadora. 
\lstinputlisting[language=C]{control_2.0.ino}
Este código podría sufrir cambios de aquí a la validación final. Se considerará posteriormente el caso general de poder enviar cualquier mensaje y traducir el código ASCII Hexadecimal enviado por medio de un diccionario en Python con cada uno de estos caracteres con sus respectivas llaves.
\subsubsection{Código preliminar del Wrapper en Python}
Este código que se muesta a continuación, es capaz de crear la conexión con el módulo bluetooth, una vez creada, imprime los datos que se reciben.\\
\lstinputlisting[language=Python]{BLE.py}
El códgo aún no esta terminado, debido a que muestra directamente todo lo que se recibe mediante la conexión bluetooth, de modo que aún es necesario modificar estos datos recibidos para sólo imprimir los datos relevantes.

\newpage
\subsection{Validación}
Una vez realizadas las modificaciones que se creyeron necesarias para que el código funcionara, se procedió a inicar las pruebas qe validaran este código. Inicialmente se encontraron problemas como que una vez que se corría el system call desde python, debido a que el comando debe estar continuamente leyendo los datos que recibe de la conexión, no era posible pasar a utilizar esto, por tanto, se optó por utilizar un pipe, para que el comando se corriera en background mientras el programa se continuara ejecutando.\\

Una vez resuelto esto, se procedió a utizar la funcióne que previamente se había hecho para poder separar los datos útilies de la lectura de los datos enviados por el dispositivo. Esta función se muestra a cotinuación.

\lstset{language=Python, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=single]

def separador(line):
	l = line.split()#Separa los datos recibidos guardandolos en una lista
	a = []
	string = ""
	cont = 0
	for i in l:
		if i == "value:":#Si se encuentra este dato, significa que luego
						 #de este continúan los datos relevantes	
				a = l [cont+1:]#Una vez encontrado esto, se copia
							   #el resto de los datos
				cont +=1
				pass
		cont +=1
		
	a = a[:-2]#Estos datos en las dos últimas posiciones tienen un par
			  #de valores que ndican que ahí terminan los datos enviados
			  #por ende, estos dos últimos datos se quitan para poder
			  #regresar sólo los datos relevantes
	return a
	
if __name__=='__main__':
	main()

\end{lstlisting}

Luego, se procedió a tomer estos datos y convertirlos de código ASCII hexagesimal a lenguaje comúm, esto para que se entienda cual es el mensaje o la informació que se esta enviando. Esto se realizó con el uso de un diccionario, que se crea a partir de un archivo de texto que contiene todos los números y letras del alfabeto junto con su respectivo código ASCII.

\lstset{language=Python, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=single]

# -*- coding: utf-8 -*-

def main():
	leer_ascii()

def leer_ascii():
	texto_leido = open("ASCII.txt", "r")#Carga el archivo de texto ASCII.txt como sólo lectura
	dicascii = {}#Crea un diccionario donde se va a guardar toda esta información
	key,value,salto = texto_leido.readline().split(" ")#La primera línea se guarda en 3 variables debido a que dentro del texto se encuentra primero el código ASCII, luego el valor al que corresponde, y por último un cambio de línea todo separado por espacios
	while key != 'ALTO':
		key = key
		dicascii[key]=value#Aquí se agruegan los valores al diccionario
		key,value,salto = texto_leido.readline().split(" ")#Se lee el siguiente valor

	texto_leido.close()#Se cierra el archivod e texto
	return dicascii	#Seregresa el diccionario con la información

if __name__ == '__main__':
    main()

\end{lstlisting}

Por último se convierten los valores que regresa la primera función con ayuda del diccionario y se concatenan para que se muestre de la misma forma que se enviaron, como una línea de texto.

\lstset{language=Python, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=single]

import subprocess as s #Se importa el módulo para hacer System calls
from functools import wraps #Se importa la función wraps para poder utilizar los wrappers
import BleFuncs as b #Se importa el módulo encargado de conseguir la información relevante de los datos crudos que envía el dispositivo BLE
from DiccionarioASCII import leer_ascii as l #Se importa la función encargada de crear el diccionario

p = s.Popen('gatttool -b B4:99:4C:67:7D:65 --char-write-req --handle=0x0012 --value=0100 --listen', shell = True, stdout=s.PIPE, stderr=s.STDOUT) #Se corre el comando para conectar con el dispositvo BLE, se guarda su salida como un pipe

def decorador(func): #Fución decorador
	@wraps(func)
	def wrapper (*args, **kwargs): #Wrapper
		dato = p.stdout.readline()#Se lee la siguiente línea de los datos enviados por el BLE
		dato = b.separador(dato) #Se aplica la función separador para obtener los datos relevantes
		dic = l() #Se crea el diccionario
		df = [] #Se crea una lista donde se guardarán los datos ya deodificados
		for i in dato:
			df.append(dic[i])#Se decodifican los datos y se agregan a df
		dato = ""
		for i in df:
			dato += i #se concatenan los datos ara formar la línea original que se envía desde el dispositivo
		if dato != "": #Si dato no esta vacío
			func(dato)#Se corre la función sobre la que se aplica el wrapper
	return wrapper

@decorador
def lector(dato): #función sobre la que se va a aplicar el wrapper
	print dato #Se imprime lo que se recbe
	
def main():
	dato = ""
	while 1: #While para correr el programa indefinidamente
		lector(dato)

if __name__ == '__main__':
    main()

\end{lstlisting}
 
Cabe destacar que se necesitó tener mucho cuidado con lo que se leía inicialmente del dispositivo BLE, debido a que este muestra muchos datos que no son relevantes y se necesitó mucha búsqueda para dar con los datos que se estaban enviando.

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusiones}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{itemize}
\item Python es un lenguaje de programación de fácil entendimiento y que presenta muchas ventajas desde el punto de vista del programador, ya que realiza por sí sólo ciertos procesos que en otros lenguajes es trabajo del programador realizarlos, además de incorporar herramientas como los Wrapper utilizados en este proyecto.
\item Los Function Wrappers se utilizan para disfrazar u ocultar código, de modo que algo en apariencia más simple realice más operaciones o procesos de los que se visualizan. 
\item La tecnología Bluetooth Low Energy presenta muchas ventajas sobre la tecnología Classic, como el bajo consumo de energía y mayor ancho de banda, lo que permite mayor estabildad.
\item El Shield ITEAD, incorporado como un aditamiento en el arduino, utiliza un módulo HM-10, posee configuraciones de jumpers diferentes para la conexión serial por USB con PC y para el envío de señales en configuración UART.
\item En el envío de datos por medio de tecnología Low Energy es importante tener en cuenta que esta información llega en formato ASCII Hexadecimal, por lo que es necesario hacer una traducción de este código a lenguaje común, además que en este formato el envío de datos es estable hasta 8 caracteres, más allá de esto la información empieza a experimentar fluctuaciones y su transmisión se divide en paquetes.  
\end{itemize}
\newpage
%%%%%%%%%%%%%%%%%%%%%%
\section{Cronograma}
%%%%%%%%%%%%%%%%%%%%%
\begin{itemize}
\item Jueves 23 de febrero del 2017: Entrega del primer documento sobre FunctionWrapper de Python y sobre tecnología inalámbrica Bluetooth Low Energy.Además de la entrega de segundo documento con el diseño del Wrapper, ya sea por medio de un diagrama de flujo u otro medio.
\item Martes 28 de febrero del 2017: Muestra de la implementación del Wrapper en un código preliminar.
\item Domingo 5 de marzo del 2017: Realización de pruebas en dispositivos para la validación del código, así como presentación del documento final del proyecto. 
\end{itemize}
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Bibliografía/Referencias
%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{thebibliography}{} 

\bibitem{Wrap} Wrappers y decoradores. Recuperado de: http://46.101.4.154/Art\%C3\%ADculos\%20t\%C3\%A9cnicos\\
/Python/Wrappers\%20y\%20decoradores.pdf el 15 de Febrero de 2017
\bibitem{Blue} Bluetooth Smart or Version 4.0+ of the Bluetooth specification. Recuperado de: https://www.bluetooth.com/what-is-bluetooth-technology/how-it-works/low-energy
\bibitem{Apple} Apple's Core Bluetooth. Recuperado de: https://developer.apple.com/reference/corebluetooth
\bibitem{Wibree}Is Wibree going to rival Bluetooth? Recuperado de: http://electronics.howstuffworks.com/wibree.htm
\bibitem{iphone}iPhone 4S claims title of first Bluetooth 4.0 smartphone, ready to stream data from your cat. Recuperado de: https://www.engadget.com/2011/10/12/iphone-4s-claims-title-of-first-bluetooth-4-0-smartphone-ready/
\bibitem{Gatt} Generic Attributes (GATT) and the Generic Attribute Profile. Recuperado de: https://www.bluetooth.com/specifications/generic-attributes-overview

\end{thebibliography}

\end{document}

