\documentclass[14pt,openany]{book}

\include{preamble}

\begin{document}

\title{Динамическое программирование и все-все-все}
\author{Довгалюк П. М.}
\date{2018}
\maketitle

\begingroup
\hypersetup{linkcolor=black}
\tableofcontents
\endgroup

\clearpage

%\chapter{TODO}
%
%Мемоизация --- сохранение результатов вычисления функций, если они вызываются повторно с теми же параметрами.
%https://en.wikipedia.org/wiki/Memoization
%Может быть использована для реализации рекуррентностей при решении задач методом динамического программирования.
%
%https://habrahabr.ru/post/113108/
%
%http://ejudge.btty.su/bmstu/2007-2008/docs/dp1.pdf

\chapter*{Введение}

Тем, кто хоть раз участвовал в олимпиадах по программированию,
наверняка попадались задачи, которые можно попытаться решить
полным перебором вариантов ответов. При этом полный балл такое решение не получает,
оставляя начинающих программистов в замешательстве. Ведь на их-то компьютере всё работало.

Правильное решение для тех самых начинающих часто кажется каким-то волшебством.
И непонятно как зная такое решение научиться придумывать такое же волшебство самому,
даже если знать, что использовалась техника, называемая <<динамическим программированием>>.

Это самое <<динамическое программирование>> помогает организовать перебор ответов так, чтобы
он укладывался в отведённое время. Или же решение строится совсем иначе и перебор становится
не нужен.

Динамическое программирование используется не только в искусственных олимпиадных задачах,
с которыми в реальной жизни большинство программистов и не сталкивается.
Сам принцип встречается довольно часто: и в разработке игр и ботов для них (например,
при поиске кратчайшего пути), и в компиляторах (некоторые действительно их пишут),
и в веб-программировании (в совсем уж широком смысле).

Эта книга отличается от других, посвящённых динамическому программированию, тем, что
мы попробуем разобраться с ним, отталкиваясь от математических идей, лежащих в основе.
Алгебре учат всех, а вот рекурсии --- уже нет. Также мы рассмотрим как можно улучшить уже
существующие программы, использующие полный перебор (всё-таки акцент у нас будет на олимпиадные
задачи, ведь не каждому захочется писать собственный компилятор).

\chapter{Рекуррентные соотношения}

\input{lesson_recurrent}

\section{Задачи}

\input{tasks_recurrent}

\section{Ответы на задачи}

\input{answers_recurrent}

% \chapter{Ещё рекуррентные соотношения}


\chapter{Вычисление рекуррентностей на компьютере}

\input{lesson_recurrent_prog}

\section{Задачи}

\input{tasks_recurrent_prog}

\section{Ответы на задачи}

\input{answers_recurrent_prog}

\section{Упражнения}

\input{problems_recurrent_prog}


\chapter{Динамическое программирование}

% \input{lesson_dynamic}

Динамическое программирование --- это технология для эффективной реализации рекурсивных алгоритмов
с помощью сохранения промежуточных результатов. Секрет её применения заключается
в определении, выдаёт ли простой рекурсивный алгоритм одинаковые результаты для одинаковых
подзадач, а также повторяются ли они.
Если выдаёт, то вместо повторения вычислений ответ каждой подзадачи можно
сохранять в таблице для использования в дальнейшем, что даёт возможность получить эффективный
алгоритм. 

%Начинаем разработку с определения и отладки рекурсивного алгоритма. Только добившись
%правильной работы нашего рекурсивного алгоритма, мы переходим к поиску мер по ускорению
%его работы, сохраняя результаты в памяти.

Дальше в главе будут рассмотрены способы реализации рекуррентных алгоритмов, в которых применимо
динамическое программирование.

\chapter{Задачи с одним параметром}

\input{lesson_1dimension}

%\section{Упражнения}

%\input{tasks04}

\chapter{Задачи на одномерном массиве}

\input{lesson_array}

\chapter{Задачи на отрезках}

Задачи на отрезках могут определяться на некоторой строке символов, последовательности чисел
и т.п. Решение полной задачи определяется через решение задач для подотрезков. Например, задачи
о поиске наибольшей подпоследовательности или о наибольшей возрастающей подпоследовательности.

Как отличить задачу с массивом от задачи на отрезках?

\input{lesson_segments}

\chapter{Двумерное динамическое программирование}

Задачи, которые разбиваются на подзадачи, описываемые двумя целочисленными параметрами.
Например, вычисление биномиальных коэффициентов, задача о лесенках.

\input{lesson_2dimension}

\chapter{Задачи на матрицах}

Частный случай двумерных задач, когда подзадача определяется
позицией в некоторой матрице. Например, задачи о поиске путей.

\input{lesson_matrix}

\chapter{Задачи на подмножествах}

Рассматривается применение динамического программирования к задачам
о выборе наилучшего подмножества из некоторого множества элементов.
Например, задача об укладке рюкзака.

\input{lesson_subsets}

\chapter{Задачи на графах и деревьях}

Частный случай применения динамического программирования,
когда в качестве подзадачи выступает подграф или поддерево.


\chapter{Динамическое программирование по профилю}

Применение динамического программирования к задачам, где требуется
перебор состояний прямоугольного поля, причём одна из размерностей
этого поля невелика. Например, задача о замощении домино.

%http://ejudge.btty.su/bmstu/2007-2008/docs/dp2.pdf


\chapter{Динамическое программирование и игры с полной информацией}

Рассматривается применение динамического программирования к определению
оптимальных стратегий в играх с полной информацией. Например, игра Ним
или шашки на небольшом поле.

\input{lesson_games}

\chapter{Динамическое программирование и все-все-все}

Поиск кратчайшего пути в компьютерных играх

Ленивые вычисления (мемоизация)

SSA в компиляторах

Игры с полной информацией посложнее

\printbibliography

%\part{Всё подряд}
%
%\chapter{Рекуррентные соотношения}
%
%
%
%\section{Число перестановок и факториал}
%
%\section{Числа Стирлинга второго рода}
%
%Числа Стирлинга второго рода --- число разбиений множества из $n$ элементов на $k$
%непустых подмножеств. Обозначаются числа Стирлинга второго рода как $\stirling{n}{k}$.
%Так, существует семь способор разбиения четырехэлементного множества на две части:
%$$
%  \{1,2,3\}\cup\{4\}, \quad \{1,2,4\}\cup\{3\}, \quad \{1,3,4\}\cup\{2\}, \quad \{2,3,4\}\cup\{1\},
%  \quad \{1,2\}\cup\{3,4\}, \quad \{1,3\}\cup\{2,4\}, \quad \{1,4\}\cup\{2,3\}
%$$
%
%Следовательно, $\stirling{4}{2} = 7$.
%
%Существует только один способ помещения $n$ элементов в одно непустое подмножество.
%Следовательно, $\stirling{n}{1} = 1$ при любом $n>0$. С другой стороны, $\stirling{0}{1} = 0$,
%потому что $0$-элементное множество пусто. $\stirling{0}{0} = 1$, потому что пустое множество
%можно разбить на нулевое число подмножеств только одним способом. А $\stirling{n}{0} = 0$ для
%$n>0$, потому что элементы множества нужно поместить хотя бы в одну часть.
%
%Чтобы вычислить $\stirling{n}{k}$, можно использовать следующие рассуждения.
%Последний объект из заданных $n$ можно поместить в отдельное подмножество. Остальные можно
%разбить на множества $\stirling{n-1}{k-1}$ способами. Либо этот объект можно поместить
%в одну из $k$ частей, полученных из $n-1$ объектов. Количество разбиений на такие части
%будет равняться $\stirling{n-1}{k}$. Для каждого есть $k$ способов размещения последнего
%элемента.
%Следовательно,
%
%$$\stirling{n}{k} = k\stirling{n-1}{k} + \stirling{n-1}{k-1}, \text{ для $n>0$}$$
%
%\section{Числа Эйлера}
%
%Число Эйлера $\euler{n}{k}$ --- это число перестановок $\pi_1\pi_2\ldots\pi_n$
%множества $\{1,2,\ldots,n\}$, имеющих
%$k$ участков подъема, а именно, $k$ мест, где $\pi_j<\pi_{j+1}$.
%
%К примеру, одиннадцать перестановок множества $\{1,2,3,4\}$ содержат по
%два участка подъема: $$1324, 1423, 2314, 2413, 3412, 1243, 1342, 2341, 2134, 3124, 4123$$.
%
%Найдём рекуррентность для $\euler{n}{k}$. Каждая перестановка $\pi = \pi_1\pi_2\ldots\pi_{n-1}$
%множества $\{1,\ldots,n-1\}$ приводит к $n$ перестановкам множества $\{1,\ldots,n\}$,
%если вставлять новый элемент во все возможные места. Предположим, мы вставляем $n$ на $j$-е
%место, получая $\pi' = \pi_1\ldots\pi_{j-1}n\pi_j\ldots\pi_{n-1}$. Если $j=1$ или если
%$\pi_{j-1} < \pi_j$, то число участков подъема в $\pi'$ такое же, как и в $\pi$. Если же
%$\pi_{j-1} > \pi_j$ или же $j=n$, то оно на единицу больше числа участков подъёма в $\pi$.
%Поэтому в целом перестановка $\pi'$ с $k$ участками подъёма получается $(k+1)\euler{n-1}{k}$
%способами из перестановок $\pi$, которые содержат $k$ участков подъёма, плюс
%$((n-2)-(k-1)+1)\euler{n-1}{k-1}$ способами из перестановок $\pi$, которые содержат
%$k-1$ участков подъёма.
%
%Итак, искомая рекуррентность:
%\begin{align*}
%\euler{0}{k} &= [k = 0] \\
%\euler{n}{k} &= (k+1)\euler{n-1}{k} + (n-k)\euler{n-1}{k-1}, \text{ для $n>0$} \\
%\end{align*}
%
%
%
%%\section{? Производящие функции}
%
%%\section{? Свертки}
%
%\chapter{Динамическое программирование}
%
%\section{Одномерное динамическое программирование}
%
%\section{Двумерное динамическое программирование}
%
%\chapter{Перебор и динамическое программирование}
%
%\chapter{Упражнения}
%\begin{enumerate}
%
%\item Решите рекуррентное соотношение
%$$
%\begin{array}{ll}
%g_0 = 1; \\
%g_n = g_{n-1} + 2g_{n-2} + \cdots + ng_0 & n>0
%\end{array}
%$$
%
%\item Сколько существует способов разместить числа ${1, 2, \ldots , 2n}$ 
%в виде массива размера $2 \times n$ так, чтобы и строки и столбцы массива
%были упорядочены по возрастанию слева направо и сверху вниз?
%Например, для $n=5$ одним из решений будет 
%$$\begin{pmatrix}
%1 & 2 & 4 & 5 & 8 \\
%3 & 6 & 7 & 9 & 10 
%\end{pmatrix}$$.
%
%\item Число Бэлла $\varpi_n$ --- число способов разбиения множества из $n$ предметов на подмножества.
%      Например, $\varpi_3=5$, поскольку множество $\{1,2,3\}$ можно разбить на такие подмножества:
%      $$\{1,2,3\}; \{1,2\}\cup\{3\}; \{1,3\}\cup\{2\}; \{1\}\cup\{2,3\}; \{1\}\cup\{2\}\cup\{3\}; $$
%      Найдите выражение для $\varpi_n$.
%
%\item Если $S$ --- некоторое множество целых чисел, то пусть $S+1$ будет <<сдвинутым>>
%множеством $\{x+1 \mid x \in S\}$. Сколько подмножеств множества $\{1,2,\ldots,n\}$ обладают
%тем свойством, что $S\cup(S+1) = \{1,2,\ldots,n+1\}$.
%
%\end{enumerate}
%
%\section{Ответы}
%\begin{enumerate}
%
%\item $G(z)=(z/(1-z)^2)G(z)+1$, следовательно 
%$$G(z) = \frac{1-2z+z^2}{1-3z+z^2} = 1 + \frac{z}{1-3z+z^2};$$
%поэтому имеем $g_n=F_{2n}+[n=0]$.
%
%\item $C_n$. Числа в верхнем ряду соответствуют позициям плюс единиц в последовательности
%из $+1$ и $-1$, определяющей <<горную гряду>>; числа нижнего ряда отвечают позициям
%минус единиц. Например, приведенный в упражнении массив соответствует
%\begin{verbatim}
%    /\     
% /\/  \/\  
%/        \ 
%\end{verbatim}.
%
%\item $\varpi_n = \sum_k C_n^k\varpi_{n-k}$
%
%\item $F_n$.
%
%\end{enumerate}
%
%\part{Задачи}

%\chapter*{Список литературы}

%\bibliographystyle{gost780s}
%\bibliography{links}

\end{document} 
