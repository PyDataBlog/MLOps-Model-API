% Исходный LaTeX-код (c) Пётр Калинин
% Код распространяется по лицензии GNU GPL (!)

\header{Классы задач на ДП}
Какие задачи на ДП бывают? Конечно, могут быть совершенно разные, но чаще
всего бывают и решаются методами ДП следующие классы задач. (Кстати, тут все очень похоже
на перебор.)

\lheader{Подсчёт объектов, в том числе определение существования объекта}
Т.е. надо посчитать, сколько всего существует объектов с заданными свойствами, или
проверить, существует ли хотя бы один. Примеры таких задач мы уже видели: первая задача
про черепашку, задача про 01"=последовательности и задача про монеты. Я думаю, более"=менее
понятно, как решаются подобные задачи.

В такой задаче (особенно в задаче проверки существования объекта) могут попросить вывести 
пример объекта "--- мы уже обсуждали, как это делается.

\lheader{Нахождение оптимального объекта} Требуется в некотором множестве объектов найти
в некотором смысле оптимальный. Такую задачу мы тоже уже видели: вторая задача про черепашку.
Здесь тоже могут попросить вывести это оптимальный объект, и вы уже знаете, как это сделать.

\lheader{Вывод $k$"=ого объекта} Но есть ещё один тип задач, который мы ещё не рассматривали. Могут попросить по данному
$k$ вывести $k$"=ый в некотором порядке объект. Например, пусть в задаче про
01"=последовательности нас не просто просят посчитать количество хороших последовательностей
длины $N$, а просят вывести $k$"=ую в лексикографическом порядке из них (конечно, гарантируя, что $k$ не превосходит общего количества таких последовательностей).

Как это сделать? На самом деле это делается легко и весьма похоже на вывод \textit{какой"=нибудь}
хорошей последовательности, что по сути мы с вами уже обсуждали. (Мы уже даже обсуждали, что
можно легко сделать так, чтобы выводился \textit{первый} в лексикографическом порядке объект.)
Поэтому давайте предварительно методом ДП посчитаем количество хороших последовательностей длины 
$i$ для всех $i$ от 1 до $N$ (ну или от нуля, вам виднее). А дальше...

А дальше раньше мы писали процедуру $out(i)$, которая выводила \textit{любую} хорошую
последовательность длины $i$. Теперь нам надо выводить не какую попало, а вполне определённую
"--- поэтому давайте напишем процедуру $out(i,k)$, которая будет выводить $k$"=ую
в лексикографическом порядке последовательность среди всех хороших последовательностей длины
$i$.

Как это делать? Попробуем воспользоваться тем, что мы знаем, как выглядит любая хорошая последовательность длины $i$. Она либо заканчивается на 0, перед чем идёт хорошая
последовательность длины $i-1$, либо на 01, перед чем идёт хорошая последовательность
длины $i-2$. Мы разделили последовательности длины $i$ на два типа, но это нам ничего не даёт, 
т.к. если все последовательности длины $i$ записать в отсортированном порядке, то
последовательности этих двух типов будут идти вперемешку. Может быть, тут можно будет найти
закономерность, но мы поступим по"=другому.

Ясно, что нам бы хотелось так разбить последовательности длины $i$ на группы, чтобы 
в отсортированном порядке шла сначала одна группа, а потом только другая. Но это же легко!
Просто записывая рекуррентное соотношение, будем смотреть не на то, чем \textit{заканчивается}
последовательность, а на то, чем она \textit{начинается}. Совершенно аналогично тому,
как мы раньше решали эту задачу, здесь поймём, что хорошая последовательность длины $i$ 
"--- это 
\begin{olist}
\item либо 0, после чего идёт хорошая последовательность длины $i-1$,
\item либо 10, после чего идёт хорошая последовательность длины $i-2$,
\end{olist}
откуда мы, в частности, приходим к тому же рекуррентному соотношению.
(На самом деле, конечно, с самого начала абсолютно очевидно, что у нас тут все симметрично.)
Но мы что"=то заработали от такого переворота. А именно, представим себе все последовательности
длины $i$, отсортированные в лексикографическом порядке. Но ведь в этом порядке будут
идти \textit{сначала} все последовательности первого типа, и \textit{только потом}
"--- второго. А последовательностей первого типа $ans[i-1]$, второго "--- $ans[i-2]$.
Т.е. этот отсортированный список будет выглядеть так:
$$
\left.
\begin{array}{l}
\left.
\begin{array}{c}
\verb'0xxxx'\\
\verb'0xxxx'\\
\verb'0xxxx'
\end{array}
\right\} \mbox{всего $ans[i-1]$ последовательностей}
\\
\left.
\begin{array}{c}
\verb'10xxx'\\
\verb'10xxx'
\end{array}
\right\} \mbox{всего $ans[i-2]$ последовательностей}
\end{array}
\hspace{0.5cm} 
\right\} \parbox{6cm}{\raggedright всего $ans[i]=ans[i-1]+ans[i-2]$ последовательностей}
$$

Теперь вспомним о нашей цели: написании процедуры $out(i,k)$. Надо вывести $k$"=ую последовательность в этом списке. Но тогда понятно, что если $k\leq ans[i-1]$, то ответ
начинается на ноль, иначе на 10. Более того: ведь в пределах одной группы последовательности
отсортированы в лексикографическом порядке, т.е. первая группа "--- это ноль, после которого идут последовательности длины $i-1$, причём тоже в лексикографическом порядке, и аналогично вторая группа! Поэтому $k$"=ая
последовательность длины $i$ "--- это: если $k\leq ans[i-1]$, то: `0', к которому приписана $k$"=ая
последовательность длины $i-1$; иначе ($k>ans[i-1]$): `10', к чему приписана (внимание!) 
$(k-ans[i-1])$"=ая последовательность длины $i-2$. Это уже пишется легко; для вывода более
коротких последовательностей, естественно, воспользуемся рекурсивным вызовом:

\begin{codesampleo}\begin{verbatim}
procedure out(i,k);
begin
...
if (k<=ans[i-1]) then begin
   write(0);
   out(i-1,k);
end else begin
    write(10);
    out(i-2,k-ans[i-1]);
end;
end;
\end{verbatim}
\end{codesampleo}

На месте многоточия, конечно, должна быть обработка особых случаев. Её, конечно, делаем в лоб,
и, как и раньше, она упрощается, если ввести нулевые элементы:

\begin{codesampleo}\begin{verbatim}
procedure out(i,k);
begin
if (i=0) then exit; //тут обязательно k=1; единственная последовательность длины 0 --- пустая строка
if (i=1) then begin //тут k может быть 1 или 2
   if (k=1) then write(0)
   else write(1);
   exit;
end;
if (k<=ans[i-1]) then begin
   write(0);
   out(i-1,k);
end else begin
    write(10);
    out(i-2,k-ans[i-1]);
end;
end;
\end{verbatim}
\end{codesampleo}
Ещё раз напоминаю, что здесь подразумевается, что всегда $1\leq k\leq ans[i]$. Подумайте,
почему, если из внешней программы мы вызвали процедуру $out$ правильно, то и при всех 
рекурсивных вызовах это свойство сохранится.

Итак, как в общем случае выводить $k$"=ый объект? Ну, во"=первых, надо динамически посчитать 
их количество. При этом динамика у вас обычно основывается на разделении множества объектов на группы и суммировании их количества "--- так надо организовать динамику так, чтобы по номеру
объекта можно было легко отнести его к одной из групп. Чаще всего это получается просто за счёт того, что в отсортированном порядке сначала идут все объекты первой группы, потом "--- второй
и т.д.; нередко чтобы добиться этого, приходится рассматривать, с чего \textit{начинается}
решение, а не чем \textit{заканчивается}, но обычно это делается примерно одинаково.
(Кстати, может быть, что разбиение на группы будет делаться как"=нибудь по"=другому,
например, по остатку от деления $k$ на что"=нибудь, но я примеров таких задач не знаю).
После этого легко пишется процедура $out(i,k)$: вы определяете, какой группе принадлежит
$k$"=ый объект и в соответствии с этим выводите его, скорее всего пользуясь рекурсивным вызовом.

\task|Научитесь выводить $k$"=ый в лексикографическом порядке путь черепашки в задаче с подсчётом 
количества путей.
||Конечно, будет удобно переписать динамику, аналогично ответу \ref{tortoise:firstlex}, 
чтобы вообще было удобно работать с лексикографическом порядке, дальше все просто по стандартному 
сценарию.

Можно не переписывать динамику, а "<передумать"> её, и не переписывать, но будет некоторое 
несоответствие между "<текущей позицией"> черепашки и координатами в массиве $ans$ (додумайте :) )
||Я думаю, общий цикл насчета количества результатов вы напишите. Я приведу только процедуру $out$. 
Сравните с ответом к \ref{tortoise:firstlex}.
\begin{codesampleo}\begin{verbatim}
procedure out(i,j,k); // k - номер решения, которое надо вывести
begin
if (i=N+1)or(j=M+1) then exit;
if ans[i+1,j]<=k then begin
   write('R');
   out(i+1,j,k);
end else begin
    write('U');
    out(i,j+1,k-ans[i+1,j]);
end;
end;
\end{verbatim}
\end{codesampleo}
|\label{tortoise:kth}


Если у вас групп немного, то все это делается легко. Если же групп много, то скорее всего
придётся искать подходящую группу в цикле. Но это тоже пишется легко, главное не испугаться:
\begin{codesampleo}\begin{verbatim}
procedure out(i,k);
...
for g:=1 to ng do
    if k<=nans[g] then begin
       ...
       out(ii,k);
       break;
    end else k:=k-nans[g];
\end{verbatim}
\end{codesampleo}
Здесь (очень условно!) написано следующее. $g$ "--- это номер очередной группы, $ng$ "--- их
общее количество, $nans$ "--- количество решений в этой группе. В реальной программе у вас
почти наверняка обозначения будут другие и даже способ организации цикла может быть другим.
Но суть в следующем: мы перебираем группы в лексикографическом порядке и каждый раз уменьшаем 
$k$ на числе объектов в очередной группе "--- $k$ в итоге обозначает,
какой по счету объект нам надо вывести, не считая тех, что мы уже пропустили. В очередной
момент $k$ станет $\leq nans[g]$, т.е. станет ясно, что ответ находится в этой группе "---
поэтому надо вывести $k$"=ый объект из этой группы. (Точнее, сейчас, наверное, не ясно,
но наткнётесь когда"=нибудь на пример "--- и будет ясно.)

\lheader{Определение номера по объекту} Задача, противоположная предыдущей: дан объект, определить 
его номер. Решается аналогично, рассмотрим опять для примера задачу про 01"=последовательности. Как 
определить номер данной последовательности? Вспоминая, как мы находили последовательность по 
номеру, и применяя те же соображения, получаем следующее решение: если данная нам 
последовательность длины $N$ начинается на 0, то ответ будет просто ответом для последовательности с 
откинутым этим нулём. Если же начинается на единицу, то нужно эту единицу и следующий за ней ноль 
откинуть, найти номер получившейся последовательности (естественно, среди последовательностей длины 
$N-2$), а потом к нему прибавить $ans[N-1]$. Додумайте эту идею сами.

Я надеюсь, что на этом примере идея нахождения номера по объекту ясна. 

\task|Напишите эту программу.
||||Итак, нам дана хорошая последовательность $a$ длины $n$, требуется найти её номер среди всех хороших 
последовательностей длины $n$.

Я никогда такого рода программ не писал, но попробую. Вероятность багов выше, чем в других 
кодах :). Сначала, как всегда в задачах на динамику, посчитаем основной динамикой $ans[i]$ "--- 
количество хороших последовательностей длины $i$, а потом по данной последовательности $a$ найдём 
её номер. Я напишу только вторую часть; похоже, её даже проще тут реализовать нерекурсивно, но я 
попробую написать рекурсивно, чтобы была видна связь с нахождением объекта по номеру и более 
понятно обобщение на произвольный случай. Подумайте над нерекурсивной реализацией; это, по"=моему, просто.

Процедура $getnum(i)$ находит, какой по счету среди всех последовательностей длины $i$ является 
последовательность, образованная последними $i$ символами данной нам (т.е. находит номер 
последовательности $a[(n-i+1)\ddots n]$).
\begin{codesampleo}\begin{verbatim}
function getnum(i)
begin
if i=n then begin
   getnum:=1;
   exit;
end;
if (i=n+1) then begin //аналог нулевого элемента
   getnum:=1;
end;
if a[n-i+1]=0 then
   getnum:=getnum(i-1)
else getnum:=ans[i-1]+getnum(i-2)
end;
\end{verbatim}
\end{codesampleo}
Надеюсь, что правильно :)

Кстати, тут тоже, аналогично задачам \ref{tortoise:firstlex}, \ref{tortoise:kth} и 
\ref{tortoise:numberbypath}, можно переписать динамику, и в $ans[i]$ хранить количество 
последовательностей длины $n-i+1$ (т.е. количество возможных окончаний нашей последовательности, 
начиная с позиции $i$), и тогда в процедуре не будет такого странного аргумента $ans[n-i+1]$. Может 
быть, так будет проще. Во всяком случае, это объясняет, почему в задаче 
\ref{tortoise:numberbypath} мы переделаем динамику, а здесь не переделывали: на самом деле 
обе задачи можно решить, не переделывая динамику, обе можно решить, переделав, я просто решил 
показать оба способа и, кроме того, в задаче \ref{tortoise:numberbypath} мне кажется, что результат 
будет проще понять с переписанной динамикой.
|\label{01:numberbyseq}

\task|Напишите программу определения номера по пути в задаче про черепашку с подсчётом числа путей.
||Сначала сделайте задачи \ref{tortoise:firstlex} и \ref{tortoise:kth}, после этого эта задача 
сложностей составлять не должна.
||Как и в задачах \ref{tortoise:firstlex} и \ref{tortoise:kth}, переписываем динамику, чтобы 
удобнее работать с лексикографическим порядком, хотя, как я отметил в ответе \ref{01:numberbyseq}, 
можно её и не переписывать. Додумайте вариант без переписывания.

Если же мы переписали динамику и уже насчитали массив $ans$, то дальше все просто:
$getnum(i,j,k)$ возвращает номер решения, образованного символами с $k$"=ого по последний данного нам 
массива $a$, среди всех решений, формирующих $ans[i,j]$ (т.е. идущих из $(i,j)$ и $(N,M)$). 
(Обратите внимание, что в ответе \ref{01:numberbyseq} был один параметр $i$, а не два параметра $i$ 
и аналог $k$, т.к. там оба параметра имели бы одно и то же значение.)
\begin{codesampleo}\begin{verbatim}
function getnum(i,j,k); 
begin
if (i=N+1)or(j=M+1) then begin // можно написать и if k=N+M-1
   getnum:=1;
   exit;
end;
if ans[k]='R' then 
   getnum:=getnum(i+1,j,k+1)
   write('R');
   out(i+1,j,k);
end else 
    getnum:=ans[i+1,j]+getnum(i,j+1,k+1);
end;
\end{verbatim}
\end{codesampleo}
Ещё обратите внимание на следующий момент: когда вы только услышали такую задачу, может показаться, 
что тут есть какие"=нибудь идеи, методы решения, специфические только для этой задачи (например, 
какая"=нибудь игра с $C_n^k$, а в задании \ref{01:numberbyseq} "--- с числами Фиббоначчи). Нет!
\textit{Все} идеи тут совершенно стандартны, и ничего специфичного для задачи нет.
|\label{tortoise:numberbypath}
