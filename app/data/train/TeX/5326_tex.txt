% !TeX spellcheck = de_DE
\chapter{Konzeption}
\begin{figure}[ht]
	\centering
	\includegraphics[width=0.5\textwidth]{Graphics/KonzeptApp.png}
	\caption{Grobkonzept für Applikation}
	\label{fig1}
\end{figure}
\FloatBarrier
Die Applikation besteht aus drei Teilen. Einem Webserver, der eine API und statische Clientfiles zur Verfügung stellt. Der Client im Browser, welcher die API konsumiert sowie eine Android Applikation welche die Website lädt. 
 \newpage
\section{Technologiestack}
Wie in dem Grobkonzept beschrieben, wird für die Applikation ein Technologiestack gebraucht, welcher  eine skalierbare API sowie eine gute Integration der API mit einer Browser Frontend Anwendung bietet. Folgende Anforderungen werden an den Technologiestack gestellt:
\begin{itemize}
	\itemsep-0.5em
	\item Skalierbare REST API
	\item Einfacher und schneller Umgang mit AJAX
	\item Gute Integration zwischen API und HTML/JS Client
	\item Responsive Design, Integration mit OAUTH für 3rd Party Authentisierung
	\item Persistance Layer (Datenbankunterstützung)
\end{itemize} 

\subsection{MVC Frameworks}
Komplexe Applikationen werden vorzugsweise mit MVC Frameworks erstellt. Über MVC APIs sind Routing,  Logik sowie Präsentationsschicht gut voneinander abstrahiert. Es ist gut möglich, für Views mit verschiedenen Daten über ein Model zu versehen, oder auch ein logisches Routing für eine API zu entwickeln. Folgende Grafik zeigt ein MVC Konzept. Der Client sendet einen Request zu dem Server und wird vom Routing zur Logik im System weitergeleitet. Die Logik findet das richtige Model sowie die dazugehörige View.  Die View wird mit dem Model gerendert und es entsteht eine Antwort, welche dem Client zurückgesendet wird. In einer REST API ist die View JSON. Das Model wird in JSON umgewandelt und versendet. 

Folgendes Code-Beispiel --- die Funktion list() ---  zeigt, wie alle Courts aus dem Persistance Layer selektiert werden und per JSON zum Client gesendet werden. Dies ist ein API Endpunkt zur Auflistung von Courts (http://webserver/courts). Gut zu sehen ist, dass die jsonp() Funktion als Renderer gebraucht wird anstatt eine Standard-View. 
\begin{lstlisting}
exports.list = function(req, res) { 
	Court.find().sort('-created').populate('user')
	 .exec(function(err, courts) {
		if (err) {
			return res.status(400).send({
				message: 
				 errorHandler.getErrorMessage(err)
			});
		} else {
		res.jsonp(courts);
		}
	});
};
\end{lstlisting}

Mit einem MVC Framework auf der Server-Seite ist es möglich gut abstrahierte und ausbaufähige --- skalierbare --- APIs erstellen. Diese APIs müssen nun jedoch vom Client Browser verarbeitet werden können. Folgende Möglichkeiten bieten sich an:
\begin{itemize}
	\item Parallel zu der REST API werden Renderer gebaut, welche das Model mit einer View in eine --- für den Client statische --- Website rendern. Der Client verfügt hier ausschliesslich Logik um die verschiedenen Webseiten abzurufen. 
	\item Ein Website-Skelett mit Logik wird beim ersten Aufruf an den Client verschickt. Der Client bezieht nun Daten aus der REST API und reichert die schon vorhandenen Views mit den Objekten --- gesendet über AJAX --- selber an. 
\end{itemize}
Eine parallele Implementierung zur Rest API geht entgegen dem Basis-Konzept, dass alle Applikationen so gut wie möglich von der REST API profitieren. Zusätzlich würde bei einer parallelen Implementierung jeder Klick in einer Aktualisierung der Applikation resultieren. Dies ist unerwünscht, da sich die Website nicht schnell und intuitiv anfühlt. Man hat bei jedem Klick eine Downtime, da viele Daten übertragen werden müssen, und der Browser den DOM jedes mal neu aufbauen muss. Bei der zweiten Option wird die Website nur einmal heruntergeladen. Der DOM wird nach dem Download aufgebaut und von der Logik verändert. Klicks lösen einen viel geringeren Aufwand von Server bis Client aus und somit ist die Downtime viel kleiner. Die Applikation fühlt sich schneller und intuitiver an. 

Wie bei dem Server, kann man auch bei der Applikation ein MVC Pattern implementieren. Ein Routing definiert, bei welcher URL welche View aufgerufen wird. Bei dem Aufruf einer View ist ein Controller hinterlegt, welcher bei der API das Model und Objekt besorgt. Die View rendert die vom Controller generierten Daten. Server und Client MVCs können so miteinander kombiniert werden und es entsteht eine skalierbare und wartbare Applikationsumgebung.


\subsubsection{Server MVCs}
MVCs für den Server gibt es verschiedene:
\begin{itemize}
	\item Spring Framework --- Java
	\item ExpressJS --- JSON
	\item Rails --- Ruby
\end{itemize}

\subsubsection{Client MVCs}
MVC für den Server sind ausschliesslich in Javascript geschrieben:
\begin{itemize}
	\item AngularJS
	\item Backbone.js
	\item Ember.js
	\end{itemize}

\subsubsection{Stacks}
Eine Konfiguration des Client sowie Server MVCs, damit beide gut miteinander funktionieren, ist zusätzlich wichtig. In der Evaluation werden somit folgende Konfigurationen abgewogen:
\begin{itemize}
	\item JHipster (Spring, Angular)
	\item MEAN.js (ExpressJS, Angular)
\end{itemize}

\subsubsection{Anforderungen an Stacks}
Die Anforderungen an einen Frameworkstack gehen aus den nicht-funktionalen Anforderungen heraus. Einige Anforderungen, welche sich auf die User Experience beziehen (Benutzbarkeit), sind für die Anforderungen an den Stack nicht relevant. 
\begin{center}
	\tabulinesep = 1mm
	\begin{longtabu} to \linewidth [m]{X[1, m , l]|[2pt]p{2.95cm}|[2pt]p{2.5cm}|[2pt]}
		\arrayrulecolor{white}
		
		\tabucline[2pt]{-}
		\textcolor{white}{\textbf{\cellcolor{airforceblue}Anforderung}}  &  
		\textcolor{white}{\textbf{\cellcolor{airforceblue}Notwendigkeit}}&
		\textcolor{white}{\textbf{\cellcolor{airforceblue}Kritikalität}}
		\tabularnewline
		\tabucline[2pt]{-}
		\multicolumn{3}{l}{\cellcolor{bluegray}  Qualitätsmerkmal:  Funktionalität }
		\tabularnewline
		\cellcolor{testblau}  NREQ0.01 --- Sicherheit &
		\cellcolor{testblau}  Conditional &
		\cellcolor{testblau}High
		\tabularnewline
		\tabucline[2pt]{-}
		\multicolumn{3}{l}{\cellcolor{bluegray}  Qualitätsmerkmal:  Zuverlässigkeit  }
		\tabularnewline
		\cellcolor{testblau}  NREQ1.01 --- Fehlertoleranz  &
		\cellcolor{testblau}Conditional &
		\cellcolor{testblau}High
		\tabularnewline		
		\cellcolor{testblau}  NREQ1.02 --- Wiederherstellbarkeit  &
		\cellcolor{testblau}Essential &
		\cellcolor{testblau}High
		\tabularnewline	
		\tabucline[2pt]{-}
		\multicolumn{3}{l}{\cellcolor{bluegray}  Qualitätsmerkmal:  Effizienz  }
		\tabularnewline
		\cellcolor{testblau}  NREQ3.01 --- Effizient in Programmierung  &
		\cellcolor{testblau} Essential &
		\cellcolor{testblau} High
		\tabularnewline		
		\cellcolor{testblau}  NREQ3.02 --- Effizient in Installation  &
		\cellcolor{testblau} Essential &
		\cellcolor{testblau}High
		\tabularnewline
		\tabucline[2pt]{-}
		\multicolumn{3}{l}{\cellcolor{bluegray}  Qualitätsmerkmal:  Wartbarkeit  }
		\tabularnewline
		\cellcolor{testblau}  NREQ4.01 --- Einfach erweiterbar/änderbar &
		\cellcolor{testblau} Essential &
		\cellcolor{testblau} High
		\tabularnewline		
		\cellcolor{testblau}  NREQ4.02 --- Stabilität  &
		\cellcolor{testblau} Optional &
		\cellcolor{testblau} High
		\tabularnewline
		\cellcolor{testblau}  NREQ4.03 --- Testbarkeit  &
		\cellcolor{testblau} Essential &
		\cellcolor{testblau} High
		\tabularnewline
		\cellcolor{testblau}  NREQ4.04 --- Analysierbarkeit    &
		\cellcolor{testblau} Optional &
		\cellcolor{testblau} High
		\tabularnewline		
			
	\end{longtabu}\end{center}

\subsubsection{Spring}
Spring ist ein MVC Framework in Java. Man programmiert in der J2EE Umgebung und bietet eine API zum Client. Gleichzeitig sendet man den AngularJS Stack zum Client, welcher anschliessend die API konsumiert. Als Persistance Layer können relationale Datenbanken wie MySQL, Oracle oder Sybase verwendet werden. Über Data Access Object wird dieser Layer angesprochen und in Models emuliert. \footcite{Spring}

\paragraph{Installation und Konfiguration}
Die Installation und Konfiguration von Spring einem Client MVC sowie einer DAO Schicht ist komplex. Die Installation funktioniert über Maven, einzelne Komponenten nach der Installation müssen aufeinander konfiguriert werden. Security sowie ORM für den Persistance Layer sind nicht im Spring Package enthalten und müssen zusätzlich hinzugefügt und auf Spring konfiguriert werden. Es gibt Templates, welche dies etwas einfacher gestalten, jedoch in meinen Recherchen habe ich kein funktionierendes Modell gefunden.

\paragraph{Portabilität} Durch Maven ist eine Spring Installation einfach auf einer anderen Maschine installierbar. Einmal eingerichtet ist es einfach möglich den Code auszutauschen und die Applikation laufen zu lassen.

\paragraph{Funktonalität} Out of the Box bringt Spring keine Funktionalität ausser den MVC Workflow. Es gibt kein Basis User Management, kein Front End MVC, keine CSS Frameworks oder sonstiges. Ein Client MVC muss zusätzlich selber installiert und integriert werden. \footcite{SpringFramework}

\paragraph{Stabilität} Spring gilt das eines der meist eingesetzten Frameworks auf dem Markt. Es ist bekannt für seine Stabilität und Enterprise Readiness.  

\paragraph{Skalierbarkeit} Spring ist skalierbar innerhalb des Application Servers. Es gibt jedoch Limitationen im Clustering.  

\paragraph{Erweiterbarkeit} Die Programmiersprache von Spring ist Java oder Scala. Diese Programmiersprachen bieten eine breite Palette an Funktionen und Objekten, welche benutzt werden können. Spring ist somit sehr gut erweiterbar.

\paragraph{Stacks} Ein Stack für Spring, der alle Plug-Ins und Client MVCs mitbringt, heisst JHipster\footcite{jhipster}. Dieser Stack bringt eine User Verwaltung, Integration von Persistance Layer, Client MVC (AngularJS) und viel Weiteres mit sich. Die Installation ist komplex und schwer verständlich. 

\paragraph{Objekte/API} Ein integraler Bestandteil der Applikation soll eine API mit JSON sein. Bei Spring muss man Javaobjekte zu JSON Objekten serialisieren und umgekehrt. Folgender Workflow existiert für Objekte von Persistance Layer bis zum Ausgang der API:
\begin{enumerate}
	\itemsep -0.4em
	\item Relationale Datenbankfelder
	\item Konvertierung zu einem Objekt über ein ORM(Object-relational Mapping) Interface
	\item Konvertierung von Objekt zu einem JSON-Objekt
	\item JSON Objekt wird versendet
\end{enumerate}

Diese Konversionen müssen oft manuell erstellt werden und sind negativ, um effizient zu programmieren.

\newpage
\subsubsection{NodeJS/ExpressJS}

\paragraph{Installation und Konfiguration} ExpressJS wird über npm installiert. Die Installation ist sehr simpel. Zusätzlich existieren für NodeJS und ExpressJS eine grosse Anzahl Stacks, welche sehr einfach zu installieren sind. Der Persistance Layer benutzt Mongodb, das heisst Objekte werden nativ im JSON Format in der Datenbank gespeichert. Konfigurationen über die Stacks sind sehr intuitiv.

\paragraph{Portabilität} NPM lässt sich wie Maven so konfigurieren, dass eine automatische Installation  der benötigten Plug-ins ausgeführt wird. Die Portabilität ist somit wie bei Spring sehr gut.

\paragraph{Funktionalität} NodeJS bzw. ExpressJS besitzen out of the box keine Funktionalität. Diverse Stacks unterstüzten jedoch User Verwaltung, Plugin-Handling, Client sowie Server MVCs.

\paragraph{Stabilität} NodeJS ist nicht so viel benutzt wie Spring. Die Stabilität ist somit nicht endgültig bewiesen. Einige grosse Firmen setzten jedoch schon NodeJS ein \footcite{NodeJSEinsatz} und es ist bis jetzt noch nichts bekannt über Probleme mit der Stabilität.

\paragraph{Skalierbarkeit} NodeJS ist sehr gut skalierbar. Über Loadbalancer kann man HTTP Anfragen an mehrere NodeJS-Prozesse verteilen. Da der ganze Kontext im Persistance Layer existiert  --- und MongoDB im Cluster läuft --- ist NodeJS hervorragend skalierbar \footcite{NodeJSScale}.

\paragraph{Erweiterbarkeit} JavaScript ist sehr populär und es existieren zahlreiche Bibliotheken. Stacks sind in Module aufgebaut und die Erweiterbarkeit und Wartbarkeit von Code ist sehr effizient. 

\paragraph{Stacks}
In NodeJS ist der MEAN Stack weit verbreitet. Der MEAM Stack besteht aus folgenden Produkten:
\begin{itemize}
		 \itemsep-0.5em
	\item M --- MongoDB, der skalierbare Persistance Layer.
	\item E --- ExpressJS, ein MVC um APIs zu entwickeln.
	\item A --- AngularJS, ein MVC auf dem Client um Sing-Page Applikationen zu erstellen, welche auf die ExpressJS API zugreifen.
	\item N --- NodeJS, JavaScript Applikationsserver, welcher sehr gut skalierbar ist.
\end{itemize}

\paragraph{Objekte/API} Ein integraler Bestandteil der Applikation soll eine API mit JSON sein. Bei einem Mean Stack gibt es keine Konversionen. Von der Datenbank bis zum Output der API existiert immer genau das gleiche Objekt.

\subsubsection{Evaluation}
Für die Stacks MEAN sowie JHipster wird nun eine Evaluation durchgeführt. Es soll herausgefunden werden, welcher Stack besser geeignet ist für eine effiziente Programmierung.

Die nicht-funktionalen Anforderungen werden somit mit einer Bewertung von 1-10 für jedes Framework versehen. Die Bewertung entsteht auf Basis der Erfahrung des Autors dieser Arbeit aufgrund von Recherchen. Argumente sind in dem Kapitel der einzelnen Frameworks aufgelistet.
\begin{center}
	\tabulinesep = 1mm
	\begin{longtabu} to \linewidth [m]{X[1, m , l]|[2pt]p{2.95cm}|[2pt]p{2.95cm}|[2pt]}
		\arrayrulecolor{white}
		
		\tabucline[2pt]{-}
		\textcolor{white}{\textbf{\cellcolor{airforceblue}Anforderung}}  &  
		\textcolor{white}{\textbf{\cellcolor{airforceblue}MEAN}}&
		\textcolor{white}{\textbf{\cellcolor{airforceblue}JHipster}}
		\tabularnewline
		\tabucline[2pt]{-}
		\multicolumn{3}{l}{\cellcolor{bluegray}  Qualitätsmerkmal:  Funktionalität }
		\tabularnewline
		\cellcolor{testblau}  NREQ0.01 --- Sicherheit &
		\cellcolor{testblau}  9 &
		\cellcolor{testblau}10
		\tabularnewline
		\tabucline[2pt]{-}
		\multicolumn{3}{l}{\cellcolor{bluegray}  Qualitätsmerkmal:  Zuverlässigkeit  }
		\tabularnewline
		\cellcolor{testblau}  NREQ1.01 --- Fehlertoleranz  &
		\cellcolor{testblau}10 &
		\cellcolor{testblau}9
		\tabularnewline		
		\cellcolor{testblau}  NREQ1.02 --- Wiederherstellbarkeit  &
		\cellcolor{testblau}10 &
		\cellcolor{testblau}9
		\tabularnewline	
		\tabucline[2pt]{-}
		\multicolumn{3}{l}{\cellcolor{bluegray}  Qualitätsmerkmal:  Effizienz  }
		\tabularnewline
		\cellcolor{testblau}  NREQ3.01 --- Effizient in Programmierung  &
		\cellcolor{testblau} 10 &
		\cellcolor{testblau} 6
		\tabularnewline		
		\cellcolor{testblau}  NREQ3.02 --- Effizient in Installation  &
		\cellcolor{testblau} 10 &
		\cellcolor{testblau}7
		\tabularnewline
		\tabucline[2pt]{-}
		\multicolumn{3}{l}{\cellcolor{bluegray}  Qualitätsmerkmal:  Wartbarkeit  }
		\tabularnewline
		\cellcolor{testblau}  NREQ4.01 --- Einfach erweiterbar/änderbar &
		\cellcolor{testblau} 10 &
		\cellcolor{testblau} 7
		\tabularnewline		
		\cellcolor{testblau}  NREQ4.02 --- Stabilität  &
		\cellcolor{testblau} 8&
		\cellcolor{testblau} 10
		\tabularnewline
		\cellcolor{testblau}  NREQ4.03 --- Testbarkeit  &
		\cellcolor{testblau} 10 &
		\cellcolor{testblau}10 
		\tabularnewline
		\cellcolor{testblau}  NREQ4.04 --- Analysierbarkeit    &
		\cellcolor{testblau} 9 &
		\cellcolor{testblau} 9
		\tabularnewline		
		\tabucline[2pt]{-}
		\cellcolor{bluegray}  Total &
		\cellcolor{bluegray} 86 &
		\cellcolor{bluegray} 77
	\end{longtabu}\end{center}
	
Die Applikation wird somit mit dem MEAN Stack entwickelt. 

\subsection{Kontext}
Die Applikation ist aufgeteilt auf einen Server sowie auf einen Client, welcher ein Browser oder eine Android App ist. Auf dem Server sind alle Daten hinterlegt:
\begin{itemize}
	\itemsep -0.5em
	\item Gespeicherte Objekte in MongoDB
	\item Server Logik
	\item Client Daten, welche vom Browser über HTTP abgefragt werden
\end{itemize}

Im Anfangszustand hat der Client keine Daten. Der Client bekommt die Daten bei dem Abruf der Applikations-URL über HTTP. Er baut nun die Logik im Browser Cache auf und startet das JavaScript Programm. Das JavaScript Programm lädt nun die auf dem Server gespeicherten Objekte über HTTP AJAX Abrufe und stellt diese dar.  

Die Logik von Server wie auch Client benutzt das M(V)C Pattern. Objecte werden in Models --- inklusive Business Logik ---  gespeichert, der Controller beinhaltet die Applikationslogik, welche das Model sowie die View auswählt. Die View rendert nun das Model in ein bestimmtes Schema (siehe Abbildung \ref{DetAppArch}). 
\begin{figure}[ht]
	\centering
	\includegraphics[width=0.9\textwidth]{Graphics/DetailAppArch.png}
	\caption{Detaillierte Applikations Architektur}
	\label{DetAppArch}
\end{figure}

\subsubsection{Continues Integration}
Die Applikation wird auf dem Server des Autors gehostet. 

Um Updates der Applikation direkt zu installieren, besitzt der Server eine Applikation für Continues Integration namens Jenkins. Jenkins führt ein Deployment der Applikation automatisch aus bei Anforderung eines solchen Deployments. In Jenkins werden diese Deployments Jobs genannt. 

Dieser Jenkins Job wird bei jedem Push nach Github ausgeführt. Das heisst, bei jedem Update der Applikation wird die neuste Version direkt auf dem Server unter der Adresse https://racket.marques.pw aktualisiert. 




\subsection{Businessschicht}
\subsubsection{DB Design}
In der Applikation gibt es kein relationales Datenbankmodel. MongoDB arbeitet mit Dokumenten sowie Referenzen. Dokumente sind JSON-Objekte in JavasScript, welche in MongoDB als Dokument gespeichert werden. Ein Objekt ist eine Repräsentation von Business Objekten in der Applikation.

Das User-Objekt repräsentiert der User der Applikation. Der User hat einen Namen, einen Usernamen, ein Passwort (encrypted und salted), Berechtigungen und Freunde. Zusätzlich werden ihm andere Objekte zugeordnet sowie andere User (Repräsentation als Freund).

Das Court-Objekt repräsentiert ein Racket-Sportzentrum der Applikation. Dieses Objekt wird benötigt um den physikalischen Austragungsort eines Spieles zu definieren. Das Objekt beinhaltet einen Namen, eine Adresse (inklusive Koordinaten für eine zukünftige Umkreissuche), welche für Sportarten gespielt werden können und welche User in diesem Racket-Sportzentrum spielen wollen.

Das Match-Objekt repräsentiert das Spiel, welches geplant, ausgetragen oder beendet ist. Das Spiel-Modell definiert zwei oder einen Spieler, einen Status, eine Sportart, einen Court, mehrere Datumsvorschläge, maximal fixes Datum, eine Punktzahl, sowie ein Gewinner. Hinter dem Match-Objekt existiert ein relativ grosser Business-Workflow, welcher im Kapitel Workflow definiert ist. 

Das Liga-Objekt repräsentiert eine Liga. Verschiedene Benutzer können einer Liga beitreten und sind nach Beitritt bestimmten Regeln unterworfen. Dafür können die Benutzer Spiele für die Liga spielen und so Punkte für einen optionalen Preis sammeln. Die Liga beinhaltet nebst einem Namen, einer Sportart, einem Standort (inklusive Koordinaten, für zukünftige Umkreissuche), einem Niveau, Start- und Enddatum, einem Preis auch einem Matchmaking Plan (wird später im Dokument erläutert). 

Folgende Grafik zeigt die Beziehung der verschiedenen Schemas auf, das Datenbankmodell ist nicht Relational und somit nicht normalisiert. 
\begin{figure}[ht]
	\centering
	\includegraphics[width=0.9\textwidth]{Graphics/DBModel.png}
	\caption{Datenbank Modell}
	\label{DBMOdel}
\end{figure}

\newpage
\subsection{Präsentationsschicht} 
Als GUI wird ein Standard Bootstrap Design verwendet. Ohne Authentisierung kann nur die Home-Page gesehen werden sowie die Login- und Signup-Page. Für alle anderen Seiten muss der Benutzer authentisiert sein. Sobald die Authentisierung durchgeführt wurde, können die Elemente (Nach Datenbank) Benutzer, Liga, Racket-Sportzentrum sowie Spiele selektiert werden. Innerhalb der einzelnen Menus kann man verschiedene Operationen direkt ansteuern, einige nur über andere Operationen. Folgendes Diagramm zeigt die Interaktion durch die verschiedenen Views.
\begin{figure}[ht]
	\centering
	\includegraphics[width=0.9\textwidth]{Graphics/GUIInteraction.png}
	\caption{GUI Interaktions Modell}
	\label{GUIInteraction}
\end{figure}

\subsubsection{User Section}
Die User Section einhaltet drei Views, die direkt aus dem Menu erreichbar sind. Die erste View User Profile ermöglicht dem User, Details über sich preiszugeben. Er kann zusätzlich das Passwort ändern. In der Friends View kann er neue Friendrequests erstellen und pendente Friendrequests annehmen oder ablehnen. Die Social Account View bietet eine Verknüpfung von Social Accounts mit der Applikation an.

\subsubsection{Court Section}
Die Court Section beinhaltet vier Views sowie eine Aktion. In der New Court View kann ein neues Racket-Sportzentrum registriert werden. In der List Courts view findet man alle  Racket-Sportzentren und erreicht bei Klick auf ein Zentrum die View Court Details View. In dieser View kann man alle Details des Racketsportzentrum anschauen sowie alle Spieler, welche in diesem Racketsportzentrum spielen. Durch Klick auf den Spieler kann in die New Match View gewechselt werden, um einen Spieler herauszufordern. Von der Detail View kann man zusätzlich das Court löschen, sofern man das Court erstellt hat oder ein Admin ist.

\subsubsection{League Section}
Die League Section beinhaltet vier Views sowie eine Aktion. In der New League View kann ein neues Liga registriert werden. In der List League View findet man alle  Ligen und erreicht bei Klick auf eine Liga die View League Details View. In dieser View kann man alle Details die Liga anschauen, sowie alle Spieler, welche in dieser Liga spielen. Durch Klick auf den Spieler kann in die New Match View gewechselt werden, um einen Spieler herauszufordern. Von der Detail View kann man zusätzlich die Liga löschen, sofern man die Liga erstellt hat oder ein Admin ist.

\subsubsection{Match Section}
Die Match Section beinhaltet alle Interaktionen im Match. Drei Views sind direkt aus dem Menu erreichbar. Auf der New Match View kann man ein neues Spiel erstellen. Man kann Court und Spieler in einem Formular auswählen. Über den Menupunkt New Broadcast Match View, wählt man einen Court sowie eine Zeit und alle Spieler, welche in diesem Court spielen, werden angefragt für eine spontanes Spiel. In der List Match View werden alle Spiele aufgelistet. Von da gelangt man in die View Match Details View, welche den Matchworkflow abdeckt.

\subsubsection{GUI Design}
Als Design wurde Bootstrap benutzt. Das Design besteht aus einem Header sowie einem Hauptfenster. 

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.9\textwidth]{Graphics/website.png}
	\caption{GUI Design}
	\label{GUIInteraction}
\end{figure}