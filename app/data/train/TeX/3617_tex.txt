% !Mode:: "TeX:UTF-8"

\BiChapter{系统软件设计}{Software Design}

本章介绍监控系统的软件设计，系统软件可以分为三个部分开发，分别检测设备的采集程序、监控平台的后端服务器程序和监控平台的前端网页设计。本章首先介绍了软件开发环境，接着介绍系统软件的总体结构，最后分部详细介绍软件设计的流程。

%\section{软件开发环境介绍}
%
%工欲善其事，必先利其器。软件开发环境在软件开发过程中是一个很重要的一个环节。好的软件开发软件能极大提高软件开发的效率，降低软件出错概率。下面根据三个部分分别介绍所使用的软件开发环境。
%
%\subsection{设备GUI开发环境} % Qt Creator
%
%在检测设备上装载有触摸屏，需要在触摸屏上开发图形化人机交互界面（Graphical User Interface, 简称GUI）。GUI的选择与操作系统有很大关系，如MFC框架只能在微软Windows系统上运行。本课题选择的GUI为Qt/QML，其特性介绍如下：
%
%Qt是一个跨平台应用程序和UI开发框架。使用Qt只须一次性开发应用程序，无须重新编写源代码，便可跨不同桌面和嵌入式操作系统部署这些应用程序。\citeup{qtcreator2014}Qt本身拥有独特的信号/槽（SIGNAL/SLOT）机制，信号和槽机制是 QT 的核心机制，要精通 QT 编程就必须对信号和槽有所了解。信号和槽是一种高级接口，应用于对象之间的通信，它是 QT 的核心特性，也是 QT 区别于其它工具包的重要地方。
%
%此外，除了GUI相关库之外，Qt本身也提供了一系列开发库以方便应用程序设计，如串口类（QSerialPort）、数据库类（QSqlQuery）等。如果又需要，可以将自己开发的库作为一个插件安装至Qt库内，应用程序的源代码改动细微。
%
%\subsubsection{Qt Quick}
%
%本质上，Qt是一个C++类库。在引入qml以前，所有的开发都是基于C++的，但到了Qt 5，QML和 Qt Quick成为了 Qt的核心之一。Qt Quick是Qt 4.7推出的一个新的绘图库，利用qml语言描述界面，可以做出类似手机、平板上应用程序附带的动画效果（渐变、迟滞等），而且利用OpenGL渲染以获得很高的绘图性能。qml语言简单易学，描述的界面、布局可以通过程序渲染立即得到反馈，大大加快了GUI程序的开发效率。Qt Quick是qml标准库，提供各种绘图组件以供qml语言描述，如窗口、对话框、页面布局等。目前在Qt开发者大会上推崇的一种新的开发趋势是利用qml语言描述界面，利用C++代码实现程序逻辑。qml引擎读取qml代码独立渲染界面，界面与核心逻辑的交互则借由qml引擎提供的Context Property、定义新的QML类等方式实现。
%
%\subsection{服务器后端开发环境} % Golang, Gentoo, Nginx
%
%监控平台运行在服务器上，设计成典型的B/S架构，主要逻辑、数据部署在平台后端运行的服务器上。如第二章所述，服务器采用阿里云提供的云主机产品。云主机是一种虚拟主机，是服务器集群利用虚拟化技术将计算资源按需分配，生成性能各异的虚拟主机。用户在虚拟主机的操作系统上操作与一般的实体主机相同，但是利用虚拟化技术可以动态扩展服务器的性能，如CPU算力、内存空间、存储空间、数据库空间和带宽等。
%
%\subsubsection{Linux}
%
%云主机上运行的操作系统是Gentoo Linux。Linux操作系统十分稳定，可长期连续运行，可以动态裁剪不必要的组件以减少资源占用。Linux系统具有严格的用户权限设置，可以预防软件漏洞对系统产生的冲击，提高系统安全性。Gentoo是Linux系统的一个发行版，采用滚动升级的机制，绝大部分软件以源代码的形式提供，在本机上编译获得最佳的优化性能。
%
%\subsubsection{Nginx}
%
%Nginx是俄罗斯人编写的十分轻量级的HTTP服务器，是一个高性能的HTTP和反向代理服务器。Nginx因为它的稳定性、丰富的模块库、灵活的配置和低系统资源的消耗而闻名。监控平台的静态页面交给Nginx处理，而动态页面经由Nginx反向代理将请求转发至服务器内部的应用服务器相应端口上处理。
%
%\subsubsection{Go语言}
%
%Go语言是由Google开发的一个开源项目，目的之一为了提高开发人员的编程效率。 Go语言语法灵活、简洁、清晰、高效。它对的并发特性可以方便地用于多核处理器 和网络开发，同时灵活新颖的类型系统可以方便地编写模块化的系统。go可以快速编译， 同时具有垃圾内存自动回收功能，并且还支持运行时反射。Go是一个高效、静态类型， 但是又具有解释语言的动态类型特征的系统级语法。
%
%go语言本身提供的go routine机制十分适合于并发编程，标准库提供的函数使得网页开发变得极其容易。媲美C/C++的高性能、Python的动态语言特性使得采用go语言开发的程序开发效率、程序性能都很高。本文即采用go语言自行实现了三个应用服务器。
%
%\subsection{Web前端开发环境} % HTML5/Javascript
%
%监控平台采用B/S架构设计，其中的B是Browser的缩写，即浏览器。用户通过浏览器访问监控平台，浏览器从后端获取数据之后通过网页渲染成人类易于阅读的格式。Web前端的开发环境与客户使用的浏览器显示效果应一致。网页布局可以通过HTML、CSS设定，而页面行为需要javascript描述。
%
%\subsubsection{jQuery}
%
%jQuery是一个javascript函数库，可以方便的对文档对象模型（DOM）寻址和修改，即可以通过javascript语言动态修改网页。
%
%jQuery兼容绝大部分的浏览器，是开发人员的一个利器。
%
%\subsubsection{Flotcharts} % or Highcharts
%
%Flotcharts是一款基于javascript开发的绘图程序，专门用于绘制数据图表（折线图、条形图、饼状图等），历史比较悠久，文档成熟，可以利用插件增强绘图功能。

\section{软件总体设计}

本节介绍监测系统的软件开发总体设计。根据第二章系统总体设计的描述，系统可以分为两个部分开发：下位机检测设备和上位机监控平台。检测设备软件的角色是控制设备硬件的运作、显示测量结果给操作人员和上传数据给监控平台。监控平台软件的功能是获取下位机设备的工作状态、接收和记录下位机发送的数据、把数据结果动态显示在客户端浏览器上、接受客户端的请求，调阅数据或控制设备运行状态等。

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{node_dfd.pdf}
  \caption{检测设备数据流图}\label{node_dfd}
\end{figure}

检测设备的数据流图如图\ref{node_dfd}所示，数据采集卡采集传感器数据，置于缓冲数组，后续程序从缓冲数组中获取数据，作标度变换之后将数据转换成电压值。把电压值存入数据库的同时，绘图程序将电压值数组的数值添加至波形图显示。另外通讯程序也同时将电压值数组的数值封装好上传到服务器。

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{platform_dfd.pdf}
  \caption{监控平台数据流图}\label{platform_dfd}
\end{figure}

监控平台的数据流图如图\ref{platform_dfd}所示，监控平台监听检测设备的数据，获取数据之后根据协议对数据作解析。当浏览器订阅设备信息时，监控平台将气体符合条件的浓度数据发送给浏览器，浏览器负责将气体浓度绘制成曲线显示。为了监控平台开发方便，服务器上没有设置数据库保存气体浓度信息，故监控平台只能够显示当前设备的实时数据。

\section{移动式气体检测仪}

检测设备的程序用于便携式气体检测仪的操作与显示，功能包括数据采集、数据显示、数据传输、传感器算法执行、气泵调速和电磁阀开关等。为了编写现代的操控界面，选择利用 C++自行开发程序，编写出来的界面如同平板或手机应用的界面，界面美观且具有动态效果。最后基于 QT/QML库编写出来的程序界面如图\ref{fig_gui}所示。

\begin{figure}
  \centering
  \includegraphics[width=0.6\textwidth]{gui.png}
  \caption{波形显示界面}\label{fig_gui}
\end{figure}

\subsection{需求分析}

软件开发首先需要明确软件的需求，可分为业务逻辑提出的功能性需求和软件工程要求的非功能性需求。

\subsubsection{功能性需求分析}

\begin{enumerate}
  \item 在检测节点上将配备触摸屏，用作人机交互，所编写的人机交互界面应有利于手指操作。
  \item 程序控制采集卡采集12路传感器电压值、12路加热控制信号电压值，利用软件波形合成技术生成波形输出加热控制信号，利用数字IO口控制气泵和电磁阀的运行状态。
  \item 需要在触摸屏上编写人机交互界面以获取设备的当前运行状态（正在采集/停止采集），并提供控制面板控制状态。
  \item GUI应提供波形显示界面，显示12路气体传感器的电压信号，显示界面上应提供类似于示波器的调节旋钮动态调整波形位置、波形通道数。
  \item 人机交互界面的控制面板应提供动态调整采样率的功能（\SI{10}{\milli\second}、\SI{100}{\milli\second}和\SI{1}{\second}）、传感器加热信号输出设置功能（波形、周期、幅度、占空比等）。
  \item 人机交互界面采集获得的电压值应实时录入数据库内，按日期动态生成表记录，并应能够从列表中选择数据库中的表以xlsx和txt的格式导出。
  \item 应提供波形显示界面实时显示气体浓度信息，通过鼠标定位动态获取气体浓度波形某时间点的浓度值。
  \item 手动设置电磁阀的开关状态；气泵的转停控制、转速控制等。
  \item 获取的气体浓度信息定时上传到监控平台，并实时监听来自监控平台发出的指令。
\end{enumerate}

\subsubsection{非功能性需求分析} %性能/安全性等

\begin{enumerate}
  \item 应保证波形显示的绘图性能，刷新率应支持\SI{15}{\hertz}以上。
  \item 界面显示与数据存储解耦，采用传统MVC思想开发程序。
  \item 保证采集程序定是精度，利用硬件定时器实现\SI{1}{\milli\second}精度的定时，采用独立线程减少GUI界面等操作的干扰。
  \item 为了实现高频率（\SI{10}{\milli\second}周期）的软件波形合成，每路加热控制信号生成程序都应具备独立线程。
  \item 出于安全性考量，在程序开启时将输出通道电压初始化为\SI{0}{\volt}。
  \item 为了与系统界面相匹配，软件界面采用Metro风格形式展现，提供动画渐变效果增强程序动态感。
\end{enumerate}

\subsection{软件结构设计}

为了兼顾速度和界面美观，程序设计的时候采用了采集程序和显示程序线程独立的形式。采集程序，主要负责定时采集、加热控制信号输出和数据库记录三个工作，其中定时采集2个线程，加热控制信号输出12个线程和数据库1个线程。数据库采用高性能的 PostgreSQL，保证24小时工作情况下数据项的插入时间保持稳定。显示程序则是采用了Qt Quick库开发，利用 qml语言描述动态界面。

\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{gui_connect.pdf}
  \caption{显示程序和设备控制程序交互的网络图}\label{gui_connect}
\end{figure}

界面显示程序和设备控制程序之间的交互如图\ref{gui_connect}所示，在程序初始状态，main()函数在执行初期，初始化三个主要实例（instance）：usb2089负责设备控制相关事物、db负责数据库操作相关事务和QML Engine负责界面相关事务。其中usb2089进一步开辟三类线程：一个daq线程，负责处理数据采集事务、12个dac线程，负责控制波形生成事务和一个gasdata线程，负责将采集电压值转换为气体浓度数据和温湿度数据。而db也开辟两个工作线程：insertWorker负责将内存的数据插入数据库，dbWorker负责数据库表的查询和导出。QML Engine负责界面的渲染，并作为qml和C++语言的桥梁传递信号/槽和数据于两者之间当用户在GUI界面点击按钮的时候，触发相应的信号给usb2089或db，后者根据信号类型执行相应的函数，待函数执行完毕的时候，发送信号给QML Engine，通知界面读取结果。设备和界面之间利用了异步非阻塞通信的方式。图\ref{gui_connect}的边展示了实例之间通信的先后顺序。

\subsubsection{界面显示}

QML(Qt Meta-Object Language)，是Qt推出的Qt Quick技术的一部分，是一种新增的简便易学的语言。QML是一种声明方式设计的语言，用来设计应用程序的界面，包括样式与表现行为。在QML中，用户界面被制定为一个树形的对象模型并且包含了对象的属性。文件格式以.qml结尾。语法格式非常像CSS，但又支持javacript形式的编程控制。在学习QML最好首先有HTML的基础与CSS的基础。利用QML语言描述界面十分灵活、精确，可通过属性绑定（binding）的方式将数据与界面连接起来。

\begin{figure}
  \centering
  \includegraphics[width=0.6\textwidth]{gui_main.png}
  \caption{程序主界面}\label{gui_main}
\end{figure}

系统的主界面如图\ref{gui_main}所示，通过点击按钮可以跳转至不同的子界面，下面介绍各个子界面的功能。

\begin{description}
  \item[系统设置] 对检测参数的设置，包括采集周期更改、采集状态设置、数据库表格导出、电磁阀开关设定等。
  \item[AD] AD显示界面显示采集获取的电压数值，如图\ref{fig_gui}所示，右侧包含类似于示波器的X、Y功能旋钮，波形上侧可动态选择通道。保存数据和新建文件开关用于设定采集数值是否记录到数据库内。
  \item[DA输出设置] DA输出设置界面提供了12个加热驱动信号波形的设置，包括输出波形、幅值、周期和占空比。
  \item[DA输出显示] DA输出显示界面将输出的加热驱动信号波形通过采集卡采集，将波形输出到显示界面上。
  \item[实时气体浓度] 实时气体浓度界面显示\SI{4}{\minute}范围内的气体浓度信息，可以在波形界面上移动鼠标，动态读取波形上的气体浓度数值。
  \item[其他] 其他子界面设计算法部分，功能交给后续人员继续开发。
\end{description}

\begin{figure}[hbtp]
  \centering
  \includegraphics[width=0.8\textwidth]{gui_stru.pdf}
  \caption{界面层次结构}\label{gui_stru}
\end{figure}

\subsubsection{设备控制}

C++部分采用传统的Qt函数库开发，Qt本身提供了十分丰富的库函数功能。Qt是一个跨平台的 C++图形用户界面库，由挪威 TrollTech 公司出品，目前包括Qt， 基于 Framebuffer 的 Qt Embedded，快速开发工具 Qt Designer，国际化工具 Qt Linguist等部分。 Qt支持所有 Unix 系统，当然也包括 Linux，还支持 WinNT/Win2k，Win95/98平台。

qml语言描述的界面需要通过数据来获得``生命''，即利用数据``驱动''界面的运转。qml本身提供了javascript引擎负责简单的数据处理，但是更加底层的操作，如文件、数据库、驱动程序等还需要Qt提供的C++函数库支持。

本课题的C++部分设计并实现了若干类，功能描述如下：

\begin{figure}[htbp]
  \centering
  \begin{minipage}{0.4\textwidth}
    \centering
    \includegraphics[width=0.5\textwidth]{doxygen/class_database__coll__graph.pdf}
    \caption{Database协作图}\label{class_database__coll__graph}
  \end{minipage}
  \begin{minipage}{0.4\textwidth}
    \centering
    \includegraphics[width=0.5\textwidth]{doxygen/class_serial__coll__graph.pdf}
    \caption{Serial协作图}\label{class_serial__coll__graph}
  \end{minipage}
  \vspace{-1em}
\end{figure}

\begin{figure}[htbp]
  \centering
  \begin{minipage}{0.25\textwidth}
    \centering
    \includegraphics[width=\textwidth]{doxygen/class_timer__coll__graph.pdf}
    \caption{Timer协作图}\label{class_timer__coll__graph}
  \end{minipage}
  \begin{minipage}{0.22\textwidth}
    \centering
    \includegraphics[width=\textwidth]{doxygen/class_d_a_q__coll__graph.pdf}
    \caption{DAQ协作图}\label{class_d_a_q__coll__graph}
  \end{minipage}
  \begin{minipage}{0.22\textwidth}
    \centering
    \includegraphics[width=\textwidth]{doxygen/class_d_a_c__coll__graph.pdf}
    \caption{DAC协作图}\label{class_d_a_c__coll__graph}
  \end{minipage}
  \vspace{-1em}
\end{figure}

\begin{description}
  \item[Timer] 提供精确的定时功能（\SI{1}{\milli\second}），保证操作的实时性。
  \item[Database] 负责数据库相关事务的处理，支持查询数据表、新建数据表、插入数据项共三个功能。
  \item[Device] 提供设备操作的方法，包括调整采样时间、设定采样状态等，并负责初始化驱动、定时器、采集进程和输出进程等任务。
  \item[DAQ] 负责采集卡数据采集部分的任务，由软件定时器触发，将采集的原始电压值存放到缓冲数组。
  \item[DAC] 负责采集卡加热驱动信号的生成和输出任务。
  \item[DAParameters] 提供软件接口，将QML界面设定的波形参数转换为C++可用的形式，供\textbf{DAQ}、\textbf{DAC}参考。
  \item[DataSource] 数据源，在QML波形显示界面上实时绘制的波形，因数据量较大，数据处理部分放置在C++执行。
  \item[GasData] 气体浓度数据，将处理好的气体浓度数据暴露给QML浓度显示界面。
  \item[Serial] 串口类，负责通过串口与GPRS连接，最后与监控中心方面的通讯事务，包括数据封装、指令监听等功能。
\end{description}

\begin{figure}
  \centering
  \includegraphics[width=0.8\textwidth]{doxygen/class_device__coll__graph.pdf}
  \caption{Device协作图}\label{class_device__coll__graph}
\end{figure}

图\ref{device_8cpp__incl}展示了device.cpp的引用关系。

\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{doxygen/device_8cpp__incl.pdf}
  \caption{device.cpp引用（Include）关系图}\label{device_8cpp__incl}
\end{figure}

qml语言描述的界面需要通过qml渲染引擎渲染到显示窗口 上，qml语言描述的物件（object）独立于C++运行环境中。为了实现数据交互，必须通过某种办法将C++数据、方法、属性等参数导出到qml引擎内以供调用。

\subsection{系统实现与测试}

此节介绍在软件实现过程中所用到的方法、机制、工具和技术。

\subsubsection{解耦设计}

本小节介绍利用Qt/QML语言来描述系统的界面和功能。在上一小节曾介绍了QML和C++语言的特点及应用场景，QML语法简单，描述的部件具有各种属性，部件的属性在定义的时候可以通过冒号（``:''）表示，以和其他部件的属性绑定。qml可以执行javascript，因此与网页应用开发有些类似，基本上拥有HTML/CSS开发经验的开发人员可以很容易上手运用qml语言编程。本系统的设计方案也是利用qml语言来描述界面。不使用可视化工具，如Qt Assistant是因为可视化工具虽然很容易上手，但是在描述比较复杂的界面逻辑时力不从心。其实目前商业开发的软件大部分都是通过语言来定义的。利用qml语言描述界面，可以十分方便地定义属性，通过C++程序、javascript语句自定义界面的行为。

利用qml语言描述好界面前端之后，随之利用了C++语言描述程序的行为。C++语言效率很高，适合处理繁重、复杂的业务。本文为了保证界面程序的性能，在操作界面的过程中不至于卡死，所以把所有耗时的工作都交给C++程序来完成，并借助多线程技术提高软件的执行效率。用户在界面上下达指令之后，将任务通知给C++相应部分的程序/线程处理，带处理完毕之后将结果返回给界面。这种设计实现了异步通信，非阻塞执行的特性，提高了程序执行效率和程序稳定性。如前文所述，这种开发方法是当前Qt用户群推崇的一种未来的开发模式。

\subsubsection{上下文属性}

在程序实现的过程中需要重点解决的问题其实是qml和C++语言之间的通信。Qt的官方文档上介绍了C++和QML之间的交互的办法如下\citeup{qt2016contexproperty}：

为了提供C++数据或功能给QML，C++的类必须是从QObject导出的。因为QML引擎本身与Qt的Meta Object System集成在一起，所以QObject导出的类，其方法与信号都可以从QML中访问。一旦一个类提供了所需的功能，那么可以通过如下办法暴露给QML：

\begin{itemize}
  \item 把C++类作为一个QML类型注册，这样即可在QML语言使用这个类型，使用方法与一般的类型的使用方法无异。
  \item 把C++类作为一个Singleton类型注册，这样在QML中只会导入唯一的一个类型，其方法、属性和信号都可被QMl访问。
  \item 将C++类的一个具体实例（instance）作为上下文属性（context property）嵌入到QML中，其方法、属性和信号都可被QMl访问。
\end{itemize}

本设计采用了第三种方案，即将C++类的一个具体事例作为上下文属性嵌入到QML中，QML可以根据id找到相应的属性，其使用方法与一般的类型的id引用一致。这种方法的特点是只有一个类型会暴露给QML，每个实例可以通过id辨别。同时实例作为一个C++的实例也可以被C++操作，因此十分适合本文的应用场景：在C++中把数据赋给实例，应用信号/槽机制通知qml更新界面结果。这种方法效率高，界面美观，编程简单自然，十分具有优势。

\subsubsection{信号槽机制}

信号和槽机制是 QT 的核心机制，要精通QT编程就必须对信号和槽有所了解。信号和槽是一种高级接口，应用于对象之间的通信，它是 QT的核心特性，也是 QT区别于其它工具包的重要地方。信号和槽是QT自行定义的一种通信机制，它独立于标准的C/C++语言，因此要正确的处理信号和槽，必须借助一个称为 moc（Meta Object Compiler）的 QT工具，该工具是一个C++预处理程序，它为高层次的事件处理自动生成所需要的附加代码。

所有从 QObject或其子类 派生的类都能够包含信号和槽。当对象改变其状态时，信号就由该对象发射 (emit) 出去，这就是对象所要做的全部事情，它不知道另一端是谁在接收这个信号。槽用于接收信号，但它们是普通的对象成员函数。一个槽并不知道是否有任何信号与自己相连接。而且，对象并不了解具体的通信机制。

利用信号槽机制，当数据发生变化的时候可以发射（emit）一个信号，qml的槽获取信号之后，利用Context Property访问实例，根据数据绘制结果到界面上。同样地，界面上的按钮被点击之后，按钮会发射一个信号，则C++实例的槽函数可以执行相应的方法响应信号。

你可以将很多信号与单个的槽进行连接，也可以将单个的信号与很多的槽进行连接，甚至于将一个信号与另外一个信号相连接也是可能的，这时无论第一个信号什么时候发射系统都将立刻发射第二个信号。总之，信号与槽构造了一个强大的部件编程机制。

\subsubsection{多线程技术}

一个程序是一个静态实体，包含代码和数据，存放在硬盘中。进程是动态的实体，拥有程序计数器指向下一条将要执行的指令，在内存中还维护着当前程序中的变量。一个进程中可以有多个线程，多个线程共同拥有一份代码，但是程序计数器各不相同，一个进程中的多个线程共享内存。

采用多个线程，可以合理地分配CPU时间给相应的工作。例如，在界面渲染的同时，后台程序也需要不断定时采集传感器数据、输出控制信号、处理通讯事物等，这些任务要求很高的响应优先级，而界面渲染工作耗时较多且优先级较低。如果采用单一线程工作的话，界面渲染的时候其他任务必须暂停，而任务执行的时候界面没有响应，即俗称的``卡机''。利用多线程技术可以提高程序的并发性，将CPU时间合理地分配给后台和前台任务。在Qt中实现多线程有两个方法：

\begin{itemize}
  \item 继承QThread类并重定义run()方法；
  \item 定义一个QThread实例，将继承QObject的类利用方法moveToThread移动到实例中运行；
\end{itemize}

两种方法各有利弊，并在使用过程中存在不少误解，因此在这里说明一下两种用法的区别：

继承QThread并重定义run()可以避免引入新变量（QThread），但是文档不推荐在继承类中加入新的SLOT（槽），因为信号槽的执行周期是在创建线程所在的线程中执行的。即若不需要信号槽机制的话，用此办法在代码上更为精简。

定义QThread实例，可以将变量的信号槽机制引入到新的线程中，此时事件循环（event loop）将在新的线程中执行。这种方法可以利用Qt的信号槽机制，因此适用范围更广。但是因为要处理线程的创建、开始、结束和解构等事物，因此使用更加复杂。

本程序中广泛采用了多线程技术提高程序的响应性能，各个线程的功能列举如下：

\begin{itemize}
  \item 提供采集周期的定时器与采集程序
  \item 12路提供控制信号输出的定时器与波形生成程序
  \item 数据库插入程序
  \item 数据库查询、导出程序
  \item 供波形显示的数据处理程序
  \item 供浓度显示的数据处理程序
  \item GPRS串口通信程序
  \item 记录程序运行时长的计时器程序
\end{itemize}

上述各个程序有高实时性、业务繁重、操作耗时等特点，放在主程序中执行将影响界面渲染，因此有必要单独开辟线程运行。另外，在qml引擎中内部实现了广泛的多线程机制，而界面渲染部分所有qml类型共用一个线程。

\subsubsection{qwebchannel.js}

本程序应用了Qt最新开放的Qt Charts绘图库完成波形显示部分，Qt Charts允许使用OpenGL技术加速绘图渲染工作，性能很高，适合用于多路数据的波形显示。但是在性能高的同时，采用OpenGL加速的波形交互性能很弱，界面较为简陋。

为了提高显示效果，本文采用了javascript库作为绘图库显示4种气体浓度数据，在程序内部运行了浏览器加载HTML页面（WebEngineView）。利用网页作为显示前端也是未来移动应用开发的一个趋势。在实测中，发现Qt内部自带的新浏览器引擎（QWebEngine）的js引擎性能低下，采用美观的js绘图库没办法跟上数据的变化，本程序最后选用的js库是flotcharts。

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.25\textwidth]{data_flow.pdf}
  \caption{气体浓度数据在程序内的从采集卡最后传递给HTML网页}\label{data_flow}
\end{figure}

flotchats是一个老牌的js绘图库，它占用资源小，提供了必要的插件用作交互显示：利用js语言可以获取鼠标当前位置，利用插值算法可以获得该位置的气体浓度数据，将数据返回给qml界面绘制的图例中作渲染显示。而C++部分则通过上下文属性（context property）将数据传送给qml，经中转到达HTML界面中绘制。在数据传输流程中比起上面的C++/QML来，又引入了独立的HTML层，增加了通信复杂性。

为了处理C++/QML/HTML之间通信的需求，以往可以在C++部分建立WebSocket服务器，而HTML网页则执行WebSocket的客户端部分。这种办法引入了不必要的编程复杂度，而且面向网络的软件开发十分繁琐。2015年11月，QWebEngine推出了一个新的库QWebChannel避免引入不要的组件。在WebEngineView中注册的部件（object）可以在网页中被访问。具体的操作是在网页中嵌入qwebchannel.js库，利用里面提供的函数，根据注册id获取object，将改object作为一个新的js变量使用即可。qwebchannel.js库也提供了信号槽机制，C++/QML发送信号之后，在网页部分的变量会更新变量值，新的事件会传入qwebchannel.js的事件处理回调函数中。

利用qwebchannel.js，qml可以将QML类型直接传递给WebEngineView；而HTML部分则是可以利用一般的网页开发方法利用js代码对变量作处理，对事件利用回调函数响应。两者的程序设计方法没有因为引入QWebChannel而变得更加复杂。对于C++/HTML之间的通讯，则利用上下文属性（context property）将C++实例暴露给qml引擎，即可利用qml/HTML的方法通信了。最后气体浓度数据在程序内的流动如图\ref{data_flow}所示。

\subsubsection{UDP与串口测试}

GPRS模块与设备通过串口连接，GPRS作为DTU对于设备是透明的，因此对设备的通信编程本质上是串口编程。面向串口的数据是流式的（streaming），所以需要设置帧头和帧尾等机制判别数据包。相应的协议已经在第二章作了详细介绍，再次不再叙述。待数据到来之后，需要等待若干毫秒缓冲新的数据到来，若超时则说明数据包已经结尾。由于UDP是以包为单位传输数据，因此协议的处理比较简单。为了降低通信程序对主程序的影响，需要把耗时的通信程序转移到新的线程中执行，对命令/数据作解析之后利用信号槽机制对主程序发出指令。

串口的测试利用了串口线自发自收的方法，将TX连接到RX上，若在调试终端上能获得自己发送的信息，则说明设备IO工作正常。接着是UDP通信的调试，首先将服务端的应用程序调试好，再对客户端作调试。因为GPRS模块是一个串口设备，在设备编程的时候可以利用虚拟串口加速调试过程。TCP-Com是一款串口/TCP调试软件，能够在电脑中虚拟出串口的端口，在串口上的数据会被转发到指定IP的指定端口号上，即软件扮演了GPRS模块。

为了监听通信过程，可以利用Wireshark截取数据包。Wireshark是非常流行的网络封包分析软件，功能十分强大。可以截取各种网络封包，显示网络封包的详细信息。

\section{远程中央监控平台}

远程中央监控平台主要功能是给监控中心一个监控界面，观察从各个监测点上传汇总而来的传感器数据，并提供传感器故障和气体浓度超限等警报功能。本节介绍平台的构成、总体结构和前后端设计与实现。远程中央监控平台本质上是一个数据广播器，检测节点将数据上传到平台上，平台则将数据转发给订阅该设备的所有客户端处理。在本设计中，远程中央监控平台包含浏览器前端和服务器后端，后端服务器程序没有数据库，不保存气体浓度信息。浏览器前端负责监听数据，并按数据实时绘制波形供显示。

\subsection{需求分析}

远程中央监控平台实际上是一个Web服务器+应用服务器，应用服务器的任务是监听设备的数据，并发送命令给指定设备。由此，需要应用服务器维护一个设备列表，上面包含对应id设备的IP地址、UDP端口号，而且根据UDP协议的特点，如第二章所述，GPRS内网设备若一段时间没有通信，则该端口号会解除与内网相应IP的绑定。为了保持设备IP、端口的稳定，需要应用服务器保持和列表上设备的会话。最后，需要应用服务器监听来自浏览器发出来的命令，并将命令通过UDP协议发送给指定设备。

Web服务器是一般的网页服务器，客户端浏览器输入相应的网址/IP地址之后，Web服务器会返回HTML代码给客户端浏览器渲染网页。因此Web服务器的主要功能是监听客户端请求并根据请求发送HTML代码。HTML代码不一定是静态网页，也可以利用HTML模板技术根据网址参数动态生成HTML代码返回。Web服务器需要支持至少GET和POST方法，其中GET方法用于数据获取，POST方法用于命令发送。Web服务器应该具备相应的API作为方法的接口，根据HTTP协议的设计理念，API应该是REST风格的。不仅如此，客户端若订阅了某API的传感器数据，则Web服务器应该将获得的数据广播给所有订阅该API的客户端。

\subsection{系统总体设计}

监控平台可以分为两个阶段设计：前端设计和后端设计。前端的功能是平台的操作面板，界面的描述任务交给前端完成，界面的渲染工作交给浏览器；后端的功能是平台的逻辑、数据处理，一切运算皆交给后端完成。

\subsection{后端设计}

\subsubsection{系统分析}

监控平台的后端需要实现三个功能：
\begin{enumerate}
  \item 响应Web客户端的资源请求
  \item 维护与设备的连接，接收设备的资源
  \item 将设备数据向订阅的客户端广播更新
\end{enumerate}

对应以上三个功能，服务器程序可以分为三个独立的模块：Web服务器、设备服务器和应用服务器。下面介绍三个子模块的功能。

\paragraph{Web服务器}

Web服务端的功能是响应Web客户端的资源请求，所谓资源是一个对于网络上所有可访问的对象的一个抽象称呼。资源可以是HTML代码、Javascript代码、数据库数据、图片或者视频等，资源可以以多种形式表现，例如数据库数据可以通过渲染成图片可视化之后呈现，也可以绘制表格以展示。为了响应资源请求，需要Web服务器根据URL定位网络资源在本地的位置，即要实现路由（Router）功能。Web服务器解析URL，分析是否在本机，根据本机地址的相对地址，找到相应资源返回，或者根据正则表达式，把请求转发给内部的其他服务器。后者可以称为反向代理，如图\ref{server_stru}所示。

\begin{figure}
  \centering
  \includegraphics[width=0.4\textwidth]{server_stru.pdf}
  \caption{反向代理示意图}\label{server_stru}
\end{figure}

\paragraph{设备服务器}

设备服务器需要完成响应设备发出的请求，维护设备的网络位置，转发用户请求给相应的设备等三个功能。响应设备发出的请求即接收设备发出的数据，根据已知协议解析数据。维护设备网络位置，是根据GPRS内网的网络特性决定的，NAT技术会将GPRS内网的IP与网关的一个端口绑定一段时间，为了随时能够访问设备，需要维护内网设备与网关端口的绑定，以及维护一个设备网络位置的动态列表，该列表支持根据设备ID查询设备的网络位置。转发用户请求，顾名思义，是设备服务器监听用户的请求，将请求作筛选之后转发给符合条件的设备。

\paragraph{应用服务器}

应用服务器的任务是转发设备数据给订阅的客户端。为了方便客户端能及时接受数据，订阅机制应该是服务器主动向客户端推送数据。目前HTML5技术已经在普及，其中有一项技术支持数据从服务端单向推送给客户端，称为Server-Sent Events(SSE)：

Server-Sent Events支持客户端-服务端之间高效传输文本字段的事件（event）数据，即在服务器产生实时通知或者更新。为了实现这个目标，SSE介绍了两个新的组件，在浏览器上的一个新的接口，称为EventSource，它允许客户端从服务器接收通知推送，作为DOM事件；另一个是事件流（event stream）的数据格式，用于传递独立的更新消息。

应用服务器在服务器上开放多个API供给浏览器订阅，为了响应HTTP协议的设计理念，API的URL设计为REST风格。Web服务器需要将相应的URL资源请求通过路由反向代理给应用服务器。

\subsubsection{系统设计}

\paragraph{Web服务器}

根据资源的请求，可以将Web服务器分为两个部分，静态资源交给传统的Web服务器处理，包括网页、css、js、图片等，同时静态服务器还需要完成反向代理的功能，于是需要完成静态路由功能。nginx是一个高性能的Web/反向代理服务器，由于静态服务器的要求不多，配置也比较简单，所以选择了nginx服务器作为静态Web服务器。

动态资源交给动态页面服务器生成。所谓动态资源，是服务器根据本机资源，运行相应的脚本程序，把生成的结果作为资源返回给客户端。因为同一个资源可能在不同条件下结果不同，是程序执行的输出，所以称为动态资源。动态服务器需要完成高级路由功能，利用HTML模板技术把数据填充给模板上相应的位置，再把网页返回给客户端。

如图\ref{fig_web_stru}所示，检测节点页面是动态资源的，相应的界面是动态服务器生成的HTML代码，其URL格式如下：

/node/\{:Id\}

根据Id号的变更，就可以向Web服务器请求相应设备Id的资源，动态服务器需要解析URL，将资源路由给模板程序。模板程序获取URL中设备的Id之后，动态生成设备状态网页返回给客户端。

两种资源的路由如图\ref{web_router}

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{web_router.pdf}
  \caption{Web资源请求路由}\label{web_router}
\end{figure}

\paragraph{设备服务器}

设备服务器开放一个端口监听设备请求，所有设备将数据利用UDP协议发送给该端口。待设备服务器接收到数据之后，解析数据的网络地址，并根据第二章描述的应用层协议解析数据发送的设备Id，更新程序内部的设备动态列表：若设备Id不存在则添加条目，若Id与网络位置不对应，则根据Id更新设备的网络位置。同时设备会以一定的时间间隔发送心跳包给服务器，服务器需要不断监听设备的心跳包，若心跳包超时，即判断设备出现故障（网络故障、设备关机等）。

设备通讯的流程如图\ref{dev_conn}所示，设备有多次心跳包没有发送到达服务端，服务端的定时器超时，认为设备已经下线。

\begin{figure}
  \centering
  \includegraphics[width=0.5\textwidth]{dev_conn.pdf}
  \caption{设备心跳包通讯图}\label{dev_conn}
\end{figure}

\paragraph{应用服务器}

应用服务器需要获得反向代理转发的请求，解析请求的对象，将请求路由给相应的转发程序，同时也需要监听设备服务器发送的数据通知。监听程序监听到新的数据时，将数据根据设备Id分类，将符合要求的设备数据通知给转发程序，转发程序维护一个客户端的列表，每当新的设备数据到达的时候，转发程序获取设备数据，依次根据客户端列表把数据发送给目标地址。

数据和命令之间在应用服务器和设备服务器之间周转，如图\ref{server_comm}所示。

\begin{figure}
  \centering
  \includegraphics[width=0.8\textwidth]{server_comm.pdf}
  \caption{数据和命令在服务器之间传输}\label{server_comm}
\end{figure}

\subsubsection{系统实现与测试}

\paragraph{Web服务器}

Web静态服务器部署nginx，需要设定内部的反向代理，具体设定如列表\ref{conf_nginx}，根据URL地址将请求转发给内部运行的各种服务器端口。

Web动态服务器采用Go语言编写，开放本地端口10242，nginx将所有前缀为/node/\{:Id\}，/api/status/\{:Id\}的URL反向代理给动态服务器处理。/node/\{:Id\}用于查看设备实时运行状态，包括气体浓度的实时图表、表格和控制面板，动态服务器利用HTML模板技术生成网页，具体实现的时候利用缓存技术加速处理，见列表\ref{golang_web}：

/api/status/\{:Id\}则用于获取、设定设备的运行状态，是一个REST风格的API，支持HTTP GET和POST操作。GET操作可以获得设备状态，而POST操作可以设定设备状态。API采用JSON格式作为数据交换格式，字段包括：

\begin{minipage}{0.8\textwidth}\centering
  \begin{lstlisting}[language=Java,
  numbers=left,
  numbersep=5pt,
%  caption={JSON syntax},
  showstringspaces=false,
  label={lst_json}]
{
    id: id,
    cmd: "devQuery"/"devStart"/"devStop"
}
   \end{lstlisting}
\end{minipage}

``devQuery''可查询设备状态，将状态返回给浏览器，其余命令则设定设备状态，无返回值。


\paragraph{设备服务器}

设备服务器也采用Go语言实现，监听5683端口，当端口有新的数据请求时，开启新的协程（goroutine）处理请求。协程首先复制缓冲区数据至内存，根据第二章的协议寻找帧头将帧从数据流中拆分，开启新协程处理，此协程称为负载协程。

负载协程获取设备id，数据类型，在设备列表中登记设备的网络地址，开启设备定时器协程，并将气体浓度数据转从二进制化为float64类型，通过通道（channel）发送给Unix socket。

设备定时器协程用于记录至今设备与服务器最后一次通讯的时间，若时间过长的话，协程认为设备和服务器之间的端口绑定失效，设备无法寻址，因此在设备列表中注销设备的网络地址。

Unix socket用于设备服务器和应用服务器之间的交互，在Linux系统下，利用Unix Socket作为一种进程间通讯的方法十分普遍。

\paragraph{应用服务器}

应用服务器监听/api/events前缀的URL，负责设备数据的广播。应用服务器内部实现了一个广播器，当客户端通过URL访问某设备id的状态时，广播器新建通道，触发信号通知通道使能，开启广播协程不断监听来自通道的事件并转发给客户端；当客户端断开连接或超时的时候，触发关闭信号，协程关闭通道并退出广播协程。

应用服务器同时监听Unix socket的气体浓度数据，当有新的气体浓度数据到达时，将数据推送给广播器处理。广播器根据设备Id，将数据推送给符合要求的客户端广播通道。

\subsection{前端设计}

\subsubsection{页面设计}

如图\ref{fig_web_stru}所示，监控平台包括3个界面：身份认证、地理信息系统和检测节点。身份认证界面用于监控平台的登入，防止非法用户进入系统操作设备，地理信息系统界面显示设备的当前地理位置，地图上有标签标识设备的位置，鼠标指向提示窗可观察节点实时气体浓度，检测节点界面则显示了设备气体浓度的详细信息，包括曲线、最近10秒的气体浓度数据、设备状态和控制按钮。

\subsubsection{页面功能实现}

\begin{description}
  \item[身份认证] 身份认证采用javascript脚本实现，定义文本输入框和提交按钮，javascript判断用户名和密码是否一致，若一致则跳转到地理信息系统界面，否则返回HTTP 403状态。
  \item[地理信息系统] 地理信息系统的地图采用Openlayers 3库，从外部导入地图数据。利用javascript脚本在地图上添加向量层，在向量层上定义地图标签、设备Id、设备经纬度等信息。利用bootstrap库引入提示窗，并监听鼠标几何坐标。当鼠标坐标覆盖设备的图标时候，生成提示窗信息并弹出提示窗。
  \item[检测节点] 检测节点的页面由Web动态服务器生成，根据设备Id订阅相应的设备通道。在页面上有三个区域（section）：按钮控制区、浓度曲线区和浓度列表区。按钮控制区放置了设备运行和停止按钮，jQuery接管按钮行为，把请求利用POST方法转发给/api的应用服务器。浓度曲线区放置了一个图标，用于显示气体浓度曲线，采用的库是charist.js。浓度列表区放置了一个表格，表头包含Time、\ce{SO_2}、\ce{NO_2}、\ce{O_3}、\ce{CO}、Temp和RH。
\end{description}

初始状态图表和表格都没有数据，javascript在页面装载完毕之后开始利用EventSource API订阅/api/events/\{:Id\}的事件。当新的事件到达的时候，回调函数解析事件数据，把设备数据添加到图表里，并刷新图表。同时回调函数也在表格中添加新的一行数据，根据表格最大行的设定相应地把最后一行数据去除显示。以上功能都利用了jQuery库和HTML5技术。

\subsubsection{页面调试与优化}

前端开发面对的是直观的网页和不直观的javascript语句，网页布局可以直接通过浏览器观察，并通过文本编辑器更改HTML代码。javascript语句需要根据网页行为判断是否实现了期望的功能。为了提高调试效率，需要利用网页端的调试工具。Chrome浏览器提供了强大的开发者工具，活用Chrome浏览器是前端开发的一项必备技能。

利用console.log语句可以打印javascript中的变量信息，而console可以在线执行javascript命令。为了调试函数内部的语句，可以在函数内部设置断点，待断点激活的时候console环境即可访问函数内部的变量，十分地方便。

javascript的性能在以往皆不忍瞩目，直到Google引入了V8引擎，大幅提升了javascript的执行效率。目前一般的javascript应用，性能已经不是一个问题，但是在监控平台上需要显示数以百计的图表，因此性能优化需要注意。javascript默认的赋值都是按值赋值，因此会引入不要的变量拷贝，在更新气体浓度序列的时候尤其是个问题。为了解决这个问题，需要利用javascript的object避免复制，同时利用javascript数组的shitf()和append()方法加速数组变量的更新。

\section{本章小结}

本章介绍了系统的软件设计，包括下位机的控制界面和上位机的网络监控平台。下位机利用Qt/QML编写了界面，将数据按日期时间存储至PostgreSQL数据库内，并利用GPRS数据透传模块通过串口发送数据给上位机。界面上能控制仪器的电气设备、加热模块、数据采集卡等，能显示采集数据的电压波形、气体浓度波形等，可设定驱动信号波形、导出数据库数据。

上位机分为前端和后端开发，其中服务器开发占据主要地位，包括设备服务器和网络服务器。设备服务器负责设备事务，网络服务器处理客户端请求。用户通过浏览器访问设备信息，并控制设备状态。上位机开发主要采用javascript和go语言实现前端和后端功能。