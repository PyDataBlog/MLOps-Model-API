\section{Updating frequencies of subgraphs}
\label{sec:upd}

The main bottleneck of the method described in the previous section is
computing the frequencies of subgraphs in every iteration, to estimate
the energy of the current solution. In \cite{milo2002network}, an
analogous operation was done recounting the frequencies of subgraphs
after each iteration of their algorithm until convergence. Our
approach avoids recomputing all of the frequencies by only considering
the subgraphs that are changed by the addition or removal of a certain
edge.

The base of our method is the {\tt FaSE} \cite{paredes2013towards}
algorithm, which we will extend in order to only count subgraphs that
touch a given edge. Firstly, we will briefly describe the algorithm.

\subsection{FaSE Algorithm}

The original {\tt FaSE} algorithm enumerates all connected subgraphs
of a given size $K$ and in the end computes the isomorphism of some of
the subgraphs. To avoid having to compute the isomorphism of all
subgraphs, the algorithm partitions subgraphs into intermediate
classes during the enumeration process. By requiring that all
subgraphs in one of the intermediate classes are isomorphic, in the
end we only need to compute one isomorphism test per class. This is
done by encapsulating the topological features of the enumerating
graph in a tree like data structure. Thus, we can divide the algorithm
into two interleaved concepts: the enumeration and a tree data
structure.

{\bf Enumeration}: The enumeration step can be done using any
algorithm that grows a set of connected vertices. The algorithm from
\cite{wernicke2006efficient}, {\tt ESU}, was chosen since it is
simple, efficient and fulfills all the requirements. We will describe
its functioning since it will be useful for the end of this section.

{\tt ESU} works by enumerating all size $K$ subgraphs exactly once. It
does so by keeping two ordered sets of vertices: $V_s$, which
represents the partial subgraph that is currently being enumerated;
$V_{ext}$, which represents the set of vertices that can be added to
$V_s$ as a valid extension. Each vertex is represented by a label
which is unique and defined between $1$ and $|V|$.

For each vertex $v$ the algorithm repeats the same procedure setting
initially $V_s = \{v\}$ and $V_{ext} = N(v)$, where $N(v)$ are the
neighbors of $v$. This procedure starts by removing one element $u$ of
$V_{ext}$ at a time. For each $u$, a new $V_s'$ and $V_{ext}'$ are
created and the same procedure is repeated. $V_s'$ is set to $V_s \cup
\{u\}$ and $V_{ext}'$ is set to $V_{ext}$ without $u$ and with
additionally each element in $N_{exc}(u, V_s)$ with value greater than
$v$. $N_{exc} (u, V_s)$ are the exclusive neighbors of $u$ given
$V_s$, that is, the neighbors of $u$ that are not neighbors of
elements in $V_s$. This procedure stops when the size of $V_s$ reaches
$K$, in which case $V_s$ contains one occurrence of size $K$. The
addition of elements in $N_{exc}(u, V_s)$ along with the $u > v$,
ensure that there is no subgraph enumerated twice, and it can be
proved \cite{wernicke2006efficient} that this procedure stops and
enumerates all subgraphs.

{\bf The tree data structure}: During the enumeration process, this
data structure is used to encapsulate information about the subgraph
contained in $V_s$. Since this is a recursive procedure, one can use
information about the initial content of $V_s$ to build a partial
isomorphism representation, that can be complemented on each vertex
insertion in $V_s$. For this, a data structure called a gtrie is used,
which is similar to a prefix tree of subgraphs. Whenever a new vertex
is added to $V_s$, one uses the information of connectivity with the
previous elements of $V_s$ to generate a label that identifies the
current partial subgraph, which is used as the identifier for the
mentioned intermediate classes.

Figure \ref{fig:gtrie} summarizes the whole algorithm. The tree on the
left represents the implicit recursion tree ESU creates. The induced
g-trie on the right is a visual representation of the actual g-trie
{\tt FaSE} creates. More information about the {\tt FaSE} can be found in
\cite{paredes2013towards}.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.9\columnwidth]{fase}
  \caption{Summary of the {\tt FaSE} algorithm.}
  \label{fig:gtrie}
\end{figure}

\subsection{FaSE with updates}

Our method to efficiently update frequency counts works by altering
the enumeration algorithm to count frequencies starting on edges. When
adding an edge, the algorithm first counts all subgraphs that use the
edge's two ends and decrements their frequency. Afterwards, it adds
the new edge and counts all subgraphs that touch that edge. To remove
an edge we do an analogous process. Our method is based on the {\tt
  ESU} algorithm, altering it to start on a given edge.

For a given edge to add, $\{a, b\}$, the algorithm first considers as
initial sets $V_s = \{a, b\}$ and $V_{ext} = N(a) \cup N(b) \setminus
\{a, b\}$ and only uses these as initial sets (meaning it does not
recurse on other initial $V_s$ and $V_{ext}$). The rest of the
procedure is similar to the original {\tt ESU} algorithm, but the
symmetry breaking is removed, that is, when adding a node $u'$ to
$V_{ext}$, there is no comparison with $a$: if $u'$ belongs to
$N_{exc}(u, V_s)$ it will be added to $V_{ext}$.

To prove that this method is correct we use the original correction
proof of the {\tt ESU} algorithm. If $a$ is the minimal node of the
graph (that is, for every node $v$, $a \leq v$), all subgraphs that
include $a$ will be enumerated on the first iteration of the
algorithm. For that iteration, if $b$ is the first element of
$N_{ext}$, then it will be removed and the next iteration has $V_s =
\{a, b\}$ and $V_{ext} = N(a) \setminus \{b\} \cup N_{exc}(b, \{a\}) =
N(a) \cup N(b) \setminus \{a, b\}$. Since this is the only recursion
path that will include $a$ and $b$ (since $b$ was the first node to be
removed from the initial $N_{ext}$), all subgraphs that contain $a$
and $b$ will be counted on this recursive subtree. Since this is
analogous to our method, its correctness implies the correctness of
our method.
