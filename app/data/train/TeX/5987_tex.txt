\hypertarget{sbrk_8h}{
\section{/home/doki/AGCS/src/mmanager/alloc/sbrk.h File Reference}
\label{sbrk_8h}\index{/home/doki/AGCS/src/mmanager/alloc/sbrk.h@{/home/doki/AGCS/src/mmanager/alloc/sbrk.h}}
}


\subsection{Detailed Description}
Header for \hyperlink{sbrk_8c}{mmanager/alloc/sbrk.c}. 

\begin{Desc}
\item[Author:]Dorian Ivancic \href{mailto:dorian@linux.hr}{\tt dorian@linux.hr} \end{Desc}
\begin{Desc}
\item[Date:]2005-11-12\end{Desc}
\begin{Desc}
\item[Warning:]None so far.\end{Desc}
\begin{Desc}
\item[\hyperlink{bug__bug000041}{Bug}]There are no known bugs. \end{Desc}


Definition in file \hyperlink{sbrk_8h-source}{sbrk.h}.

{\tt \#include \char`\"{}context.h\char`\"{}}\par
\subsection*{Functions}
\begin{CompactItemize}
\item 
unsigned long int \hyperlink{sbrk_8h_d6514b5e02d5cf3e4e53bfb80c3cf9e4}{i\_\-sbrk} (\hyperlink{structstr____ctx}{str\_\-\_\-ctx} $\ast$ctx)
\begin{CompactList}\small\item\em This expands memory block. \item\end{CompactList}\end{CompactItemize}


\subsection{Function Documentation}
\hypertarget{sbrk_8h_d6514b5e02d5cf3e4e53bfb80c3cf9e4}{
\index{sbrk.h@{sbrk.h}!i\_\-sbrk@{i\_\-sbrk}}
\index{i\_\-sbrk@{i\_\-sbrk}!sbrk.h@{sbrk.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}unsigned long int i\_\-sbrk ({\bf str\_\-\_\-ctx} $\ast$ {\em ctx})}}
\label{sbrk_8h_d6514b5e02d5cf3e4e53bfb80c3cf9e4}


This expands memory block. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em ctx}]Simulator context with command line params.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]unsigned long int.\end{Desc}
\begin{Desc}
\item[See also:]\hyperlink{structstr____ctx}{str\_\-\_\-ctx}\end{Desc}
\begin{Desc}
\item[Author:]Dorian Ivancic \href{mailto:dorian@linux.hr}{\tt dorian@linux.hr} \end{Desc}
\begin{Desc}
\item[Date:]2005-11-12 \end{Desc}


Definition at line 63 of file sbrk.c.

References ALLOC\_\-ALGO\_\-\_\-ATVD\_\-FITS, ALLOC\_\-ALGO\_\-\_\-DI\_\-FF, ALLOC\_\-ALGO\_\-\_\-DK\_\-BB, ALLOC\_\-ALGO\_\-\_\-IP\_\-SFF, ALLOC\_\-ALGO\_\-\_\-MG\_\-BSD, ALLOC\_\-ALGO\_\-\_\-MG\_\-DL, atvd\_\-fits\_\-sbrk(), cur\_\-mem\_\-size, di\_\-ff\_\-sbrk(), dk\_\-bb\_\-sbrk(), fatal(), ip\_\-sff\_\-sbrk(), mg\_\-bsd\_\-sbrk(), and mg\_\-dl\_\-sbrk().

Referenced by eval\_\-event\_\-new\_\-object\_\-dbi\_\-l\_\-ms(), eval\_\-event\_\-new\_\-object\_\-di\_\-diag\_\-ms(), eval\_\-event\_\-new\_\-object\_\-di\_\-ms(), eval\_\-event\_\-new\_\-object\_\-di\_\-no\_\-gc(), eval\_\-event\_\-new\_\-object\_\-di\_\-tb\_\-dnr\_\-ms(), eval\_\-event\_\-new\_\-object\_\-di\_\-tb\_\-ms\_\-ws(), eval\_\-event\_\-new\_\-object\_\-di\_\-tb\_\-nr\_\-ms(), and eval\_\-event\_\-new\_\-object\_\-di\_\-tb\_\-pr\_\-ms().

\begin{Code}\begin{verbatim}65 {
66     #ifdef DEBUG
67         unsigned int    i;
68     #endif /* #ifdef DEBUG */
69 
70     /* are we going to leak out of our block? */
71     if (ctx -> cur_mem_size + ctx -> alloc_step_size <= ctx -> max_mem_size)
72     {
73         #ifdef DEBUG
74             for (i = 0; i < ctx -> alloc_step_size; i++)
75                 ((byte*) ctx -> sysmem_block + ctx -> cur_mem_size)[i] = FILL_PATTERN;
76         #endif /* #ifdef DEBUG */
77 
78         /* increase current memory size */
79         ctx -> cur_mem_size += ctx -> alloc_step_size;
80 
81         /* do algorithm specific initialization */
82         switch (ctx -> alloc_algo)
83         {
84             /* Danijel Keleminec, binary buddy */
85             case ALLOC_ALGO__DK_BB:
86                 dk_bb_sbrk (ctx);
87                 break;
88 
89             /* Aleksandar Topuzovic, Veljko Dragsic, Fits */
90             case ALLOC_ALGO__ATVD_FITS:
91                 atvd_fits_sbrk (ctx);
92                 break;
93 
94             case ALLOC_ALGO__DI_FF:
95                 di_ff_sbrk (ctx);
96                 break;
97 
98             case ALLOC_ALGO__MG_BSD:
99                 mg_bsd_sbrk (ctx);
100                 break;
101 
102             case ALLOC_ALGO__MG_DL:
103                 mg_dl_sbrk (ctx);
104                 break;
105 
106             case ALLOC_ALGO__IP_SFF:
107                 ip_sff_sbrk (ctx);
108                 break;
109 
110             /* we should never get here! */
111             default:
112                 fatal (MSG__SBRK__I_SBRK__INTERNAL_ERROR
113                     , EXIT_CODE__SBRK__I_SBRK__INTERNAL_ERROR
114                     , ctx);
115                 break;
116         }
117 
118         /* adjust counter */
119         ctx -> counter.sbrk ++;
120 
121         /* this should be the same as ctx -> cur_mem_size */
122         ctx -> counter.heap_size += ctx -> alloc_step_size;
123 
124         /* we succeeded, return size that was added */
125         return (ctx -> alloc_step_size);
126     }
127 
128     /* we failed! */
129     return (0);
130 }
\end{verbatim}
\end{Code}


