\hypertarget{ip__sff_8h}{
\section{/home/doki/AGCS/src/mmanager/alloc/ip\_\-sff.h File Reference}
\label{ip__sff_8h}\index{/home/doki/AGCS/src/mmanager/alloc/ip\_\-sff.h@{/home/doki/AGCS/src/mmanager/alloc/ip\_\-sff.h}}
}


\subsection{Detailed Description}
Header for \hyperlink{ip__sff_8c}{mmanager/alloc/ip\_\-sff.c}. 

\begin{Desc}
\item[Author:]Ivan Popovski \href{mailto:ivan.popovski@srce.hr}{\tt ivan.popovski@srce.hr} \end{Desc}
\begin{Desc}
\item[Date:]2009-01-05\end{Desc}
\begin{Desc}
\item[Warning:]None so far.\end{Desc}
\begin{Desc}
\item[\hyperlink{bug__bug000031}{Bug}]There are no known bugs. \end{Desc}


Definition in file \hyperlink{ip__sff_8h-source}{ip\_\-sff.h}.

{\tt \#include $<$stdlib.h$>$}\par
{\tt \#include \char`\"{}context.h\char`\"{}}\par
\subsection*{Enumerations}
\begin{CompactItemize}
\item 
enum \hyperlink{ip__sff_8h_0ef43d437c955f47da1b9612ed0f5ac8}{ret\_\-\_\-ip\_\-sff\_\-is\_\-block\_\-free} \{ \textbf{RET\_\-\_\-IP\_\-SFF\_\-IS\_\-BLOCK\_\-FREE\_\-\_\-FREE\_\-BLOCK} = 1, 
\textbf{RET\_\-\_\-IP\_\-SFF\_\-IS\_\-BLOCK\_\-FREE\_\-\_\-USED\_\-BLOCK}
 \}
\begin{CompactList}\small\item\em Return values for ip\_\-sff\_\-is\_\-block\_\-free. \item\end{CompactList}\item 
enum \hyperlink{ip__sff_8h_1e74f73e8c27ca683a74e72e1d1bfb60}{ret\_\-\_\-ip\_\-sff\_\-is\_\-block\_\-used} \{ \textbf{RET\_\-\_\-IP\_\-SFF\_\-IS\_\-BLOCK\_\-USED\_\-\_\-USED\_\-BLOCK} = 1, 
\textbf{RET\_\-\_\-IP\_\-SFF\_\-IS\_\-BLOCK\_\-USED\_\-\_\-FREE\_\-BLOCK}
 \}
\begin{CompactList}\small\item\em Return values for ip\_\-sff\_\-is\_\-block\_\-used. \item\end{CompactList}\end{CompactItemize}
\subsection*{Functions}
\begin{CompactItemize}
\item 
void \hyperlink{ip__sff_8h_39bbf53849241cf7673463f332537730}{ip\_\-sff\_\-init} (void $\ast$ptr, size\_\-t size, \hyperlink{structstr____ctx}{str\_\-\_\-ctx} $\ast$ctx)
\begin{CompactList}\small\item\em Initializes memory. \item\end{CompactList}\item 
void \hyperlink{ip__sff_8h_d50bc16c203c5ce9532bbd514c9b3a2c}{ip\_\-sff\_\-drop} (\hyperlink{structstr____ctx}{str\_\-\_\-ctx} $\ast$ctx)
\begin{CompactList}\small\item\em Drops the memory. \item\end{CompactList}\item 
void \hyperlink{ip__sff_8h_264eaa8e59d469a3eec30187b2cec04f}{ip\_\-sff\_\-sbrk} (\hyperlink{structstr____ctx}{str\_\-\_\-ctx} $\ast$ctx)
\begin{CompactList}\small\item\em Sbrk adjustments. \item\end{CompactList}\item 
void $\ast$ \hyperlink{ip__sff_8h_f579e283cbd85501b5aa1d160cfed07e}{ip\_\-sff\_\-alloc} (size\_\-t size, \hyperlink{structstr____ctx}{str\_\-\_\-ctx} $\ast$ctx)
\begin{CompactList}\small\item\em Allocates memory block. \item\end{CompactList}\item 
void \hyperlink{ip__sff_8h_64e89fd27bfbca132314dac762b45589}{ip\_\-sff\_\-free} (void $\ast$ptr, \hyperlink{structstr____ctx}{str\_\-\_\-ctx} $\ast$ctx)
\begin{CompactList}\small\item\em Frees given memory block. \item\end{CompactList}\item 
unsigned int \hyperlink{ip__sff_8h_e25f1262966a1dc5adb1fcf66118ea7d}{ip\_\-sff\_\-get\_\-unused\_\-bits\_\-num} (void)
\begin{CompactList}\small\item\em Taken from di\_\-ff and mg\_\-dl. \item\end{CompactList}\item 
unsigned int \hyperlink{ip__sff_8h_94be05400c624d8e122ae47f3e55a2e3}{ip\_\-sff\_\-get\_\-unused\_\-bits} (void $\ast$ptr, \hyperlink{structstr____ctx}{str\_\-\_\-ctx} $\ast$)
\begin{CompactList}\small\item\em This function returns unused bits for given $\ast$USED$\ast$ memory block. \item\end{CompactList}\item 
void \hyperlink{ip__sff_8h_77f2eb6813ec2e09075474aa5e25131e}{ip\_\-sff\_\-set\_\-unused\_\-bits} (unsigned int bits, void $\ast$ptr)
\begin{CompactList}\small\item\em This function sets unused bits in given $\ast$USED$\ast$ memory block. \item\end{CompactList}\item 
void $\ast$ \hyperlink{ip__sff_8h_fe105ab88c73b8c2f27aba5f753868b5}{ip\_\-sff\_\-get\_\-first\_\-used\_\-block} (\hyperlink{structstr____ctx}{str\_\-\_\-ctx} $\ast$ctx)
\begin{CompactList}\small\item\em This function fetches first used block from simulator's memory. \item\end{CompactList}\item 
void $\ast$ \hyperlink{ip__sff_8h_ebab029460751e6c9b1c036496bfa80c}{ip\_\-sff\_\-get\_\-next\_\-used\_\-block} (void $\ast$ptr, \hyperlink{structstr____ctx}{str\_\-\_\-ctx} $\ast$ctx)
\begin{CompactList}\small\item\em This function fetches used block following the given one. \item\end{CompactList}\item 
void $\ast$ \hyperlink{ip__sff_8h_f505f956cb6c8f38fff94af2fe225a6c}{ip\_\-sff\_\-get\_\-first\_\-free\_\-block} (\hyperlink{structstr____ctx}{str\_\-\_\-ctx} $\ast$ctx)
\begin{CompactList}\small\item\em This function fetches first free block from simulator's memory. \item\end{CompactList}\item 
void $\ast$ \hyperlink{ip__sff_8h_29626065cd5157bfed1b55b6e039b89a}{ip\_\-sff\_\-get\_\-next\_\-free\_\-block} (void $\ast$ptr, \hyperlink{structstr____ctx}{str\_\-\_\-ctx} $\ast$ctx)
\begin{CompactList}\small\item\em This function fetches free block following the given one. \item\end{CompactList}\item 
unsigned int \hyperlink{ip__sff_8h_d6386e1614a555536874050e62736942}{ip\_\-sff\_\-get\_\-num\_\-of\_\-used\_\-blocks} (\hyperlink{structstr____ctx}{str\_\-\_\-ctx} $\ast$ctx)
\begin{CompactList}\small\item\em This function returns the number of used blocks. \item\end{CompactList}\item 
unsigned long int \hyperlink{ip__sff_8h_fd0d0514b4e3f8ac449aeb39c63a7a1c}{ip\_\-sff\_\-get\_\-size\_\-of\_\-used\_\-blocks} (\hyperlink{structstr____ctx}{str\_\-\_\-ctx} $\ast$ctx)
\begin{CompactList}\small\item\em This function returns the sum of sizes of used blocks. \item\end{CompactList}\item 
unsigned int \hyperlink{ip__sff_8h_5e41bf3c2fbafbfe0d4741d4b1ea0f40}{ip\_\-sff\_\-get\_\-num\_\-of\_\-free\_\-blocks} (\hyperlink{structstr____ctx}{str\_\-\_\-ctx} $\ast$ctx)
\begin{CompactList}\small\item\em This function returns the number of free blocks. \item\end{CompactList}\item 
unsigned long int \hyperlink{ip__sff_8h_bc2c104e16089879326f2675c8cce7a2}{ip\_\-sff\_\-get\_\-size\_\-of\_\-free\_\-blocks} (\hyperlink{structstr____ctx}{str\_\-\_\-ctx} $\ast$ctx)
\begin{CompactList}\small\item\em This function returns the sum of sizes of free blocks. \item\end{CompactList}\item 
void $\ast$ \hyperlink{ip__sff_8h_3db1c8837b7910521dfe489e76ec7430}{ip\_\-sff\_\-get\_\-first\_\-block} (\hyperlink{structstr____ctx}{str\_\-\_\-ctx} $\ast$ctx)
\begin{CompactList}\small\item\em This function fetches the first block from simulator's memory. \item\end{CompactList}\item 
void $\ast$ \hyperlink{ip__sff_8h_00458d11726d5feae14841def65ad387}{ip\_\-sff\_\-get\_\-next\_\-block} (void $\ast$ptr, \hyperlink{structstr____ctx}{str\_\-\_\-ctx} $\ast$ctx)
\begin{CompactList}\small\item\em This function fetches the block following the given one. \item\end{CompactList}\item 
void $\ast$ \hyperlink{ip__sff_8h_ffccf3a9bea082acaab68a19f4c857ac}{ip\_\-sff\_\-get\_\-last\_\-block} (\hyperlink{structstr____ctx}{str\_\-\_\-ctx} $\ast$ctx)
\begin{CompactList}\small\item\em This function fetches the last block from simulator's memory. \item\end{CompactList}\item 
void $\ast$ \hyperlink{ip__sff_8h_36a1e956083edbd4d29208cfcfdd96ed}{ip\_\-sff\_\-get\_\-prev\_\-block} (void $\ast$ptr, \hyperlink{structstr____ctx}{str\_\-\_\-ctx} $\ast$ctx)
\begin{CompactList}\small\item\em This function fetches the block preceding the given one. \item\end{CompactList}\item 
size\_\-t \hyperlink{ip__sff_8h_b4c15a7906d6a3a1df904874e3d0bb46}{ip\_\-sff\_\-get\_\-block\_\-size} (void $\ast$ptr, \hyperlink{structstr____ctx}{str\_\-\_\-ctx} $\ast$ctx)
\begin{CompactList}\small\item\em This function returns the usable bytes in current block. \item\end{CompactList}\item 
enum \hyperlink{ip__sff_8h_0ef43d437c955f47da1b9612ed0f5ac8}{ret\_\-\_\-ip\_\-sff\_\-is\_\-block\_\-free} \hyperlink{ip__sff_8h_6563e99560182df05523acc51da24332}{ip\_\-sff\_\-is\_\-block\_\-free} (void $\ast$ptr, \hyperlink{structstr____ctx}{str\_\-\_\-ctx} $\ast$ctx)
\begin{CompactList}\small\item\em This function returns the status of the block - free or used. \item\end{CompactList}\item 
enum \hyperlink{ip__sff_8h_1e74f73e8c27ca683a74e72e1d1bfb60}{ret\_\-\_\-ip\_\-sff\_\-is\_\-block\_\-used} \hyperlink{ip__sff_8h_dc4c639cc9925d1e24c1775f939510d9}{ip\_\-sff\_\-is\_\-block\_\-used} (void $\ast$ptr, \hyperlink{structstr____ctx}{str\_\-\_\-ctx} $\ast$ctx)
\begin{CompactList}\small\item\em This function returns the status of the block - free or used. \item\end{CompactList}\item 
void $\ast$ \hyperlink{ip__sff_8h_364cf00d14dd63d23c8d19b1eeaa93be}{ip\_\-sff\_\-block\_\-copy} (void $\ast$dst, void $\ast$src, \hyperlink{structstr____ctx}{str\_\-\_\-ctx} $\ast$ctx)
\begin{CompactList}\small\item\em This function is used to copy memory block. \item\end{CompactList}\item 
void $\ast$ \hyperlink{ip__sff_8h_06748ab545b8993beece4ce80a1b5fae}{ip\_\-sff\_\-block\_\-move} (void $\ast$dst, void $\ast$src, \hyperlink{structstr____ctx}{str\_\-\_\-ctx} $\ast$ctx)
\begin{CompactList}\small\item\em This function is used to move memory block. \item\end{CompactList}\item 
int \hyperlink{ip__sff_8h_9dc0e72fbce3d6cf0a01a80996809458}{ip\_\-sff\_\-get\_\-allocator\_\-state} (\hyperlink{structstr____ctx}{str\_\-\_\-ctx} $\ast$ctx)
\begin{CompactList}\small\item\em This function returns the state of the allocator. \item\end{CompactList}\item 
void \hyperlink{ip__sff_8h_9022db5a54bf31bdad21df2836e1d365}{ip\_\-sff\_\-set\_\-allocator\_\-state} (int state, \hyperlink{structstr____ctx}{str\_\-\_\-ctx} $\ast$ctx)
\begin{CompactList}\small\item\em This function sets the state of the allocator. \item\end{CompactList}\item 
void \hyperlink{ip__sff_8h_3f9134c53f38b27ccd4938aa8d4ad09d}{ip\_\-sff\_\-print\_\-stat} (\hyperlink{structstr____ctx}{str\_\-\_\-ctx} $\ast$ctx)
\begin{CompactList}\small\item\em Print statistics. \item\end{CompactList}\item 
void \hyperlink{ip__sff_8h_f6000d6e7bd3d62c7f845eb0e3717e82}{ip\_\-sff\_\-mem\_\-dump} (\hyperlink{structstr____ctx}{str\_\-\_\-ctx} $\ast$ctx)
\begin{CompactList}\small\item\em Memory dump. \item\end{CompactList}\end{CompactItemize}


\subsection{Function Documentation}
\hypertarget{ip__sff_8h_39bbf53849241cf7673463f332537730}{
\index{ip\_\-sff.h@{ip\_\-sff.h}!ip\_\-sff\_\-init@{ip\_\-sff\_\-init}}
\index{ip\_\-sff\_\-init@{ip\_\-sff\_\-init}!ip_sff.h@{ip\_\-sff.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void ip\_\-sff\_\-init (void $\ast$ {\em ptr}, \/  size\_\-t {\em size}, \/  {\bf str\_\-\_\-ctx} $\ast$ {\em ctx})}}
\label{ip__sff_8h_39bbf53849241cf7673463f332537730}


Initializes memory. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em ptr}]Pointer to memory space. \item[\mbox{$\leftarrow$} {\em size}]Size of memory. \item[\mbox{$\leftarrow$} {\em ctx}]Simulator's context.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Nothing.\end{Desc}
\begin{Desc}
\item[Author:]Ivan Popovski \href{mailto:ivan.popovski@srce.hr}{\tt ivan.popovski@srce.hr} \end{Desc}
\begin{Desc}
\item[Date:]2009-02-15 \end{Desc}


Definition at line 495 of file ip\_\-sff.c.

References ALLOC\_\-STEP, clear\_\-this\_\-in\_\-use\_\-this, context, fatal(), get\_\-treap\_\-root, init\_\-treap\_\-node, reset\_\-alloc\_\-counter, reset\_\-free\_\-counter, reset\_\-sbrk\_\-counter, reset\_\-total\_\-alloc\_\-timer, reset\_\-total\_\-free\_\-timer, reset\_\-total\_\-sbrk\_\-timer, set\_\-last\_\-block, set\_\-prev\_\-size\_\-this, set\_\-this\_\-size\_\-this, and set\_\-treap\_\-root.

\begin{Code}\begin{verbatim}499 {
500     str__treap_node *this;
501 
502     /* allocate memory for alloc's context */
503     ctx -> alloc_algo_ctx = malloc (sizeof (str__ip_sff_alloc_algo_ctx));
504 
505     /* allocated? */
506     if (NULL == ctx -> alloc_algo_ctx)
507     {
508         fatal (MSG__IP_SFF__IP_SFF_INIT__NOT_ENOUGH_SYSTEM_MEMORY
509             , EXIT_CODE__IP_SFF__IP_SFF_INIT__NOT_ENOUGH_SYSTEM_MEMORY
510             , ctx);
511     }
512 
513     context -> idx = 0;
514 
515     set_treap_root (ptr); 
516     this = get_treap_root; 
517 
518     set_prev_size_this (this, 0);
519     set_this_size_this (this, (size / ALLOC_STEP) * ALLOC_STEP);
520     set_prev_in_use_this (this);
521     clear_this_in_use_this (this);
522     init_treap_node (this);
523     set_last_block (this);
524 
525     reset_total_alloc_timer;
526     reset_alloc_counter;
527     reset_total_free_timer;
528     reset_free_counter;
529     reset_total_sbrk_timer;
530     reset_sbrk_counter;
531 
532     /*
533     t_reset_timer (&(context -> TIMER));
534     */
535 }
\end{verbatim}
\end{Code}


\hypertarget{ip__sff_8h_d50bc16c203c5ce9532bbd514c9b3a2c}{
\index{ip\_\-sff.h@{ip\_\-sff.h}!ip\_\-sff\_\-drop@{ip\_\-sff\_\-drop}}
\index{ip\_\-sff\_\-drop@{ip\_\-sff\_\-drop}!ip_sff.h@{ip\_\-sff.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void ip\_\-sff\_\-drop ({\bf str\_\-\_\-ctx} $\ast$ {\em ctx})}}
\label{ip__sff_8h_d50bc16c203c5ce9532bbd514c9b3a2c}


Drops the memory. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em ctx}]Simulator's context.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Nothing.\end{Desc}
\begin{Desc}
\item[Author:]Ivan Popovski \href{mailto:ivan.popovski@srce.hr}{\tt ivan.popovski@srce.hr} \end{Desc}
\begin{Desc}
\item[Date:]2009-02-31 \end{Desc}


Definition at line 548 of file ip\_\-sff.c.

\begin{Code}\begin{verbatim}550 {
551     /* allocated? */
552     if (NULL != ctx -> alloc_algo_ctx)
553     {
554         free (ctx -> alloc_algo_ctx);
555     }
556 }
\end{verbatim}
\end{Code}


\hypertarget{ip__sff_8h_264eaa8e59d469a3eec30187b2cec04f}{
\index{ip\_\-sff.h@{ip\_\-sff.h}!ip\_\-sff\_\-sbrk@{ip\_\-sff\_\-sbrk}}
\index{ip\_\-sff\_\-sbrk@{ip\_\-sff\_\-sbrk}!ip_sff.h@{ip\_\-sff.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void ip\_\-sff\_\-sbrk ({\bf str\_\-\_\-ctx} $\ast$ {\em ctx})}}
\label{ip__sff_8h_264eaa8e59d469a3eec30187b2cec04f}


Sbrk adjustments. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em ctx}]Simulator's context.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Nothing.\end{Desc}
\begin{Desc}
\item[Author:]Ivan Popovski \href{mailto:ivan.popovski@srce.hr}{\tt ivan.popovski@srce.hr} \end{Desc}
\begin{Desc}
\item[Date:]2009-02-02 2009-03-15 2009-04-28 \end{Desc}


Definition at line 825 of file ip\_\-sff.c.

References add\_\-to\_\-total\_\-sbrk\_\-timer, ALLOC\_\-STEP, cur\_\-mem\_\-size, get\_\-last\_\-block, get\_\-this\_\-in\_\-use\_\-this, get\_\-this\_\-size\_\-this, get\_\-treap\_\-root, inc\_\-idx, inc\_\-sbrk\_\-counter, init\_\-treap\_\-node, str\_\-\_\-ip\_\-sff\_\-alloc\_\-algo\_\-ctx::last, left\_\-child, mem\_\-at\_\-offset\_\-to\_\-chunk, PREV\_\-IN\_\-USE, right\_\-child, str\_\-\_\-ip\_\-sff\_\-alloc\_\-algo\_\-ctx::root, set\_\-last\_\-block, set\_\-this\_\-size\_\-this, set\_\-treap\_\-root, sys\_\-mem\_\-block, t\_\-start\_\-timer(), t\_\-stop\_\-timer(), THIS\_\-IN\_\-USE, and treap\_\-parent.

Referenced by i\_\-sbrk().

\begin{Code}\begin{verbatim}827 {
828     str__timer      timer;
829     str__treap_node *root = get_treap_root;
830     str__treap_node *last = get_last_block;
831     str__treap_node *insert = last;
832     str__treap_node *node;
833 
834     size_t  root_size = root ? get_this_size_this (root) : 0;
835     size_t  last_size = get_this_size_this (last);
836     size_t  size = (sys_mem_block + cur_mem_size) - ((byte *) last);
837 
838     inc_idx;
839 
840     /* let's time this stuff */
841     t_start_timer (&timer); 
842 
843     if (get_this_in_use_this(last) == THIS_IN_USE)
844     {
845         size = ((size + last_size) / ALLOC_STEP) * ALLOC_STEP;
846         insert = mem_at_offset_to_chunk (last, last_size);
847         init_treap_node (insert); 
848         set_this_size_this (insert, size | (PREV_IN_USE & ~THIS_IN_USE)); 
849         set_last_block (insert);
850 
851         if (size >= root_size)
852         {
853             if(root)
854             {
855                 treap_parent (root) = insert;
856                 left_child (insert) = root;
857             }
858 
859             set_treap_root (insert);
860 
861             t_stop_timer (&timer, ctx); 
862             add_to_total_sbrk_timer (&timer); 
863             inc_sbrk_counter;
864             return;
865         }
866 
867         bin_tree_insert (root, insert);
868 
869     }
870     /* last block free */
871     else
872     {
873         size = (size / ALLOC_STEP) * ALLOC_STEP;
874         set_this_size_this (insert, size | (PREV_IN_USE & ~THIS_IN_USE)); 
875 
876         if (insert == root)
877         {
878             t_stop_timer (&timer, ctx);
879             add_to_total_sbrk_timer (&timer);
880             inc_sbrk_counter;
881             return;
882         }
883 
884     }
885     
886     /* Promote */
887     node = insert -> parent;
888 
889     while (node && (get_this_size_this (insert) > get_this_size_this (node)))
890     {
891         if(left_child (node) == insert)
892         {
893             rot_right (node);
894         }
895         else if(right_child (node) == insert)
896         {
897             rot_left (node);
898         }
899 
900         node = treap_parent (insert);
901 
902     }
903 
904     /* stop timing */
905     t_stop_timer (&timer, ctx);
906     add_to_total_sbrk_timer (&timer);
907     inc_sbrk_counter;
908 
909 }
\end{verbatim}
\end{Code}


\hypertarget{ip__sff_8h_f579e283cbd85501b5aa1d160cfed07e}{
\index{ip\_\-sff.h@{ip\_\-sff.h}!ip\_\-sff\_\-alloc@{ip\_\-sff\_\-alloc}}
\index{ip\_\-sff\_\-alloc@{ip\_\-sff\_\-alloc}!ip_sff.h@{ip\_\-sff.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ ip\_\-sff\_\-alloc (size\_\-t {\em size}, \/  {\bf str\_\-\_\-ctx} $\ast$ {\em ctx})}}
\label{ip__sff_8h_f579e283cbd85501b5aa1d160cfed07e}


Allocates memory block. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em size}]Size of memory block. \item[\mbox{$\leftarrow$} {\em ctx}]Simulator's context.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]void $\ast$.\end{Desc}
\begin{Desc}
\item[Author:]Ivan Popovski \href{mailto:ivan.popovski@srce.hr}{\tt ivan.popovski@srce.hr} \end{Desc}
\begin{Desc}
\item[Date:]2009-02-11 \end{Desc}


Split, take from end and push down rest

Demote 

Definition at line 923 of file ip\_\-sff.c.

References add\_\-to\_\-total\_\-alloc\_\-timer, context, get\_\-last\_\-block, get\_\-this\_\-size\_\-this, get\_\-treap\_\-child\_\-size, get\_\-treap\_\-root, inc\_\-alloc\_\-counter, inc\_\-idx, str\_\-\_\-ip\_\-sff\_\-alloc\_\-algo\_\-ctx::last, left\_\-child, mem\_\-at\_\-offset\_\-to\_\-chunk, PREV\_\-IN\_\-USE, right\_\-child, str\_\-\_\-ip\_\-sff\_\-alloc\_\-algo\_\-ctx::root, round\_\-size\_\-to\_\-alloc\_\-step, set\_\-last\_\-block, set\_\-prev\_\-in\_\-use\_\-next, set\_\-prev\_\-size\_\-next, set\_\-prev\_\-size\_\-this, set\_\-this\_\-in\_\-use\_\-this, set\_\-this\_\-size\_\-this, set\_\-treap\_\-root, size\_\-of\_\-min\_\-free\_\-chunk, size\_\-of\_\-used\_\-chunk\_\-head, t\_\-start\_\-timer(), t\_\-stop\_\-timer(), THIS\_\-IN\_\-USE, treap\_\-parent, and used\_\-chunk\_\-to\_\-mem.

Referenced by i\_\-alloc().

\begin{Code}\begin{verbatim}926 {
927     str__treap_node *this = get_treap_root;
928     str__treap_node *root = get_treap_root;
929     str__treap_node *last = get_last_block;
930     str__treap_node *chunk;
931     str__timer  timer;
932     size_t      res, this_size;
933 
934     inc_idx;
935 
936     /* let's time this stuff */
937     t_start_timer (&timer);
938 
939     /* add size of header to the requested size */
940     size += size_of_used_chunk_head;
941 
942     /* minimal memory chunk must be large enough to contain the structure
943      * of the free chunk plus MIN_USABLE_BYTES_IN_FREE_CHUNKS bytes
944      */
945     if (size < size_of_min_free_chunk)
946         size = size_of_min_free_chunk; 
947 
948     /* round size to the nearest greater allocation step */
949     size = round_size_to_alloc_step (size);
950 
951     /* start from root of tree */
952     if (!root)
953     {
954         inc_alloc_counter;
955         return (NULL);
956     }
957 
958     /* Find free block */
959     while (get_this_size_this (this) >= size)
960     {
961         size_t left, right;
962 
963         left = get_treap_child_size (this, 0);
964         right = get_treap_child_size (this, 1);
965 
966         if (left >= size && right >= size)
967         {
968             this = this -> child [context->idx];
969         }
970         else if (left >= size)
971         {
972             this = left_child (this); 
973         }
974         else if (right >= size)
975         {
976             this = right_child (this);
977         }
978         else
979             break;
980     }
981 
982     this_size = get_this_size_this (this);
983 
984     if (this_size >= size)
985     {
986 
987         res = this_size - size;
988 
992         if (res > size_of_min_free_chunk)
993         { 
994             chunk = mem_at_offset_to_chunk (this, res); 
995             
996             set_this_size_this (this, res | (PREV_IN_USE & ~THIS_IN_USE)); 
997             set_this_size_this (chunk, size | (THIS_IN_USE & ~PREV_IN_USE));
998             set_prev_size_this (chunk, res);
999 
1000             if (this != last)
1001             {
1002                 set_prev_size_next (chunk, 0); 
1003                 set_prev_in_use_next (chunk);
1004             }   
1005             else
1006                 set_last_block (chunk);
1007 
1008         }
1009 
1010         /* 
1011          * Size of free block is same as requested size.
1012          * After demote we need to delete whole chunk from tree 
1013          */
1014         else if (res <= size_of_min_free_chunk)
1015         {
1016             size = size_of_min_free_chunk;
1017             chunk = this;
1018     
1019             /* Trivial case */
1020             if
1021             (
1022                 (this == root)
1023                 &&
1024                 (left_child (this) == NULL)
1025                 &&
1026                 (right_child (this) == NULL)
1027             )
1028             {
1029                 set_treap_root (NULL); 
1030                 goto trivial;
1031             }
1032 
1033             /* Or push down the tree */ 
1034             while (child_not_empty (this,0) || child_not_empty (this,1))
1035             {
1036                 size_t left, right;
1037 
1038                 left = get_treap_child_size (this, 0);
1039                 right = get_treap_child_size (this, 1);
1040                 
1041                 if (right >= left)
1042                 {
1043                     rot_left (this);
1044                 }
1045                 else if (left > right)
1046                 {
1047                     rot_right (this);
1048                 }
1049 
1050             }
1051 
1052             /* Delete node from tree */
1053             if (treap_parent (this))
1054             {
1055                 if (this == left_child (treap_parent (this)))
1056                 {
1057                     left_child (treap_parent (this)) = NULL;
1058                 }
1059                 else if (this == right_child (treap_parent (this)))
1060                 {
1061                     right_child (treap_parent (this)) = NULL;
1062                 }
1063                     }
1064 
1065 trivial:
1066 
1067             set_this_in_use_this (this); 
1068 
1069             if (this != last) 
1070             {
1071                 set_prev_size_next (this, 0);
1072                 set_prev_in_use_next (this); 
1073             }
1074 
1075             t_stop_timer (&timer, ctx);
1076             add_to_total_alloc_timer (&timer);
1077             inc_alloc_counter;
1078             return (used_chunk_to_mem (this)); 
1079 
1080         }
1081 
1082     }
1083 
1084     else 
1085     {       
1086         inc_alloc_counter;
1087         return (NULL);
1088     }
1089 
1091     while (child_not_empty (this, 0) || child_not_empty (this, 1))
1092     {
1093         size_t left, right;
1094 
1095         left=get_treap_child_size (this, 0);
1096         right=get_treap_child_size (this, 1);
1097 
1098         if (right >= left)
1099         {
1100             if (right >= get_this_size_this (this))
1101             {
1102                 rot_left (this);
1103             }
1104             else
1105                 break;
1106         }
1107         else if (right < left)
1108         {
1109             if (left >= get_this_size_this (this))
1110             {
1111                 rot_right (this);
1112             }
1113             else
1114                 break;
1115         }
1116         
1117     }
1118 
1119     /* stop timing */
1120     t_stop_timer (&timer, ctx);
1121     add_to_total_alloc_timer (&timer);
1122     inc_alloc_counter;
1123     return (used_chunk_to_mem (chunk)); 
1124 }
\end{verbatim}
\end{Code}


\hypertarget{ip__sff_8h_64e89fd27bfbca132314dac762b45589}{
\index{ip\_\-sff.h@{ip\_\-sff.h}!ip\_\-sff\_\-free@{ip\_\-sff\_\-free}}
\index{ip\_\-sff\_\-free@{ip\_\-sff\_\-free}!ip_sff.h@{ip\_\-sff.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void ip\_\-sff\_\-free (void $\ast$ {\em ptr}, \/  {\bf str\_\-\_\-ctx} $\ast$ {\em ctx})}}
\label{ip__sff_8h_64e89fd27bfbca132314dac762b45589}


Frees given memory block. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em ptr}]Pointer to memory block. \item[\mbox{$\leftarrow$} {\em ctx}]Simulator's context.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Nothing.\end{Desc}
\begin{Desc}
\item[Author:]Ivan Popovski \href{mailto:ivan.popovski@srce.hr}{\tt ivan.popovski@srce.hr} \end{Desc}
\begin{Desc}
\item[Date:]2009-04-20 \end{Desc}


Definition at line 1138 of file ip\_\-sff.c.

References add\_\-to\_\-total\_\-free\_\-timer, clear\_\-prev\_\-in\_\-use\_\-next, clear\_\-prev\_\-size\_\-this, clear\_\-this\_\-in\_\-use\_\-this, get\_\-last\_\-block, get\_\-prev\_\-in\_\-use\_\-this, get\_\-prev\_\-size\_\-this, get\_\-this\_\-in\_\-use\_\-next, get\_\-this\_\-size\_\-this, get\_\-treap\_\-child\_\-size, get\_\-treap\_\-root, inc\_\-free\_\-counter, inc\_\-idx, init\_\-treap\_\-node, str\_\-\_\-ip\_\-sff\_\-alloc\_\-algo\_\-ctx::last, left\_\-child, mem\_\-at\_\-offset\_\-to\_\-chunk, mem\_\-to\_\-used\_\-chunk, PREV\_\-IN\_\-USE, right\_\-child, str\_\-\_\-ip\_\-sff\_\-alloc\_\-algo\_\-ctx::root, set\_\-last\_\-block, set\_\-prev\_\-size\_\-next, set\_\-this\_\-size\_\-this, set\_\-treap\_\-root, t\_\-start\_\-timer(), t\_\-stop\_\-timer(), THIS\_\-IN\_\-USE, and treap\_\-parent.

Referenced by i\_\-free().

\begin{Code}\begin{verbatim}1141 {
1142     str__treap_node *prev;
1143     str__treap_node *next;
1144     str__treap_node *this;
1145     str__treap_node *node;
1146     str__treap_node *last = get_last_block;
1147     str__treap_node *root = get_treap_root;
1148     str__treap_node *promote = NULL;
1149     
1150     #ifdef DEBUG
1151     str__treap_node     *this_org;
1152     #endif /* #ifdef DEBUG */
1153     
1154     size_t                  size;
1155     str__timer              timer;
1156     /*
1157     str__timer              TIMER;
1158     */
1159 
1160     inc_idx;
1161 
1162     /* let's time this stuff */
1163     t_start_timer (&timer);
1164 
1165     /* pointers */
1166     this = mem_to_used_chunk (ptr); 
1167     init_treap_node (this); 
1168     next = prev = this;
1169 
1170     #ifdef DEBUG
1171         this_org = this;
1172     #endif /* #ifdef DEBUG */
1173 
1174     size = get_this_size_this (this);
1175 
1176     /* No root? Make this block root */
1177     if (!root)
1178     {
1179         clear_this_in_use_this (this);
1180 
1181         if (this != last)
1182         {
1183             clear_prev_in_use_next (this);
1184             set_prev_size_next (this, get_this_size_this (this));
1185         }
1186 
1187         set_treap_root (this);
1188 
1189         t_stop_timer (&timer, ctx);
1190         add_to_total_free_timer (&timer);
1191         inc_free_counter;
1192         return;
1193     }
1194 
1195     /* No free neighbours, insert and promote */
1196     if
1197     (
1198         (PREV_IN_USE == get_prev_in_use_this (this))
1199         &&
1200         (
1201             (this == last)
1202             ||
1203             (THIS_IN_USE == get_this_in_use_next (this))
1204         )
1205     )
1206     {
1207         clear_this_in_use_this (this);
1208 
1209         if (this != last)
1210         {
1211             set_prev_size_next (this, get_this_size_this (this));
1212             clear_prev_in_use_next (this); 
1213         }
1214 
1215         bin_tree_insert (root, this);
1216         node = treap_parent (this);
1217         
1218         /* Promote */
1219         while (node && (get_this_size_this(this) > get_this_size_this (node)))
1220         {
1221 
1222             if (left_child (node) == this)
1223             {
1224                 rot_right (node);
1225             }
1226             else if (right_child (node) == this)
1227             {
1228                 rot_left (node);
1229             }
1230 
1231             node = treap_parent (this);
1232 
1233         }
1234         
1235         t_stop_timer (&timer, ctx);
1236         add_to_total_free_timer (&timer);
1237         inc_free_counter;
1238         return;
1239     
1240     } 
1241 
1242     /* Previous neighbour free? */
1243     if (PREV_IN_USE != get_prev_in_use_this (this))
1244     { 
1245                 prev = mem_at_offset_to_chunk (this, -get_prev_size_this (this));
1246     } 
1247 
1248     /* Next free? */
1249     if
1250     (
1251         (this != last)
1252         &&
1253         (THIS_IN_USE != get_this_in_use_next (this))
1254     )
1255     { 
1256         next = mem_at_offset_to_chunk (this, get_this_size_this (this));
1257     }
1258 
1259     /* Previous block is free, merge and promote */
1260     if
1261     (
1262         (prev != this)
1263         &&
1264         (next == this)
1265     )
1266     {
1267         size += get_this_size_this (prev);
1268         set_this_size_this (prev, size | (PREV_IN_USE & ~THIS_IN_USE)); 
1269 
1270         if (this != last)
1271         {
1272             set_prev_size_next (prev, size);
1273             clear_prev_in_use_next (prev); 
1274         }
1275         else
1276             set_last_block (prev);
1277 
1278         if (prev == root)
1279         {
1280             t_stop_timer (&timer, ctx);
1281             add_to_total_free_timer (&timer);
1282             inc_free_counter;
1283             return;
1284         }
1285 
1286         /* Mark for promotion */
1287         promote = prev;
1288 
1289     } 
1290 
1291     /* Next is free, merge them and promote */
1292     else if
1293     (
1294         (next != this)
1295         &&
1296         (prev == this)
1297     )
1298     {
1299         size += get_this_size_this (next);
1300         set_this_size_this (this, size | (PREV_IN_USE & ~THIS_IN_USE)); 
1301 
1302         if (treap_parent(next))
1303         {
1304             treap_parent (this) = treap_parent (next);
1305 
1306             if(left_child (treap_parent (next)) == next)
1307             {
1308                 left_child (treap_parent (next)) = this;
1309             }
1310             else if(right_child (treap_parent (next)) == next)
1311             {
1312                 right_child (treap_parent (next)) = this;
1313             }
1314 
1315         }
1316 
1317         if (left_child (next))
1318             treap_parent (left_child (next)) = this;
1319 
1320         if (right_child (next))
1321             treap_parent (right_child (next)) = this;
1322 
1323         left_child (this) = left_child (next);
1324         right_child (this) = right_child (next);
1325 
1326         if (next != last)
1327         {
1328             set_prev_size_next (this, size);
1329             clear_prev_in_use_next (this); 
1330         }
1331         else
1332             set_last_block (this);
1333 
1334         if (next == root)
1335         {
1336             set_treap_root (this);
1337 
1338             t_stop_timer (&timer, ctx);
1339             add_to_total_free_timer (&timer);
1340             inc_free_counter;
1341             return;
1342         }
1343 
1344         /* Mark for promotion */
1345         promote = this;
1346         
1347     }
1348 
1349     /* Both neighbours are free */
1350     else if
1351     (
1352         (next != this)
1353         &&
1354         (prev != this)
1355     )
1356     {
1357         size += get_this_size_this (prev) + get_this_size_this (next);
1358 
1359         /* We should delete next */
1360         while (child_not_empty (next, 0) || child_not_empty (next, 1))
1361         {
1362             size_t left, right;
1363 
1364             left = get_treap_child_size (next, 0);
1365             right = get_treap_child_size (next, 1);
1366 
1367             if (left >= right)
1368             {
1369                 rot_right (next);
1370             }
1371             else if (right > left)
1372             {
1373                 rot_left (next);
1374             }
1375 
1376         }
1377 
1378         /* Delete leaf */
1379         if (treap_parent (next))
1380         {
1381             if (left_child (treap_parent (next)) == next)
1382             {
1383                 left_child (treap_parent (next)) = NULL;
1384             }
1385             else if (right_child (treap_parent (next)) == next)
1386             {
1387                 right_child (treap_parent (next)) = NULL;
1388             }
1389         }
1390 
1391         set_this_size_this (prev, size | (PREV_IN_USE & ~THIS_IN_USE)); 
1392 
1393         if (next != last)
1394         {
1395             clear_prev_in_use_next (prev); 
1396             set_prev_size_next (prev, size); 
1397         }
1398         else
1399             set_last_block (prev);
1400 
1401         /* Mark for promotion */
1402         promote = prev;
1403 
1404     }
1405     
1406     node = treap_parent (promote);
1407     
1408     while (node && (get_this_size_this (promote) > get_this_size_this (node)))
1409     {
1410 
1411         if (left_child (node) == promote)
1412         {
1413             rot_right (node);
1414         }
1415         else if (right_child (node) == promote)
1416         {
1417             rot_left (node);
1418         }
1419 
1420         node = treap_parent (promote);
1421 
1422     }
1423 
1424     #ifdef DEBUG
1425         clear_prev_size_this (this);
1426     #endif /* #ifdef DEBUG */
1427 
1428     /* stop timing */
1429     t_stop_timer (&timer, ctx);
1430     add_to_total_free_timer (&timer);
1431     inc_free_counter;
1432 
1433 }
\end{verbatim}
\end{Code}


\hypertarget{ip__sff_8h_e25f1262966a1dc5adb1fcf66118ea7d}{
\index{ip\_\-sff.h@{ip\_\-sff.h}!ip\_\-sff\_\-get\_\-unused\_\-bits\_\-num@{ip\_\-sff\_\-get\_\-unused\_\-bits\_\-num}}
\index{ip\_\-sff\_\-get\_\-unused\_\-bits\_\-num@{ip\_\-sff\_\-get\_\-unused\_\-bits\_\-num}!ip_sff.h@{ip\_\-sff.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}unsigned int ip\_\-sff\_\-get\_\-unused\_\-bits\_\-num (void)}}
\label{ip__sff_8h_e25f1262966a1dc5adb1fcf66118ea7d}


Taken from di\_\-ff and mg\_\-dl. 

This function returns the number of unused bits in the algorithm headers.

\begin{Desc}
\item[Returns:]Nothing.\end{Desc}
\begin{Desc}
\item[Author:]Ivan Popovski \href{mailto:ivan.popovski@srce.hr}{\tt ivan.popovski@srce.hr} \end{Desc}
\begin{Desc}
\item[Date:]2009-04-17 \end{Desc}


Definition at line 1448 of file ip\_\-sff.c.

References NUMBER\_\-OF\_\-UNUSED\_\-BITS\_\-IN\_\-USED\_\-BLOCK\_\-HEADER.

Referenced by i\_\-get\_\-unused\_\-bits\_\-num().

\begin{Code}\begin{verbatim}1449 {
1450     return (NUMBER_OF_UNUSED_BITS_IN_USED_BLOCK_HEADER);
1451 }
\end{verbatim}
\end{Code}


\hypertarget{ip__sff_8h_94be05400c624d8e122ae47f3e55a2e3}{
\index{ip\_\-sff.h@{ip\_\-sff.h}!ip\_\-sff\_\-get\_\-unused\_\-bits@{ip\_\-sff\_\-get\_\-unused\_\-bits}}
\index{ip\_\-sff\_\-get\_\-unused\_\-bits@{ip\_\-sff\_\-get\_\-unused\_\-bits}!ip_sff.h@{ip\_\-sff.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}unsigned int ip\_\-sff\_\-get\_\-unused\_\-bits (void $\ast$ {\em ptr}, \/  {\bf str\_\-\_\-ctx} $\ast$ {\em ctx})}}
\label{ip__sff_8h_94be05400c624d8e122ae47f3e55a2e3}


This function returns unused bits for given $\ast$USED$\ast$ memory block. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em ptr}]Pointer to memory block.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]unsigned int.\end{Desc}
\begin{Desc}
\item[Author:]Ivan Popovski \href{mailto:ivan.popovski@srce.hr}{\tt ivan.popovski@srce.hr} \end{Desc}
\begin{Desc}
\item[Date:]2009-04-17 \end{Desc}


Definition at line 1464 of file ip\_\-sff.c.

References get\_\-this\_\-size\_\-unused\_\-bits, inc\_\-idx, and mem\_\-to\_\-used\_\-chunk.

Referenced by i\_\-get\_\-unused\_\-bits().

\begin{Code}\begin{verbatim}1467 {
1468     str__treap_node *this = mem_to_used_chunk (ptr);
1469     inc_idx;
1470 
1471     return (get_this_size_unused_bits (this));
1472 
1473 }
\end{verbatim}
\end{Code}


\hypertarget{ip__sff_8h_77f2eb6813ec2e09075474aa5e25131e}{
\index{ip\_\-sff.h@{ip\_\-sff.h}!ip\_\-sff\_\-set\_\-unused\_\-bits@{ip\_\-sff\_\-set\_\-unused\_\-bits}}
\index{ip\_\-sff\_\-set\_\-unused\_\-bits@{ip\_\-sff\_\-set\_\-unused\_\-bits}!ip_sff.h@{ip\_\-sff.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void ip\_\-sff\_\-set\_\-unused\_\-bits (unsigned int {\em bits}, \/  void $\ast$ {\em ptr})}}
\label{ip__sff_8h_77f2eb6813ec2e09075474aa5e25131e}


This function sets unused bits in given $\ast$USED$\ast$ memory block. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em bits}]Bits to be set. \item[\mbox{$\leftarrow$} {\em ptr}]Pointer to memory block.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Nothing.\end{Desc}
\begin{Desc}
\item[Author:]Ivan Popovski \href{mailto:ivan.popovski@srce.hr}{\tt ivan.popovski@srce.hr} \end{Desc}
\begin{Desc}
\item[Date:]2009-03-17 \end{Desc}


Definition at line 1487 of file ip\_\-sff.c.

References mem\_\-to\_\-used\_\-chunk, and set\_\-this\_\-size\_\-unused\_\-bits.

Referenced by i\_\-set\_\-unused\_\-bits().

\begin{Code}\begin{verbatim}1490 {
1491     str__treap_node *this = mem_to_used_chunk (ptr);
1492 
1493     set_this_size_unused_bits (this, bits);
1494 
1495 }
\end{verbatim}
\end{Code}


\hypertarget{ip__sff_8h_fe105ab88c73b8c2f27aba5f753868b5}{
\index{ip\_\-sff.h@{ip\_\-sff.h}!ip\_\-sff\_\-get\_\-first\_\-used\_\-block@{ip\_\-sff\_\-get\_\-first\_\-used\_\-block}}
\index{ip\_\-sff\_\-get\_\-first\_\-used\_\-block@{ip\_\-sff\_\-get\_\-first\_\-used\_\-block}!ip_sff.h@{ip\_\-sff.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ ip\_\-sff\_\-get\_\-first\_\-used\_\-block ({\bf str\_\-\_\-ctx} $\ast$ {\em ctx})}}
\label{ip__sff_8h_fe105ab88c73b8c2f27aba5f753868b5}


This function fetches first used block from simulator's memory. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em ctx}]Simulator context with command line params.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]void $\ast$.\end{Desc}
\begin{Desc}
\item[See also:]\hyperlink{structstr____ctx}{str\_\-\_\-ctx}\end{Desc}
\begin{Desc}
\item[Author:]Ivan Popovski \href{mailto:ivan.popovski@srce.hr}{\tt ivan.popovski@srce.hr} \end{Desc}
\begin{Desc}
\item[Date:]2009-03-06 \end{Desc}


Definition at line 1510 of file ip\_\-sff.c.

References get\_\-last\_\-block, get\_\-this\_\-in\_\-use\_\-this, get\_\-this\_\-size\_\-this, inc\_\-idx, mem\_\-at\_\-offset\_\-to\_\-chunk, THIS\_\-IN\_\-USE, and used\_\-chunk\_\-to\_\-mem.

Referenced by ip\_\-sff\_\-get\_\-num\_\-of\_\-used\_\-blocks(), and ip\_\-sff\_\-get\_\-size\_\-of\_\-used\_\-blocks().

\begin{Code}\begin{verbatim}1512 {
1513     /* if the first chunk is used */
1514     str__treap_node *chunk = (str__treap_node *) ctx -> sysmem_block; 
1515     inc_idx;
1516 
1517     if (THIS_IN_USE == get_this_in_use_this (chunk))
1518     {
1519         return (used_chunk_to_mem (chunk));
1520     }
1521 
1522     else if (chunk != get_last_block)
1523     {
1524         return (used_chunk_to_mem (mem_at_offset_to_chunk
1525                         (chunk, get_this_size_this (chunk))));
1526     }
1527 
1528     /* there are no used chunks */
1529     return (NULL);
1530 }
\end{verbatim}
\end{Code}


\hypertarget{ip__sff_8h_ebab029460751e6c9b1c036496bfa80c}{
\index{ip\_\-sff.h@{ip\_\-sff.h}!ip\_\-sff\_\-get\_\-next\_\-used\_\-block@{ip\_\-sff\_\-get\_\-next\_\-used\_\-block}}
\index{ip\_\-sff\_\-get\_\-next\_\-used\_\-block@{ip\_\-sff\_\-get\_\-next\_\-used\_\-block}!ip_sff.h@{ip\_\-sff.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ ip\_\-sff\_\-get\_\-next\_\-used\_\-block (void $\ast$ {\em ptr}, \/  {\bf str\_\-\_\-ctx} $\ast$ {\em ctx})}}
\label{ip__sff_8h_ebab029460751e6c9b1c036496bfa80c}


This function fetches used block following the given one. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em ptr}]Pointer to memory block.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]void $\ast$.\end{Desc}
\begin{Desc}
\item[See also:]\hyperlink{structstr____ctx}{str\_\-\_\-ctx}\end{Desc}
\begin{Desc}
\item[Author:]Ivan Popovski \href{mailto:ivan.popovski@srce.hr}{\tt ivan.popovski@srce.hr} \end{Desc}
\begin{Desc}
\item[Date:]2009-03-06 \end{Desc}


Definition at line 1545 of file ip\_\-sff.c.

References get\_\-last\_\-block, get\_\-this\_\-in\_\-use\_\-this, get\_\-this\_\-size\_\-this, inc\_\-idx, mem\_\-at\_\-offset\_\-to\_\-chunk, mem\_\-to\_\-used\_\-chunk, THIS\_\-IN\_\-USE, and used\_\-chunk\_\-to\_\-mem.

Referenced by ip\_\-sff\_\-get\_\-num\_\-of\_\-used\_\-blocks(), and ip\_\-sff\_\-get\_\-size\_\-of\_\-used\_\-blocks().

\begin{Code}\begin{verbatim}1548 {
1549 
1550     str__treap_node *this = mem_to_used_chunk (ptr); 
1551     str__treap_node *next;
1552     inc_idx;
1553 
1554     if(ptr == NULL)
1555         return NULL;
1556 
1557     this = mem_to_used_chunk (ptr);
1558 
1559     /* Last chunk? */
1560     if(this == get_last_block)
1561         return NULL;
1562     
1563     next = mem_at_offset_to_chunk (this, get_this_size_this (this));
1564 
1565     /* if the next chunk is free and if it's NOT the last one
1566      * jump over it and fetch the used chunk
1567      */
1568     if (THIS_IN_USE == get_this_in_use_this (next))
1569     {
1570         return (used_chunk_to_mem (next));
1571     }
1572 
1573     else if
1574     (
1575         (next != get_last_block)
1576         &&
1577         get_this_in_use_this (mem_at_offset_to_chunk
1578                     (next, get_this_size_this (next)))
1579     )
1580     {
1581         return (used_chunk_to_mem (mem_at_offset_to_chunk
1582                                         (next, get_this_size_this (next))));
1583     }
1584     
1585     return (NULL);
1586 }
\end{verbatim}
\end{Code}


\hypertarget{ip__sff_8h_f505f956cb6c8f38fff94af2fe225a6c}{
\index{ip\_\-sff.h@{ip\_\-sff.h}!ip\_\-sff\_\-get\_\-first\_\-free\_\-block@{ip\_\-sff\_\-get\_\-first\_\-free\_\-block}}
\index{ip\_\-sff\_\-get\_\-first\_\-free\_\-block@{ip\_\-sff\_\-get\_\-first\_\-free\_\-block}!ip_sff.h@{ip\_\-sff.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ ip\_\-sff\_\-get\_\-first\_\-free\_\-block ({\bf str\_\-\_\-ctx} $\ast$ {\em ctx})}}
\label{ip__sff_8h_f505f956cb6c8f38fff94af2fe225a6c}


This function fetches first free block from simulator's memory. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em ctx}]Simulator context with command line params.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]void $\ast$.\end{Desc}
\begin{Desc}
\item[See also:]\hyperlink{structstr____ctx}{str\_\-\_\-ctx}\end{Desc}
\begin{Desc}
\item[Author:]Ivan Popovski \href{mailto:ivan.popovski@srce.hr}{\tt ivan.popovski@srce.hr} \end{Desc}
\begin{Desc}
\item[Date:]2009-03-06 \end{Desc}


Definition at line 1601 of file ip\_\-sff.c.

References free\_\-chunk\_\-to\_\-mem, get\_\-treap\_\-root, inc\_\-idx, and left\_\-child.

Referenced by ip\_\-sff\_\-get\_\-num\_\-of\_\-free\_\-blocks(), and ip\_\-sff\_\-get\_\-size\_\-of\_\-free\_\-blocks().

\begin{Code}\begin{verbatim}1603 {
1604     
1605     str__treap_node *left = get_treap_root;
1606     inc_idx;
1607 
1608     if (left == NULL)
1609         return NULL;
1610 
1611     while (left_child (left)) 
1612         left = left_child (left);
1613 
1614     return free_chunk_to_mem (left);
1615 
1616 }
\end{verbatim}
\end{Code}


\hypertarget{ip__sff_8h_29626065cd5157bfed1b55b6e039b89a}{
\index{ip\_\-sff.h@{ip\_\-sff.h}!ip\_\-sff\_\-get\_\-next\_\-free\_\-block@{ip\_\-sff\_\-get\_\-next\_\-free\_\-block}}
\index{ip\_\-sff\_\-get\_\-next\_\-free\_\-block@{ip\_\-sff\_\-get\_\-next\_\-free\_\-block}!ip_sff.h@{ip\_\-sff.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ ip\_\-sff\_\-get\_\-next\_\-free\_\-block (void $\ast$ {\em ptr}, \/  {\bf str\_\-\_\-ctx} $\ast$ {\em ctx})}}
\label{ip__sff_8h_29626065cd5157bfed1b55b6e039b89a}


This function fetches free block following the given one. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em ptr}]Pointer to memory block.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]void $\ast$.\end{Desc}
\begin{Desc}
\item[See also:]\hyperlink{structstr____ctx}{str\_\-\_\-ctx}\end{Desc}
\begin{Desc}
\item[Author:]Ivan Popovski \href{mailto:ivan.popovski@srce.hr}{\tt ivan.popovski@srce.hr} \end{Desc}
\begin{Desc}
\item[Date:]2009-03-06 \end{Desc}


Definition at line 1632 of file ip\_\-sff.c.

References free\_\-chunk\_\-to\_\-mem, get\_\-last\_\-block, get\_\-this\_\-in\_\-use\_\-this, get\_\-this\_\-size\_\-this, inc\_\-idx, mem\_\-at\_\-offset\_\-to\_\-chunk, mem\_\-to\_\-free\_\-chunk, and THIS\_\-IN\_\-USE.

Referenced by ip\_\-sff\_\-get\_\-num\_\-of\_\-free\_\-blocks(), and ip\_\-sff\_\-get\_\-size\_\-of\_\-free\_\-blocks().

\begin{Code}\begin{verbatim}1635 {
1636     str__treap_node *this;
1637     str__treap_node *next;
1638     inc_idx;
1639 
1640     /* Last chunk? */
1641     if (ptr == NULL)
1642         return NULL;
1643 
1644     this = mem_to_free_chunk (ptr); 
1645 
1646     if (this == get_last_block)
1647         return NULL;
1648 
1649     for
1650     (
1651             next = mem_at_offset_to_chunk (this, get_this_size_this (this));
1652 
1653         (get_this_in_use_this (next))
1654         &&
1655         (next <= get_last_block);
1656 
1657         next = mem_at_offset_to_chunk (next, get_this_size_this (next))
1658     );
1659 
1660     if
1661     (
1662         (next <= get_last_block)
1663         &&
1664         (get_this_in_use_this (next) != THIS_IN_USE)
1665     )
1666     {
1667         return free_chunk_to_mem (next);
1668     }
1669 
1670     return (NULL);
1671 }
\end{verbatim}
\end{Code}


\hypertarget{ip__sff_8h_d6386e1614a555536874050e62736942}{
\index{ip\_\-sff.h@{ip\_\-sff.h}!ip\_\-sff\_\-get\_\-num\_\-of\_\-used\_\-blocks@{ip\_\-sff\_\-get\_\-num\_\-of\_\-used\_\-blocks}}
\index{ip\_\-sff\_\-get\_\-num\_\-of\_\-used\_\-blocks@{ip\_\-sff\_\-get\_\-num\_\-of\_\-used\_\-blocks}!ip_sff.h@{ip\_\-sff.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}unsigned int ip\_\-sff\_\-get\_\-num\_\-of\_\-used\_\-blocks ({\bf str\_\-\_\-ctx} $\ast$ {\em ctx})}}
\label{ip__sff_8h_d6386e1614a555536874050e62736942}


This function returns the number of used blocks. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em ctx}]Simulator context with command line params.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]unsigned int.\end{Desc}
\begin{Desc}
\item[See also:]\hyperlink{structstr____ctx}{str\_\-\_\-ctx}\end{Desc}
\begin{Desc}
\item[Author:]Ivan Popovski \href{mailto:ivan.popovski@srce.hr}{\tt ivan.popovski@srce.hr} \end{Desc}
\begin{Desc}
\item[Date:]2009-03-07 \end{Desc}


Definition at line 1686 of file ip\_\-sff.c.

References inc\_\-idx, ip\_\-sff\_\-get\_\-first\_\-used\_\-block(), and ip\_\-sff\_\-get\_\-next\_\-used\_\-block().

\begin{Code}\begin{verbatim}1688 {
1689     void        *block;
1690     unsigned int    i;
1691     inc_idx;
1692 
1693         for
1694         (
1695                 i = 0,
1696                 block = ip_sff_get_first_used_block (ctx);
1697 
1698                 block != NULL;
1699 
1700                 i ++,
1701                 block = ip_sff_get_next_used_block (block, ctx)
1702         );
1703 
1704     return (i);
1705 }
\end{verbatim}
\end{Code}


\hypertarget{ip__sff_8h_fd0d0514b4e3f8ac449aeb39c63a7a1c}{
\index{ip\_\-sff.h@{ip\_\-sff.h}!ip\_\-sff\_\-get\_\-size\_\-of\_\-used\_\-blocks@{ip\_\-sff\_\-get\_\-size\_\-of\_\-used\_\-blocks}}
\index{ip\_\-sff\_\-get\_\-size\_\-of\_\-used\_\-blocks@{ip\_\-sff\_\-get\_\-size\_\-of\_\-used\_\-blocks}!ip_sff.h@{ip\_\-sff.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}unsigned long int ip\_\-sff\_\-get\_\-size\_\-of\_\-used\_\-blocks ({\bf str\_\-\_\-ctx} $\ast$ {\em ctx})}}
\label{ip__sff_8h_fd0d0514b4e3f8ac449aeb39c63a7a1c}


This function returns the sum of sizes of used blocks. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em ctx}]Simulator context with command line params.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]unsigned int.\end{Desc}
\begin{Desc}
\item[See also:]\hyperlink{structstr____ctx}{str\_\-\_\-ctx}\end{Desc}
\begin{Desc}
\item[Author:]Ivan Popovski \href{mailto:ivan.popovski@srce.hr}{\tt ivan.popovski@srce.hr} \end{Desc}
\begin{Desc}
\item[Date:]2009-03-07 \end{Desc}


Definition at line 1720 of file ip\_\-sff.c.

References get\_\-this\_\-size\_\-this, inc\_\-idx, ip\_\-sff\_\-get\_\-first\_\-used\_\-block(), ip\_\-sff\_\-get\_\-next\_\-used\_\-block(), mem\_\-to\_\-used\_\-chunk, and size\_\-of\_\-used\_\-chunk\_\-head.

\begin{Code}\begin{verbatim}1722 {
1723     void        *block;
1724     unsigned long int   i;
1725     inc_idx;
1726 
1727     for
1728     (
1729         i = 0,
1730         block = ip_sff_get_first_used_block (ctx);
1731 
1732         block != NULL;
1733 
1734         i += get_this_size_this (((str__treap_node *) mem_to_used_chunk (block)))
1735                 - size_of_used_chunk_head,
1736         block = ip_sff_get_next_used_block (block, ctx)
1737     );
1738 
1739     return (i);
1740 }
\end{verbatim}
\end{Code}


\hypertarget{ip__sff_8h_5e41bf3c2fbafbfe0d4741d4b1ea0f40}{
\index{ip\_\-sff.h@{ip\_\-sff.h}!ip\_\-sff\_\-get\_\-num\_\-of\_\-free\_\-blocks@{ip\_\-sff\_\-get\_\-num\_\-of\_\-free\_\-blocks}}
\index{ip\_\-sff\_\-get\_\-num\_\-of\_\-free\_\-blocks@{ip\_\-sff\_\-get\_\-num\_\-of\_\-free\_\-blocks}!ip_sff.h@{ip\_\-sff.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}unsigned int ip\_\-sff\_\-get\_\-num\_\-of\_\-free\_\-blocks ({\bf str\_\-\_\-ctx} $\ast$ {\em ctx})}}
\label{ip__sff_8h_5e41bf3c2fbafbfe0d4741d4b1ea0f40}


This function returns the number of free blocks. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em ctx}]Simulator context with command line params.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]unsigned int.\end{Desc}
\begin{Desc}
\item[See also:]\hyperlink{structstr____ctx}{str\_\-\_\-ctx}\end{Desc}
\begin{Desc}
\item[Author:]Ivan Popovski \href{mailto:ivan.popovski@srce.hr}{\tt ivan.popovski@srce.hr} \end{Desc}
\begin{Desc}
\item[Date:]2009-03-07 \end{Desc}


Definition at line 1755 of file ip\_\-sff.c.

References inc\_\-idx, ip\_\-sff\_\-get\_\-first\_\-free\_\-block(), and ip\_\-sff\_\-get\_\-next\_\-free\_\-block().

\begin{Code}\begin{verbatim}1757 {
1758     void        *block;
1759     unsigned int    i;
1760     inc_idx;
1761 
1762         for
1763         (
1764                 i = 0,
1765                 block = ip_sff_get_first_free_block (ctx);
1766 
1767                 block != NULL;
1768 
1769                 i ++,
1770                 block = ip_sff_get_next_free_block (block, ctx)
1771         );
1772 
1773     return (i);
1774 }
\end{verbatim}
\end{Code}


\hypertarget{ip__sff_8h_bc2c104e16089879326f2675c8cce7a2}{
\index{ip\_\-sff.h@{ip\_\-sff.h}!ip\_\-sff\_\-get\_\-size\_\-of\_\-free\_\-blocks@{ip\_\-sff\_\-get\_\-size\_\-of\_\-free\_\-blocks}}
\index{ip\_\-sff\_\-get\_\-size\_\-of\_\-free\_\-blocks@{ip\_\-sff\_\-get\_\-size\_\-of\_\-free\_\-blocks}!ip_sff.h@{ip\_\-sff.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}unsigned long int ip\_\-sff\_\-get\_\-size\_\-of\_\-free\_\-blocks ({\bf str\_\-\_\-ctx} $\ast$ {\em ctx})}}
\label{ip__sff_8h_bc2c104e16089879326f2675c8cce7a2}


This function returns the sum of sizes of free blocks. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em ctx}]Simulator context with command line params.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]unsigned int.\end{Desc}
\begin{Desc}
\item[See also:]\hyperlink{structstr____ctx}{str\_\-\_\-ctx}\end{Desc}
\begin{Desc}
\item[Author:]Ivan Popovski \href{mailto:ivan.popovski@srce.hr}{\tt ivan.popovski@srce.hr} \end{Desc}
\begin{Desc}
\item[Date:]2009-03-07 \end{Desc}


Definition at line 1789 of file ip\_\-sff.c.

References get\_\-this\_\-size\_\-this, inc\_\-idx, ip\_\-sff\_\-get\_\-first\_\-free\_\-block(), ip\_\-sff\_\-get\_\-next\_\-free\_\-block(), and mem\_\-to\_\-free\_\-chunk.

\begin{Code}\begin{verbatim}1791 {
1792     void            *block; 
1793     unsigned long int   i;
1794     inc_idx;
1795 
1796     for
1797     (
1798         i = 0,
1799         block = ip_sff_get_first_free_block (ctx);
1800 
1801         block != NULL;
1802 
1803         i += get_this_size_this ((str__treap_node *) mem_to_free_chunk (block))
1804                     - sizeof (str__treap_node),
1805         block = ip_sff_get_next_free_block (block, ctx)
1806     );
1807 
1808     return (i);
1809 }
\end{verbatim}
\end{Code}


\hypertarget{ip__sff_8h_3db1c8837b7910521dfe489e76ec7430}{
\index{ip\_\-sff.h@{ip\_\-sff.h}!ip\_\-sff\_\-get\_\-first\_\-block@{ip\_\-sff\_\-get\_\-first\_\-block}}
\index{ip\_\-sff\_\-get\_\-first\_\-block@{ip\_\-sff\_\-get\_\-first\_\-block}!ip_sff.h@{ip\_\-sff.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ ip\_\-sff\_\-get\_\-first\_\-block ({\bf str\_\-\_\-ctx} $\ast$ {\em ctx})}}
\label{ip__sff_8h_3db1c8837b7910521dfe489e76ec7430}


This function fetches the first block from simulator's memory. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em ctx}]Simulator context.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]void $\ast$.\end{Desc}
\begin{Desc}
\item[See also:]\hyperlink{structstr____ctx}{str\_\-\_\-ctx}\end{Desc}
\begin{Desc}
\item[Author:]Ivan Popovski \href{mailto:ivan.popovski@srce.hr}{\tt ivan.popovski@srce.hr} \end{Desc}
\begin{Desc}
\item[Date:]2009-03-17 \end{Desc}


Definition at line 1824 of file ip\_\-sff.c.

References free\_\-chunk\_\-to\_\-mem, get\_\-this\_\-in\_\-use\_\-this, inc\_\-idx, THIS\_\-IN\_\-USE, and used\_\-chunk\_\-to\_\-mem.

Referenced by ip\_\-sff\_\-get\_\-prev\_\-block().

\begin{Code}\begin{verbatim}1826 {
1827     str__treap_node *this = (str__treap_node *) ctx -> sysmem_block;
1828     inc_idx;
1829 
1830     if (THIS_IN_USE == get_this_in_use_this (this))
1831     {
1832         return (used_chunk_to_mem (ctx -> sysmem_block));
1833     }
1834 
1835     /* if it's free */
1836     else
1837     {
1838         return (free_chunk_to_mem (ctx -> sysmem_block));
1839     }
1840 
1841     return (NULL);
1842 }
\end{verbatim}
\end{Code}


\hypertarget{ip__sff_8h_00458d11726d5feae14841def65ad387}{
\index{ip\_\-sff.h@{ip\_\-sff.h}!ip\_\-sff\_\-get\_\-next\_\-block@{ip\_\-sff\_\-get\_\-next\_\-block}}
\index{ip\_\-sff\_\-get\_\-next\_\-block@{ip\_\-sff\_\-get\_\-next\_\-block}!ip_sff.h@{ip\_\-sff.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ ip\_\-sff\_\-get\_\-next\_\-block (void $\ast$ {\em ptr}, \/  {\bf str\_\-\_\-ctx} $\ast$ {\em ctx})}}
\label{ip__sff_8h_00458d11726d5feae14841def65ad387}


This function fetches the block following the given one. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em ptr}]Pointer to memory block. \item[\mbox{$\leftarrow$} {\em ctx}]Simulator context.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]void $\ast$.\end{Desc}
\begin{Desc}
\item[See also:]\hyperlink{structstr____ctx}{str\_\-\_\-ctx}\end{Desc}
\begin{Desc}
\item[Author:]Dorian Ivancic \href{mailto:dorian@linux.hr}{\tt dorian@linux.hr} \end{Desc}
\begin{Desc}
\item[Date:]2005-09-17 \end{Desc}


Definition at line 1887 of file ip\_\-sff.c.

References free\_\-chunk\_\-to\_\-mem, get\_\-this\_\-in\_\-use\_\-next, get\_\-this\_\-size\_\-this, inc\_\-idx, ip\_\-sff\_\-get\_\-last\_\-block(), ip\_\-sff\_\-is\_\-block\_\-free(), mem\_\-at\_\-offset\_\-to\_\-chunk, mem\_\-to\_\-free\_\-chunk, mem\_\-to\_\-used\_\-chunk, THIS\_\-IN\_\-USE, and used\_\-chunk\_\-to\_\-mem.

\begin{Code}\begin{verbatim}1890 {
1891     inc_idx;
1892 
1893     /* is this the last block? */
1894     if (ptr == ip_sff_get_last_block (ctx))
1895     {
1896         return (NULL);
1897     }
1898 
1899     /* this is not the last one! */
1900     else
1901     {
1902         /* this block is free? */
1903         if (RET__IP_SFF_IS_BLOCK_FREE__FREE_BLOCK
1904                 == ip_sff_is_block_free (ptr, ctx))
1905         {
1906             /* used chunk always follows the free one */
1907             return (used_chunk_to_mem (mem_at_offset_to_chunk (
1908                         mem_to_free_chunk (ptr), get_this_size_this (
1909                             mem_to_free_chunk (ptr)))));
1910         }
1911 
1912         /* or used? */
1913         else
1914         {
1915             /* the next chunk is used */
1916             if (THIS_IN_USE == get_this_in_use_next (mem_to_used_chunk (ptr)))
1917             {
1918                 return (used_chunk_to_mem (mem_at_offset_to_chunk (
1919                             mem_to_used_chunk (ptr), get_this_size_this (
1920                                 mem_to_used_chunk (ptr)))));
1921             }
1922 
1923             /* the next chunk is free */
1924             else
1925             {
1926                 return (free_chunk_to_mem (mem_at_offset_to_chunk (
1927                             mem_to_used_chunk (ptr), get_this_size_this (
1928                                 mem_to_used_chunk (ptr)))));
1929             }
1930         }
1931     }
1932 
1933     return (NULL);
1934 }
\end{verbatim}
\end{Code}


\hypertarget{ip__sff_8h_ffccf3a9bea082acaab68a19f4c857ac}{
\index{ip\_\-sff.h@{ip\_\-sff.h}!ip\_\-sff\_\-get\_\-last\_\-block@{ip\_\-sff\_\-get\_\-last\_\-block}}
\index{ip\_\-sff\_\-get\_\-last\_\-block@{ip\_\-sff\_\-get\_\-last\_\-block}!ip_sff.h@{ip\_\-sff.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ ip\_\-sff\_\-get\_\-last\_\-block ({\bf str\_\-\_\-ctx} $\ast$ {\em ctx})}}
\label{ip__sff_8h_ffccf3a9bea082acaab68a19f4c857ac}


This function fetches the last block from simulator's memory. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em ctx}]Simulator context.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]void $\ast$.\end{Desc}
\begin{Desc}
\item[See also:]\hyperlink{structstr____ctx}{str\_\-\_\-ctx}\end{Desc}
\begin{Desc}
\item[Author:]Ivan Popovski \href{mailto:ivan.popovski@srce.hr}{\tt ivan.popovski@srce.hr} \end{Desc}
\begin{Desc}
\item[Date:]2009-03-17 \end{Desc}


Definition at line 1857 of file ip\_\-sff.c.

References free\_\-chunk\_\-to\_\-mem, get\_\-last\_\-block, get\_\-this\_\-in\_\-use\_\-this, inc\_\-idx, THIS\_\-IN\_\-USE, and used\_\-chunk\_\-to\_\-mem.

Referenced by ip\_\-sff\_\-get\_\-next\_\-block().

\begin{Code}\begin{verbatim}1859 {
1860     str__treap_node *this = get_last_block;
1861     inc_idx;
1862 
1863     if (THIS_IN_USE == get_this_in_use_this (this))
1864     {
1865         return (used_chunk_to_mem (this));
1866     }
1867     else
1868     {
1869         return (free_chunk_to_mem (this));
1870     }
1871 }
\end{verbatim}
\end{Code}


\hypertarget{ip__sff_8h_36a1e956083edbd4d29208cfcfdd96ed}{
\index{ip\_\-sff.h@{ip\_\-sff.h}!ip\_\-sff\_\-get\_\-prev\_\-block@{ip\_\-sff\_\-get\_\-prev\_\-block}}
\index{ip\_\-sff\_\-get\_\-prev\_\-block@{ip\_\-sff\_\-get\_\-prev\_\-block}!ip_sff.h@{ip\_\-sff.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ ip\_\-sff\_\-get\_\-prev\_\-block (void $\ast$ {\em ptr}, \/  {\bf str\_\-\_\-ctx} $\ast$ {\em ctx})}}
\label{ip__sff_8h_36a1e956083edbd4d29208cfcfdd96ed}


This function fetches the block preceding the given one. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em ptr}]Pointer to memory block. \item[\mbox{$\leftarrow$} {\em ctx}]Simulator context.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]void $\ast$.\end{Desc}
\begin{Desc}
\item[See also:]\hyperlink{structstr____ctx}{str\_\-\_\-ctx}\end{Desc}
\begin{Desc}
\item[Author:]Ivan Popovski \href{mailto:ivan.popovski@srce.hr}{\tt ivan.popovski@srce.hr} \end{Desc}
\begin{Desc}
\item[Date:]2009-03-17 \end{Desc}


Definition at line 1950 of file ip\_\-sff.c.

References inc\_\-idx, ip\_\-sff\_\-get\_\-block\_\-size(), and ip\_\-sff\_\-get\_\-first\_\-block().

\begin{Code}\begin{verbatim}1953 {
1954     inc_idx;
1955 
1956     /* is this the first block? */
1957     if (ptr == ip_sff_get_first_block (ctx))
1958     {
1959         return (NULL);
1960     }
1961 
1962     else
1963     {
1964         void *this;
1965 
1966         for
1967         (
1968             this = ip_sff_get_first_block (ctx);
1969             this + ip_sff_get_block_size (this, ctx) < ptr;
1970             this += ip_sff_get_block_size (this, ctx)
1971         );
1972 
1973         return this;
1974 
1975     }
1976 
1977 }
\end{verbatim}
\end{Code}


\hypertarget{ip__sff_8h_b4c15a7906d6a3a1df904874e3d0bb46}{
\index{ip\_\-sff.h@{ip\_\-sff.h}!ip\_\-sff\_\-get\_\-block\_\-size@{ip\_\-sff\_\-get\_\-block\_\-size}}
\index{ip\_\-sff\_\-get\_\-block\_\-size@{ip\_\-sff\_\-get\_\-block\_\-size}!ip_sff.h@{ip\_\-sff.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}size\_\-t ip\_\-sff\_\-get\_\-block\_\-size (void $\ast$ {\em ptr}, \/  {\bf str\_\-\_\-ctx} $\ast$ {\em ctx})}}
\label{ip__sff_8h_b4c15a7906d6a3a1df904874e3d0bb46}


This function returns the usable bytes in current block. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em ctx}]Simulator context. \item[\mbox{$\leftarrow$} {\em ptr}]Pointer to memory block.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Size of the block.\end{Desc}
\begin{Desc}
\item[See also:]\hyperlink{structstr____ctx}{str\_\-\_\-ctx}\end{Desc}
\begin{Desc}
\item[Author:]Ivan Popovski \href{mailto:ivan.popovski@srce.hr}{\tt ivan.popovski@srce.hr} \end{Desc}
\begin{Desc}
\item[Date:]2009-03-18 \end{Desc}


Definition at line 1993 of file ip\_\-sff.c.

References get\_\-this\_\-size\_\-this, inc\_\-idx, ip\_\-sff\_\-is\_\-block\_\-free(), mem\_\-to\_\-free\_\-chunk, mem\_\-to\_\-used\_\-chunk, and size\_\-of\_\-used\_\-chunk\_\-head.

Referenced by ip\_\-sff\_\-get\_\-prev\_\-block().

\begin{Code}\begin{verbatim}1996 {
1997     inc_idx;
1998 
1999     /* this block is free? */
2000     if (RET__IP_SFF_IS_BLOCK_FREE__FREE_BLOCK
2001             == ip_sff_is_block_free (ptr, ctx))
2002     {
2003         return (get_this_size_this (mem_to_free_chunk (ptr))
2004                     - sizeof (str__treap_node)); 
2005     }
2006 
2007     /* it's used! */
2008     else
2009     {
2010         return (get_this_size_this (mem_to_used_chunk (ptr))
2011                     - size_of_used_chunk_head);
2012     }
2013 
2014 }
\end{verbatim}
\end{Code}


\hypertarget{ip__sff_8h_6563e99560182df05523acc51da24332}{
\index{ip\_\-sff.h@{ip\_\-sff.h}!ip\_\-sff\_\-is\_\-block\_\-free@{ip\_\-sff\_\-is\_\-block\_\-free}}
\index{ip\_\-sff\_\-is\_\-block\_\-free@{ip\_\-sff\_\-is\_\-block\_\-free}!ip_sff.h@{ip\_\-sff.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}enum {\bf ret\_\-\_\-ip\_\-sff\_\-is\_\-block\_\-free} ip\_\-sff\_\-is\_\-block\_\-free (void $\ast$ {\em ptr}, \/  {\bf str\_\-\_\-ctx} $\ast$ {\em ctx})}}
\label{ip__sff_8h_6563e99560182df05523acc51da24332}


This function returns the status of the block - free or used. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em ctx}]Simulator context. \item[\mbox{$\leftarrow$} {\em ptr}]Pointer to memory block.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]ret\_\-\_\-ip\_\-sff\_\-is\_\-free.\end{Desc}
\begin{Desc}
\item[See also:]\hyperlink{structstr____ctx}{str\_\-\_\-ctx}\end{Desc}
\begin{Desc}
\item[Author:]Ivan Popovski \href{mailto:ivan.popovski@srce.hr}{\tt ivan.popovski@srce.hr} \end{Desc}
\begin{Desc}
\item[Date:]2009-03-10 \end{Desc}


Definition at line 2030 of file ip\_\-sff.c.

References get\_\-last\_\-block, get\_\-this\_\-in\_\-use\_\-this, get\_\-this\_\-size\_\-this, inc\_\-idx, mem\_\-at\_\-offset\_\-to\_\-chunk, and size\_\-of\_\-used\_\-chunk\_\-head.

Referenced by ip\_\-sff\_\-get\_\-block\_\-size(), ip\_\-sff\_\-get\_\-next\_\-block(), and ip\_\-sff\_\-is\_\-block\_\-used().

\begin{Code}\begin{verbatim}2033 {
2034     void    *block;
2035     str__treap_node *this = (str__treap_node *) ctx -> sysmem_block;
2036 
2037     inc_idx;
2038 
2039     if (get_this_in_use_this (this))
2040         block = (void *) ((byte *) this 
2041                     + size_of_used_chunk_head);
2042     else
2043         block = (void *) ((byte *) this 
2044                     + sizeof (str__treap_node));
2045 
2046     while 
2047     (
2048         (this <= get_last_block)
2049         &&
2050         (block != ptr)
2051     )
2052     {
2053 
2054         this = mem_at_offset_to_chunk (
2055                     this, get_this_size_this (this));
2056 
2057         if (get_this_in_use_this (this))
2058             block = (void *) ((byte *) this 
2059                         + size_of_used_chunk_head);
2060         else
2061             block = (void *) ((byte *) this 
2062                         + sizeof (str__treap_node));
2063 
2064     }
2065 
2066         if (!get_this_in_use_this (this))
2067                 return (RET__IP_SFF_IS_BLOCK_FREE__FREE_BLOCK);
2068         else
2069                 return (RET__IP_SFF_IS_BLOCK_FREE__USED_BLOCK);
2070 
2071 }
\end{verbatim}
\end{Code}


\hypertarget{ip__sff_8h_dc4c639cc9925d1e24c1775f939510d9}{
\index{ip\_\-sff.h@{ip\_\-sff.h}!ip\_\-sff\_\-is\_\-block\_\-used@{ip\_\-sff\_\-is\_\-block\_\-used}}
\index{ip\_\-sff\_\-is\_\-block\_\-used@{ip\_\-sff\_\-is\_\-block\_\-used}!ip_sff.h@{ip\_\-sff.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}enum {\bf ret\_\-\_\-ip\_\-sff\_\-is\_\-block\_\-used} ip\_\-sff\_\-is\_\-block\_\-used (void $\ast$ {\em ptr}, \/  {\bf str\_\-\_\-ctx} $\ast$ {\em ctx})}}
\label{ip__sff_8h_dc4c639cc9925d1e24c1775f939510d9}


This function returns the status of the block - free or used. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em ctx}]Simulator context. \item[\mbox{$\leftarrow$} {\em ptr}]Pointer to memory block.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]ret\_\-\_\-ip\_\-sff\_\-is\_\-used.\end{Desc}
\begin{Desc}
\item[See also:]\hyperlink{structstr____ctx}{str\_\-\_\-ctx}\end{Desc}
\begin{Desc}
\item[Author:]Ivan Popovski \href{mailto:ivan.popovski@srce.hr}{\tt ivan.popovski@srce.hr} \end{Desc}
\begin{Desc}
\item[Date:]2009-03-10 \end{Desc}


Definition at line 2087 of file ip\_\-sff.c.

References inc\_\-idx, and ip\_\-sff\_\-is\_\-block\_\-free().

\begin{Code}\begin{verbatim}2090 {
2091     inc_idx;
2092 
2093     if (RET__IP_SFF_IS_BLOCK_FREE__FREE_BLOCK
2094             != ip_sff_is_block_free (ptr, ctx))
2095     {
2096         return (RET__IP_SFF_IS_BLOCK_USED__USED_BLOCK);
2097     }
2098 
2099     else
2100     {
2101         return (RET__IP_SFF_IS_BLOCK_USED__FREE_BLOCK);
2102     }
2103 }
\end{verbatim}
\end{Code}


\hypertarget{ip__sff_8h_364cf00d14dd63d23c8d19b1eeaa93be}{
\index{ip\_\-sff.h@{ip\_\-sff.h}!ip\_\-sff\_\-block\_\-copy@{ip\_\-sff\_\-block\_\-copy}}
\index{ip\_\-sff\_\-block\_\-copy@{ip\_\-sff\_\-block\_\-copy}!ip_sff.h@{ip\_\-sff.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ ip\_\-sff\_\-block\_\-copy (void $\ast$ {\em dst}, \/  void $\ast$ {\em src}, \/  {\bf str\_\-\_\-ctx} $\ast$ {\em ctx})}}
\label{ip__sff_8h_364cf00d14dd63d23c8d19b1eeaa93be}


This function is used to copy memory block. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em ctx}]Simulator context. \item[\mbox{$\leftarrow$} {\em dst}]Pointer to the destination block. \item[\mbox{$\leftarrow$} {\em src}]Pointer to the source block.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Pointer to the destination block.\end{Desc}
\begin{Desc}
\item[See also:]\hyperlink{structstr____ctx}{str\_\-\_\-ctx}\end{Desc}
\begin{Desc}
\item[Author:]Dorian Ivancic \href{mailto:dorian@linux.hr}{\tt dorian@linux.hr} \end{Desc}
\begin{Desc}
\item[Date:]2005-09-19 \end{Desc}


Definition at line 2120 of file ip\_\-sff.c.

References inc\_\-idx.

Referenced by i\_\-block\_\-copy().

\begin{Code}\begin{verbatim}2124 {
2125     inc_idx;
2126 
2127     /* next two lines are for compiler to skip the warnings about unused variables */
2128     ctx = (str__ctx *) dst;
2129     ctx = (str__ctx *) src;
2130 
2131     /* we have no implementation for this! yet! :-) */
2132     return (NULL);
2133 }
\end{verbatim}
\end{Code}


\hypertarget{ip__sff_8h_06748ab545b8993beece4ce80a1b5fae}{
\index{ip\_\-sff.h@{ip\_\-sff.h}!ip\_\-sff\_\-block\_\-move@{ip\_\-sff\_\-block\_\-move}}
\index{ip\_\-sff\_\-block\_\-move@{ip\_\-sff\_\-block\_\-move}!ip_sff.h@{ip\_\-sff.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ ip\_\-sff\_\-block\_\-move (void $\ast$ {\em dst}, \/  void $\ast$ {\em src}, \/  {\bf str\_\-\_\-ctx} $\ast$ {\em ctx})}}
\label{ip__sff_8h_06748ab545b8993beece4ce80a1b5fae}


This function is used to move memory block. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em ctx}]Simulator context. \item[\mbox{$\leftarrow$} {\em dst}]Pointer to the destination block. \item[\mbox{$\leftarrow$} {\em src}]Pointer to the source block.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Pointer to the destination block.\end{Desc}
\begin{Desc}
\item[See also:]\hyperlink{structstr____ctx}{str\_\-\_\-ctx}\end{Desc}
\begin{Desc}
\item[Author:]Dorian Ivancic \href{mailto:dorian@linux.hr}{\tt dorian@linux.hr} \end{Desc}
\begin{Desc}
\item[Date:]2005-09-19 \end{Desc}


Definition at line 2150 of file ip\_\-sff.c.

References inc\_\-idx.

Referenced by i\_\-block\_\-move().

\begin{Code}\begin{verbatim}2154 {
2155     inc_idx;
2156 
2157     /* next two lines are for compiler to skip the warnings about unused variables */
2158     ctx = (str__ctx *) dst;
2159     ctx = (str__ctx *) src;
2160     
2161     /* we have no implementation for this! yet! :-) */
2162     return (NULL);
2163 }
\end{verbatim}
\end{Code}


\hypertarget{ip__sff_8h_9dc0e72fbce3d6cf0a01a80996809458}{
\index{ip\_\-sff.h@{ip\_\-sff.h}!ip\_\-sff\_\-get\_\-allocator\_\-state@{ip\_\-sff\_\-get\_\-allocator\_\-state}}
\index{ip\_\-sff\_\-get\_\-allocator\_\-state@{ip\_\-sff\_\-get\_\-allocator\_\-state}!ip_sff.h@{ip\_\-sff.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int ip\_\-sff\_\-get\_\-allocator\_\-state ({\bf str\_\-\_\-ctx} $\ast$ {\em ctx})}}
\label{ip__sff_8h_9dc0e72fbce3d6cf0a01a80996809458}


This function returns the state of the allocator. 

As we don't have states, we return 0.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em ctx}]Simulator context.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]0.\end{Desc}
\begin{Desc}
\item[See also:]\hyperlink{structstr____ctx}{str\_\-\_\-ctx}\end{Desc}
\begin{Desc}
\item[Author:]Dorian Ivancic \href{mailto:dorian@linux.hr}{\tt dorian@linux.hr} \end{Desc}
\begin{Desc}
\item[Date:]2005-09-20 \end{Desc}


Definition at line 2179 of file ip\_\-sff.c.

References inc\_\-idx.

Referenced by i\_\-get\_\-allocator\_\-state().

\begin{Code}\begin{verbatim}2181 {
2182     
2183     inc_idx;
2184     /* ctx = ctx; */
2185     
2186     return (0);
2187 }
\end{verbatim}
\end{Code}


\hypertarget{ip__sff_8h_9022db5a54bf31bdad21df2836e1d365}{
\index{ip\_\-sff.h@{ip\_\-sff.h}!ip\_\-sff\_\-set\_\-allocator\_\-state@{ip\_\-sff\_\-set\_\-allocator\_\-state}}
\index{ip\_\-sff\_\-set\_\-allocator\_\-state@{ip\_\-sff\_\-set\_\-allocator\_\-state}!ip_sff.h@{ip\_\-sff.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void ip\_\-sff\_\-set\_\-allocator\_\-state (int {\em state}, \/  {\bf str\_\-\_\-ctx} $\ast$ {\em ctx})}}
\label{ip__sff_8h_9022db5a54bf31bdad21df2836e1d365}


This function sets the state of the allocator. 

As we don't have states, it does nothing!

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em ctx}]Simulator context. \item[\mbox{$\leftarrow$} {\em state}]Desired state.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Nothing.\end{Desc}
\begin{Desc}
\item[See also:]\hyperlink{structstr____ctx}{str\_\-\_\-ctx}\end{Desc}
\begin{Desc}
\item[Author:]Dorian Ivancic \href{mailto:dorian@linux.hr}{\tt dorian@linux.hr} \end{Desc}
\begin{Desc}
\item[Date:]2005-09-20 \end{Desc}


Definition at line 2204 of file ip\_\-sff.c.

References inc\_\-idx.

Referenced by i\_\-set\_\-allocator\_\-state().

\begin{Code}\begin{verbatim}2207 {
2208     
2209     inc_idx;
2210     state = 0; 
2211 }
\end{verbatim}
\end{Code}


\hypertarget{ip__sff_8h_3f9134c53f38b27ccd4938aa8d4ad09d}{
\index{ip\_\-sff.h@{ip\_\-sff.h}!ip\_\-sff\_\-print\_\-stat@{ip\_\-sff\_\-print\_\-stat}}
\index{ip\_\-sff\_\-print\_\-stat@{ip\_\-sff\_\-print\_\-stat}!ip_sff.h@{ip\_\-sff.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void ip\_\-sff\_\-print\_\-stat ({\bf str\_\-\_\-ctx} $\ast$ {\em ctx})}}
\label{ip__sff_8h_3f9134c53f38b27ccd4938aa8d4ad09d}


Print statistics. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em ctx}]Simulator's context.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Nothing.\end{Desc}
\begin{Desc}
\item[See also:]\hyperlink{structstr____ctx}{str\_\-\_\-ctx}\end{Desc}
\begin{Desc}
\item[Author:]Dorian Ivancic \href{mailto:dorian@linux.hr}{\tt dorian@linux.hr} \end{Desc}
\begin{Desc}
\item[Date:]2009-02-31 \end{Desc}


Definition at line 571 of file ip\_\-sff.c.

References get\_\-alloc\_\-counter, get\_\-free\_\-counter, get\_\-sbrk\_\-counter, get\_\-total\_\-alloc\_\-timer, get\_\-total\_\-free\_\-timer, get\_\-total\_\-sbrk\_\-timer, t\_\-avg\_\-timer(), t\_\-copy\_\-timers(), t\_\-print\_\-all(), T\_\-PRINT\_\-ALL\_\-\_\-OUTPUT\_\-CYCLES, T\_\-PRINT\_\-ALL\_\-\_\-OUTPUT\_\-SYSTEM, T\_\-PRINT\_\-ALL\_\-\_\-OUTPUT\_\-USER, and T\_\-PRINT\_\-ALL\_\-\_\-PRINT\_\-LABELS.

\begin{Code}\begin{verbatim}573 {
574     str__timer  alloc_avg;
575     str__timer  sbrk_avg;
576     str__timer  free_avg;
577 
578 
579     if (0 != ctx -> statistics)
580     {
581         printf ("\n");
582         printf ("IP Stephenson's Fast Fits statistics:\n");
583         printf ("------------------------\n");
584     }
585 
586 
587     if (1 == ctx -> statistics)
588     {
589         #ifdef HAVE_TSC
590 
591         printf (" Number of calls to alloc:                            %ld\n"
592                 , get_alloc_counter);
593 
594         t_print_all (&get_total_alloc_timer
595             , "Cycles spent while allocating:                    "
596             , 1
597             , 3
598             , T_PRINT_ALL__OUTPUT_CYCLES
599             );
600 
601         if (0 < get_alloc_counter)
602         {
603             t_copy_timers (&alloc_avg, &get_total_alloc_timer);
604             t_avg_timer (&alloc_avg, get_alloc_counter);
605             t_print_all (&alloc_avg
606                 , "Average number of cycles spent per call to alloc: "
607                 , 1
608                 , 3
609                 , T_PRINT_ALL__OUTPUT_CYCLES
610                 );
611         }
612 
613 
614         printf (" Number of calls to sbrk:                             %ld\n"
615                 , get_sbrk_counter);
616 
617         t_print_all (&get_total_sbrk_timer
618             , "Cycles spent in sbrk:                             "
619             , 1
620             , 3
621             , T_PRINT_ALL__OUTPUT_CYCLES
622             );
623 
624         if (0 < get_sbrk_counter)
625         {
626             t_copy_timers (&sbrk_avg, &get_total_sbrk_timer);
627             t_avg_timer (&sbrk_avg, get_sbrk_counter);
628             t_print_all (&sbrk_avg
629                 , "Average number of cycles spent per call in sbrk:  "
630                 , 1
631                 , 3
632                 , T_PRINT_ALL__OUTPUT_CYCLES
633                 );
634         }
635 
636 
637         printf (" Number of calls to free:                             %ld\n"
638                 , get_free_counter);
639 
640         t_print_all (&get_total_free_timer
641             , "Cycles spent while freeing:                       "
642             , 1
643             , 3
644             , T_PRINT_ALL__OUTPUT_CYCLES
645             );
646 
647         if (0 < get_free_counter)
648         {
649             t_copy_timers (&free_avg, &get_total_free_timer);
650             t_avg_timer (&free_avg, get_free_counter);
651             t_print_all (&free_avg
652                 , "Average number of cycles spent per call to free:  "
653                 , 1
654                 , 3
655                 , T_PRINT_ALL__OUTPUT_CYCLES
656                 );
657         }
658 
659         /*
660         t_print_all (&(context -> TIMER)
661             , "User TIMER:                                       "
662             , 1
663             , 3
664             , T_PRINT_ALL__OUTPUT_CYCLES
665             );
666         */
667         #endif /* #ifdef HAVE_TSC */
668     }
669 
670     else if (2 == ctx -> statistics)
671     {
672         printf (" Number of calls to alloc: %ld\n"
673                 , get_alloc_counter);
674 
675         t_print_all (&get_total_alloc_timer
676             , "Cycles spent while allocaing: \n"
677             , 1
678             , 3
679             , T_PRINT_ALL__OUTPUT_USER
680             | T_PRINT_ALL__OUTPUT_SYSTEM
681             | T_PRINT_ALL__OUTPUT_CYCLES
682             | T_PRINT_ALL__PRINT_LABELS
683             );
684 
685         if (0 < get_alloc_counter)
686         {
687             t_copy_timers (&alloc_avg, &get_total_alloc_timer);
688             t_avg_timer (&alloc_avg, get_alloc_counter);
689             t_print_all (&alloc_avg
690                 , "Average number of cycles spent per call to alloc: \n"
691                 , 1
692                 , 3
693                 , T_PRINT_ALL__OUTPUT_USER
694                 | T_PRINT_ALL__OUTPUT_SYSTEM
695                 | T_PRINT_ALL__OUTPUT_CYCLES
696                 | T_PRINT_ALL__PRINT_LABELS
697                 );
698         }
699 
700 
701         printf (" Number of calls to sbrk: %ld\n"
702                 , get_sbrk_counter);
703 
704         t_print_all (&get_total_sbrk_timer
705             , "Cycles spent in sbrk: \n"
706             , 1
707             , 3
708             , T_PRINT_ALL__OUTPUT_USER
709             | T_PRINT_ALL__OUTPUT_SYSTEM
710             | T_PRINT_ALL__OUTPUT_CYCLES
711             | T_PRINT_ALL__PRINT_LABELS
712             );
713 
714         if (0 < get_sbrk_counter)
715         {
716             t_copy_timers (&sbrk_avg, &get_total_sbrk_timer);
717             t_avg_timer (&sbrk_avg, get_sbrk_counter);
718             t_print_all (&sbrk_avg
719                 , "Average number of cycles spent per call in sbrk: \n"
720                 , 1
721                 , 3
722                 , T_PRINT_ALL__OUTPUT_USER
723                 | T_PRINT_ALL__OUTPUT_SYSTEM
724                 | T_PRINT_ALL__OUTPUT_CYCLES
725                 | T_PRINT_ALL__PRINT_LABELS
726                 );
727         }
728 
729 
730         printf (" Number of calls to free: %ld\n"
731                 , get_free_counter);
732 
733         t_print_all (&get_total_free_timer
734             , "Cycles spent while freeing: \n"
735             , 1
736             , 3
737             , T_PRINT_ALL__OUTPUT_USER
738             | T_PRINT_ALL__OUTPUT_SYSTEM
739             | T_PRINT_ALL__OUTPUT_CYCLES
740             | T_PRINT_ALL__PRINT_LABELS
741             );
742 
743         if (0 < get_free_counter)
744         {
745             t_copy_timers (&free_avg, &get_total_free_timer);
746             t_avg_timer (&free_avg, get_free_counter);
747             t_print_all (&free_avg
748                 , "Average number of cycles spent per call to free: \n"
749                 , 1
750                 , 3
751                 , T_PRINT_ALL__OUTPUT_USER
752                 | T_PRINT_ALL__OUTPUT_SYSTEM
753                 | T_PRINT_ALL__OUTPUT_CYCLES
754                 | T_PRINT_ALL__PRINT_LABELS
755                 );
756         }
757     }
758 }
\end{verbatim}
\end{Code}


\hypertarget{ip__sff_8h_f6000d6e7bd3d62c7f845eb0e3717e82}{
\index{ip\_\-sff.h@{ip\_\-sff.h}!ip\_\-sff\_\-mem\_\-dump@{ip\_\-sff\_\-mem\_\-dump}}
\index{ip\_\-sff\_\-mem\_\-dump@{ip\_\-sff\_\-mem\_\-dump}!ip_sff.h@{ip\_\-sff.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void ip\_\-sff\_\-mem\_\-dump ({\bf str\_\-\_\-ctx} $\ast$ {\em ctx})}}
\label{ip__sff_8h_f6000d6e7bd3d62c7f845eb0e3717e82}


Memory dump. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em ctx}]Simulator's context.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Nothing.\end{Desc}
\begin{Desc}
\item[See also:]\hyperlink{structstr____ctx}{str\_\-\_\-ctx}\end{Desc}
\begin{Desc}
\item[Author:]Ivan Popovski \href{mailto:ivan.popovski@srce.hr}{\tt ivan.popovski@srce.hr} \end{Desc}
\begin{Desc}
\item[Date:]2009-01-20 \end{Desc}


Definition at line 773 of file ip\_\-sff.c.

References get\_\-last\_\-block, get\_\-this\_\-in\_\-use\_\-this, get\_\-this\_\-size\_\-this, str\_\-\_\-ip\_\-sff\_\-alloc\_\-algo\_\-ctx::last, PREV\_\-IN\_\-USE, and THIS\_\-IN\_\-USE.

Referenced by i\_\-alloc\_\-mem\_\-dump().

\begin{Code}\begin{verbatim}775 {
776     str__treap_node *chunk = (str__treap_node *) ctx -> sysmem_block; 
777     str__treap_node *last = get_last_block;
778 
779     printf ("\n");
780     printf ("MEMORY DUMP\n");
781 
782     printf ("+------------+----------+--------+----------------------------------------------+\n");
783     printf ("|  ADDRESS   |   SIZE   | IN USE |        HEADER DUMP (5x32bit)                 |\n");
784     printf ("+------------+----------+--------+----------------------------------------------+\n");
785 
786     do {
787         /* address, size */
788         printf ("| %10p ", chunk);
789         printf ("| %8u ", get_this_size_this (chunk));
790 
791         /* in use */
792         if (get_this_in_use_this (chunk)) 
793             printf ("|  used  ");
794         else
795             printf ("|  free  ");
796 
797         printf ("| %08x %08x %08x %08x %08x |",
798             (unsigned int) chunk -> prev_size,
799             (unsigned int) chunk -> this_size,
800             (unsigned int) chunk -> child[0],
801             (unsigned int) chunk -> child[1],
802             (unsigned int) chunk -> parent); 
803 
804         printf ("\n");
805 
806         chunk = (str__treap_node *) ((byte *) chunk + ((chunk -> this_size)
807                         & ~(PREV_IN_USE | THIS_IN_USE | RESERVED_BITS)));
808 
809     } while (chunk <= last);
810 
811     printf ("+------------+----------+--------+----------------------------------------------+\n\n"); 
812 }
\end{verbatim}
\end{Code}


