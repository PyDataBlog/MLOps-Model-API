% Created 2015-05-06 Wed 10:28
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{soul}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{hyperref}
\tolerance=1000
\usepackage{minted}
\providecommand{\alert}[1]{\textbf{#1}}

\title{Lecture 14 Notes}
\author{Derek Harter}
\date{2015-05-06}
\hypersetup{
  pdfkeywords={},
  pdfsubject={Lecture 14 Notes.},
  pdfcreator={Emacs Org-mode version 7.9.3f}}

\begin{document}

\maketitle


\section{First Session (11 - 11:40)}
\label{sec-1}
\subsection{Stacks}
\label{sec-1-1}

\begin{itemize}
\item A stack is a structure that allows nodes to be added and removed from the top of the stack only.
\item It is last-in-first-out (LIFO) data structure.  The last item you push, will be the first item back
  out when you pop.
\item One way to implement, is using a linked list, where we provide only 2 operations, `push()\~{} and \verb~pop()~
\item Function push() is basically the same as the \verb~insertAtFront()~ function we have already developed.
\item Function pop() removes item from top
\item Other common operators on a stack are a function to test if the stack is empty.
\end{itemize}


\begin{verbatim}
struct Node
{
  int data;
  Node* nextPtr;
};
\end{verbatim}
\section{Second Session (11:45 - 12:30)}
\label{sec-2}
\subsection{Queues}
\label{sec-2-1}

\begin{itemize}
\item A queue is basically similar to a line in a store.  The first person in line is serviced first.
\item Queue nodes are added to the tail of the queue, and queue nodes are removed from the head of the queue.
\item A queue is first-in, first-out (FIFO), the first item in will be the first item removed.
\item The basic queue operations are usually named \verb~enqueue()~ and \verb~dequeue()~
\item Function \verb~enqueue()~ adds a node to the tail of the list.
\item Function \verb~dequeue()~ removes the node from the head of the list.
\item For efficiency, we usually keep pointers to the head and tail nodes of a queue, so we can
  do \verb,enqueue~/~dequeue, operations in O(1) constant time
\item We also commonly provide a function that determines if the queue is empty or not.
\end{itemize}
\section{Third Session (12:40 - 1:40)}
\label{sec-3}
\subsection{Trees}
\label{sec-3-1}

\begin{itemize}
\item Linked lists, stacks and queues are linear data structures.
\item A tree is nonlinear.
\item Each node in a tree is either an internal node or a leaf node.
\item All internal nodes have 1 or more children.  In a strict binary tree (which we will
  discuss here) each internal node has 1 or 2 child nodes, the left child and the right child.
\item In a tree, including a binary tree, there is one node that is at the top of the tree, known
  as the root node of the tree.
\item For example, we can recreate our binary search by organizing items as a binary search tree.
\begin{itemize}
\item The left node of tree contains child nodes with values less than the parent node.
\item The right node of tree contains child nodes with values greater than the parent node.
\end{itemize}
\end{itemize}

\end{document}
