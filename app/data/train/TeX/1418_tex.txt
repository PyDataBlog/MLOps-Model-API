\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{setspace}

\begin{document}

\vspace{0.5in}

\begin{center}
    {\large CIS 452, Winter 2015} \vspace{0.1in} \\
    {\large Michael McGirr} \vspace{0.1in} \\
    ~\\
    \textbf{Proposal:}\\
    \textbf{A project that will attempt to unify the communication of  
            medical information stored on heterogeneous database systems 
            and integrate the data using Haskell's strong 
            type system. }
\end{center}

%\vspace{0.1in}

% Project proposals are to be 5 pages in length and will include a 
% definition of the area, the particular problem to be considered in 
% that area, and a list of several references that will support the project. 

\begin{spacing}{2}

    \begin{center}
        \textbf{Background}\\
    \end{center}
    This project comes out of the apparent and growing need to find some 
    way to unify the many different medical database systems that exist.  This
    is especially important now, as many medical practices, hospitals and medical
    institutions shift from paper records of patient information to electronic
    medical records.  This task is challenging because there are numerous
    database systems that are being used now and many of them are proprietary
    and closed source. The RAND Corporation described the database used by Epic (a company that
    focuses on healthcare software) as a very ``closed'' platform that made 
    it ``challenging and costly for hospitals'' to interconnect with the 
    clinical or billing software of other companies.$^{1}$  
    The task of facilitating quick communication between these, while at the 
    same time preserving and guaranteeing the consistency of the data, is not 
    trivial but is a very interesting topic to work on.  

    \begin{center}
        \textbf{Project Description}\\
    \end{center}
    
    There are many database systems that are used for medical data storage.  
    This is reflective of the wide and differing kinds of data 
    involved with medicine and healthcare.  This project is not going to try to create 
    yet another medical database system in an attempt to unify this data  
    because medical data is stored in a wide variety of databases for a reason.  
    Instead, this project will demonstrate how medical data that is stored 
    on two different database systems can be integrated effectively at query 
    time and how the results can be selectively chosen from one database or the 
    other based on the kind of query made against the data.  

    In reality, there are many closed source electronic medical record programs 
    and complete knowledge of how their proprietary database systems work is 
    not available. Further, deploying these databases for testing purposes for this 
    project would be costly.  For that reason this project will focus on 
    integrating data in open-source database systems. 

    Since medical records often consist of databases management software that
    is not always SQL based, this project will focus on integrating data in both 
    a SQL system and a NoSQL system.  If time permits a third NoSQL system will 
    be included.

    The two main database systems that have been chosen are Cassandra, which is
    an open source distributed NoSQL database management system, and the second
    is PostgreSQL, an object-relational database management system (ORDMBS) that
    can handle complex SQL queries with index methods that are not available in
    other SQL database systems. If there is some time leftover or if there some difficulties are encountered
    with either of the previously mentioned database systems, MongoDB will be
    implemented as well. 

    In order to communicate with the specific Cassandra database protocols, the
    application for this will use Database.Cassandra.CQL$^{3}$ and the corresponding 
    data types that it provides between CQL and Haskell.  
    I will also attempt to define my own type instances to extend these types. 

    To communicate with PostgreSQL I will either use the 
    Database.PostgreSQL.Simple$^{4}$ package, which is a mid-level client 
    library for the PostgreSQL database, or I will use the slightly more 
    complicated Database.Persist.Postgresql$^{5}$ package which is a PostgreSQL
    backend for Persistent$^{6}$. Persistent is a Haskell library for type-safe
    data serialization.

    In either case the goal for my purposes is to allow my application to communicate
    with the two databases and be able to retrieve results for them based on
    queries that are put into the application.  The importance of the type
    systems that these protocols use will become clear as I try to mediate and
    combine results between the databases.  In the data integration scenario
    where data is pulled from both database sources, the application will have 
    to take data of one type and variety from one database and combine it with
    data from the other database and then combine them in a sensible and logical
    way to present to the user. 

    In some cases there will not be a need to combine data from both databases
    and the information available in one will be sufficient.  For instance
    billing information might only be in the PostgreSQL database.  There then
    might be some queries that are imputed in the system that only require the
    application to have to search through one of the databases. The functional
    ability of figuring out when to do this will be one of the goals of the
    project. 

    However the largest goal of this application is the ability to combine data
    from both systems in a way that can sensibly determine what data overlaps
    between the two and then how to avoid presenting duplicates of essentially
    the same data.  This will be difficult because making sense of the data is
    something that will not be able to be automated - except through case specific
    rules that are defined beforehand by a person.  An ambitious goal if
    everything else is complete would be to define a system by which abstract cases
    could be defined and then used in combination with one another to recognize
    more complex scenarios.  One of the things I will try to do as I write the
    case recognition code will be to define some of thse abstract cases that can
    then hopefully be
    used in combination with one another to sort through complicated cases that
    I haven't necessarily completely defined as one single case. 

    \begin{center}
        \textbf{Source of Data}\\
    \end{center}
  
    Because this project is focused on integrating disparate data from
    heterogeneous sources more than it is on the size of the data itself 
    and because of the privacy issues involved with access
    to real medical data - I will create fake data on my own to be used for this
    project.  The data that I create will be have a lot of detail instead of a
    large quantity. This is because my project is intended to demonstrate
    how to integrate data from sources that are very different and so the
    process of creating the data will be time intensive.  My goal is to generate
    enough data to demonstrate proof of concept.  If I am able to find a source 
    of fake medical data online, I will also use that.  
    Showing how a project like this can handle large amounts of data and how it 
    can scale would be an area for future work. 

    \begin{center}
        \textbf{Stretch Goals}\\
    \end{center}

    There are two parts that I hope to get to for this project but the scope of
    these tasks and of the time left to do this project might not allow for.
    The first is to integrate and use the Haxl$^{7}$ Haskell library that Facebook
    recently open-sourced$^{8}$. Beyond the desire to do so simply because it
    would be cool to integrate an open-source project like Haxl into my project
    - the more serious justification for doing so would be because Haxl can
    batch multiple requests to use the same data-source and it can request data
    from multiple heterogeneous data sources concurrently. These abilities
    closely match the goals that I have for my project. One line from their
    description highlights this: ``\emph{Haxl data sources are separated by request
    type; you may have any number of data sources coexisting in the same Haxl
    client, and each data source may be used to fetch data of any type. Type
    safety is enforced through GADTs, so that a request is always paired with
    its result type; and the Typeable class, so that requests to different data
    sources can be stored in Haxlâ€™s request store.}''$^{8}$

    Another goal would be to create a secure web-based interface for this
    project.  The Yesod Web Framework$^{9}$ for Haskell would be ideally suited to
    this.

    \begin{center}
        \textbf{Conclusion}\\
    \end{center}

    My hope is for this project is to show how a program could intelligently 
    mediate and integrate medical data from different database systems.  
    I think that doing so would create a starting ground for future work that 
    could implement a way for doctors and researchers to access data that is 
    stored on many of the existing proprietary database systems that are in 
    use today.  This would encourage better healthcare since is would make it
    easier to facilitate communication between the differing systems and it
    would allow for the patient to have one system through which they could
    access all of their own health records and the wealth of non-traditional
    data about our own health that is able to be measured and stored today in
    different databases. 


\end{spacing}


\newpage

\begin{center}
    \textbf{Citations and References}   
\end{center}

1. \\
Sullivan, Mark (December 8, 2014). ``Saying Epic is a Closed System is an
Oversimplification''. Venture Beat. Retrieved January 23, 2015. \\

2. \\
Creswell, Julie (September 30, 2014). ``Doctors Find Barriers to Sharing
Digital Medical Records''. The New York Times. Retrieved January 23, 2015. \\

3. \\
https://hackage.haskell.org/package/cassandra-cql-0.4.0.1/docs/Database-Cassandra-CQL.html\\

4. \\
http://hackage.haskell.org/package/postgresql-simple-0.0/docs/Database-PostgreSQL-Simple.html\\ 

5. \\
https://hackage.haskell.org/package/persistent-postgresql-2.1.2.2/docs/Database-Persist-Postgresql.html \\

6.\\
https://hackage.haskell.org/package/persistent \\

7.\\
https://github.com/facebook/Haxl\\

8.\\
https://code.facebook.com/posts/302060973291128/open-sourcing-haxl-a-library-for-haskell/ \\

9.\\
http://www.yesodweb.com/ \\


\end{document}
