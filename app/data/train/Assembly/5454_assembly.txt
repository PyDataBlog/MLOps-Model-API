#	Universidade de Brasília
#	Introdução aos Sistemas Computacionais - 2017/1
#	@authors:	Leonardo de Almeida
#				Marcus Vinícius da Silva Borges
#
#	This is a simple implementation of Selection Sort algorithm. 
#	Given the array in line 10 and the size in line 11. The code
#	will sort it and print it sorted.
.data

	array:	.word 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, -4
	size:	.word 12
	str0:	.asciiz ">> "
	str1:	.asciiz " "
	
.text
	
	main:
				la $s0, array	# Load the first array's element into $s0 register.
				lw $s1, size	# Load the array's size into $s1 register.
				
	sort:
				li $s2, 0 		# $s2 = 0
				sub $s3, $s1, 1 # $s3 = size - 1
				
	sort_loop:
				beq $s2, $s3, print_vector	# Break sort_loop if $s2 == $s3
				
				# Here, $s4 register is used to store the index of de smallest element.
				# We assume that in this point, the smallest element has index 0.
				move $s4, $s2		
				jal min		# jumps to min label
				jal swap	# jumps to wap label
				addi $s2, $s2, 1	# $s2++
				j sort_loop					
				
	min:
				# $s5 register is used to iterate through elements, from, k + 1 to size
				addi $s5, $s2, 1 # $s5 = $s2 + 1
				
	min_loop:
				beq $s5, $s1, end_min_loop	# Break min_loop if $s5 == size
				
				sll $t8, $s4, 2		# Calculates, based on index, the smallest index pointer's position.
				add $t9, $t8, $s0	# Moves the vector's pointer to the position calculated above
				lw $t0, ($t9)		# Stores the element into $s0 register
				
				sll $t1, $s5, 2		# Calculates, based on index, the current index pointer's position.
				add $t2, $t1, $s0	# Moves the vector's pointer to the position calculated above
				lw $s6, ($t2)		# Stores the element into $s6 register
				
				# The next instruction test if the element in the $s6 (currentIndex) is less than 
				# the element into $t0 (smallest element). If it is, updates the $s4 (smallest index).
				blt $s6, $t0, set_min
				addi $s5, $s5, 1	# $s5++
				j min_loop
					
	set_min:
				move $s4, $s5		# Update the index associated to smallestIndex. $s4 = $s5 (current index) 
				addi $s5, $s5, 1	# $s5++
				j min_loop
				
	end_min_loop:
				jr $ra		# returns to sort_loop
				
	swap:
				sll $t3, $s4, 2		# Calculates, based on $s4 index, the smallest index pointer's position.
				add $t2, $t3, $s0	# Moves the vector's pointer to the position calculated above.
				lw $t1, ($t2) 		# Stores in $t1 register the smallest element.
				
				sll $t4, $s2, 2		# Calculates, based on $s2 index, the current index pointer's position.
				add $t5, $t4, $s0	# Moves the vector's pointer to the position calculated above.
				lw $t6, ($t5) 		# Stores in $t6 register the current element.
				
				# The following three lines swap the smallest element with the current element.
				move $t7, $t1
				move $t1, $t6
				move $t6, $t7
				
				# Save the changes
				sw $t1, ($t2)
				sw $t6, ($t5)
				
				jr $ra			# back to sort_loop
			
	print_vector:
				li $s2, 0 		# $s2 is used to iterate through the array.
				
				la $a0, str0
				li $v0, 4
				syscall			# prints '>> ' string
				
	print_loop:
				beq $s2, $s1, end	# Ends the program if $s2 == size
				sll $t0, $s2, 2		# Calculates, based on $s2 index, the current index pointer's position.
				add $t1, $t0, $s0	# Moves the vector's pointer to the position calculated above.
				
				la $a0, str1		# prints the ' ' string
				li $v0, 4
				syscall
				
				lw $a0, ($t1)		# Stores in #a0 register the element in the current position of the array.
				li $v0, 1			
				syscall				# Prints the current element.
				addi $s2, $s2, 1	# $s2++
				j print_loop	
				
	end:
				li $v0, 10			# Ends the program
				syscall
				
				
				