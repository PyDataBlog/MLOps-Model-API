
level4:     file format elf32-i386

Disassembly of section .text:

08048080 <_start>:
 8048080:	8b 5c 24 08          	mov    0x8(%esp),%ebx               ; ebx = esp + 0x08
 8048084:	e8 6a 00 00 00       	call   80480f3 <That>               ; call That, line 57
 8048089:	85 c0                	test   %eax,%eax                    ; set sign flag (SF) to 1 if eax < 0 (negative)
 804808b:	78 70                	js     80480fd <What>               ; jump if SF == 1, if call to open failed at line 60
 804808d:	e8 49 00 00 00       	call   80480db <Other>              ; call Other, line 47
 8048092:	85 c0                	test   %eax,%eax                    ; set sign flag (SF) to 1 if eax < 0 (negative)
 8048094:	78 67                	js     80480fd <What>               ; jump if SF == 1, if call to read failed at line 52
 8048096:	e8 2e 00 00 00       	call   80480c9 <This>               ; call This, line 40
 804809b:	75 60                	jne    80480fd <What>               ; jump if ZF == 0
 804809d:	e8 00 00 00 00       	call   80480a2 <More>               ; call More, line 18

080480a2 <More>:
 80480a2:	6a 31                	push   $0x31                        ; push 0x31 on the stack
 80480a4:	58                   	pop    %eax                         ; eax = 0x31, this is system call sys_geteuid
 80480a5:	cd 80                	int    $0x80                        ; perform interrupt
 80480a7:	89 c3                	mov    %eax,%ebx                    ; ebx = eax (effective uid)
 80480a9:	89 c1                	mov    %eax,%ecx                    ; ecx = eax (effective uid)
 80480ab:	6a 46                	push   $0x46                        ; push 0x46 on the stack
 80480ad:	58                   	pop    %eax                         ; eax = 0x46, this is system call sys_setreuid (uses ebx + ecx)
 80480ae:	cd 80                	int    $0x80                        ; perform interrupt
 80480b0:	31 c0                	xor    %eax,%eax                    ; eax = 0
 80480b2:	50                   	push   %eax                         ; push 0 on the stack
 80480b3:	68 2f 2f 73 68       	push   $0x68732f2f                  ; push 0x68732f2f on the stack
 80480b8:	68 2f 62 69 6e       	push   $0x6e69622f                  ; push 0x6e69622f on the stack
 80480bd:	54                   	push   %esp                         ; push esp (stack pointer) on the stack
 80480be:	5b                   	pop    %ebx                         ; ebx = esp
 80480bf:	50                   	push   %eax                         ; push eax on the stack
 80480c0:	53                   	push   %ebx                         ; push ebx on the stack
 80480c1:	89 e1                	mov    %esp,%ecx                    ; ecx = esp
 80480c3:	31 d2                	xor    %edx,%edx                    ; edx = 0
 80480c5:	b0 0b                	mov    $0xb,%al                     ; eax = 0x0b, this is system call sys_execve
 80480c7:	cd 80                	int    $0x80                        ; perform interrupt

080480c9 <This>:
 80480c9:	be 1c 91 04 08       	mov    $0x804911c,%esi              ; esi = 0x0804911c
 80480ce:	bf 08 91 04 08       	mov    $0x8049108,%edi              ; edi = 0x08049108
 80480d3:	b9 0e 00 00 00       	mov    $0xe,%ecx                    ; ecx = 0x0e
 80480d8:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)    ; while ZF != 0 and ecx != 0, compare characters and set ZF = 1 if chars are same
 80480da:	c3                   	ret                                 ; return

080480db <Other>:
 80480db:	89 c3                	mov    %eax,%ebx                    ; ebx = eax, the file descripter
 80480dd:	b8 03 00 00 00       	mov    $0x3,%eax                    ; eax = 0x03, this is system call sys_read
 80480e2:	b9 1c 91 04 08       	mov    $0x804911c,%ecx              ; ecx = 0x0804911c, address where to put read contents
 80480e7:	ba 16 91 04 08       	mov    $0x8049116,%edx              ; edx = 0x08049116, this is count, how much to read
 80480ec:	cd 80                	int    $0x80                        ; perform interrupt
 80480ee:	85 c0                	test   %eax,%eax                    ; set sign flag (SF) to 1 if eax < 0 (negative)
 80480f0:	78 0b                	js     80480fd <What>               ; jump if SF == 1, if call to read failed at line 52
 80480f2:	c3                   	ret                                 ; return

080480f3 <That>:
 80480f3:	b8 05 00 00 00       	mov    $0x5,%eax                    ; eax = 0x05, this is sytem call sys_open
 80480f8:	31 c9                	xor    %ecx,%ecx                    ; ecx = 0
 80480fa:	cd 80                	int    $0x80                        ; perform interrupt, ebx set at line 7 is starting esp + 0x08, ecx is 0
 80480fc:	c3                   	reti                                ; file descriptor in eax, return

080480fd <What>:
 80480fd:	89 c3                	mov    %eax,%ebx                    ; ebx = eax
 80480ff:	31 c0                	xor    %eax,%eax                    ; eax = 0
 8048101:	05 01 00 00 00       	add    $0x1,%eax                    ; eax += 1, this is system call sys_exit
 8048106:	cd 80                	int    $0x80                        ; perform interrupt
