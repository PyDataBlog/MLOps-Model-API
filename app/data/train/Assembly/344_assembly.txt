; name : dllmain.asm

; description :	main assembly file for the Dynamic Link Library

; remark : It's a strange case/switch structure I've constructed here but doing so
;			I can put eventually long routines for each case in the code.
;			Another approach is to use subroutines but I believe it will make the
;			dll loader more complex.
;			Also notice that you can set the error code if a requirement fails.
;			This error code must be in rax before the ret instruction at the end.
;			In case you don't use a special routines for each case, you can also comment
;			the decision making component and just end with mov rax, 1 followed by a ret
; more info :	about DLL https://social.msdn.microsoft.com/Search/en-US?query=dll&pgArea=header&emptyWatermark=true&ac=4
;				about GetLastError : https://msdn.microsoft.com/en-us/library/windows/desktop/ms679360(v=vs.85).aspx
;				about SetLastError : https://msdn.microsoft.com/en-us/library/windows/desktop/ms680627(v=vs.85).aspx

; You can safely remove TestFunction.asm and TestFunction.inc. If you do also remove the 'extrn TestFunction : proc' in dllfunctions.inc
; each added routine must be defined as extrn in dllfunctions.inc if you like to use the libary in other applications without defining the
; published functions yourself in the future.

option casemap :none	; case sensitive

include dllmain.inc		; constants used in dllmain routine (if any)

USE_SWITCH_CASE_BLOCK = 1				; replace 0 by 1 to let the assembler know to use the attach/detach procedures

%if USE_SWITCH_CASE_BLOCK eq 1

	.data
	
	; in stead of creating a switch case structure we can easily calculate the address of each attach/detach procedure. We do this only when we
	; make use of the procedures, otherwise it's waste of space.
	; DON'T ALTER the order of appearance of the addresses. They are placed in numerical ascending order of
	;	DLL_PROCESS_DETACH                   equ 0
	;	DLL_PROCESS_ATTACH                   equ 1
	;	DLL_THREAD_ATTACH                    equ 2
	;	DLL_THREAD_DETACH                    equ 3
	
		dllProcedures		dq	ProcessDetachProc, ProcessAttachProc, ThreadAttachProc, ThreadDetachProc

	.code

		dllmain proc hInstDLL: qword, reason: qword, reserved1: qword
			mov		hInstDLL, rcx		; save procedure values
			mov		reason, rdx
			mov		reserved1, r8
			shl		rdx, 3				; multiply by 8 to calculate the right address
			lea		rax, dllProcedures	; load effective address of start of procedures
			add		rax, rdx			; add offset
			call	qword ptr[rax]		; jump to respective routine
			ret							; when all is ok we have rax = 1, otherwise rax = 0
		dllmain endp

		; the individual attach/detach procedures
		; if succesfull we return with rax = 1
		ProcessAttachProc	proc
			xor		rax, rax
			inc		rax
			ret
		ProcessAttachProc	endp

		ProcessDetachProc	proc
			xor		rax, rax
			inc		rax
			ret
		ProcessDetachProc	endp

		ThreadAttachProc	proc
			xor		rax, rax
			inc		rax
			ret
		ThreadAttachProc	endp

		ThreadDetachProc	proc
			xor		rax, rax
			inc		rax
			ret
		ThreadDetachProc	endp

%else

	.code
		; if we don't have specific code to run, we can return with rax = 1
		dllmain proc hInstDLL: qword, reason: qword, reserved1: qword
			xor		rax, rax
			inc		rax
			ret
		dllmain endp
			
%endif

end