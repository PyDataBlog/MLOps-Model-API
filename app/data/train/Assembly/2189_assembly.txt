; procedure : reg64ToDec.asm
;
; Converts the value passed in rax to its decimal equivalent in ASCIIZ.
; Returns the pointer to the buffer where the string is stored. 
; The procedure doesn't clear the buffer before use.

option casemap:none

.data
	dbBuffer	db	20 dup (0)
				db	0					; terminating zero

.code
align 16

reg64ToDec proc qwValue: qword
	local	lpResult : qword
	push	rdi						; save used registers
	push	rbx
	push	rdx	
	mov		rbx, 10					; base 10
	lea		rdi, dbBuffer+20		; pointer to end of buffer = buffer + 20
	mov		rax, qwValue
	; repeat next loop until quotient in rax is zero, rdx contains the remainder which will be stored
@@:
	xor		rdx, rdx
	div		rbx
	or		dl, 30h					; make ASCII
	mov		byte ptr[rdi], dl		; store digit
	dec		rdi
	and		rax, rax
	; until quotient is zero
	jnz		@B
	inc		rdi						; adjust pointer to decimal data
	mov		lpResult, rdi			; pointer to string in rax	
	pop		rdx
	pop		rbx
	pop		rdi
	; next piece of code is to get rid of the stack variable pushed before calling this procedure
	mov		rax, [rbp+8]			; get return address
	mov		[rbp+16], rax			; put it in place of qwValue
	mov		rax, [rbp]				; get old value of RBP
	mov		[rbp+8], rax			; put in in place of the return address location
	mov		rax, lpResult			; load the pointer to the result in rax, after this point it will be lost
	add		rbp, 8					; adjust RBP
	add		rsp, 8					; adjust RSP
	;;masm will add the opcode for leave 
	ret
reg64ToDec endp
end