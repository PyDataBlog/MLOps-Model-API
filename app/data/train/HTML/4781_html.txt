---
layout: socpage
title: Bithire - peer-to-peer employment
excerpt: Bithire is a global online market place for offering services and acquiring services.
image:
  feature:
---
<style type="text/css">
p.q {font-weight: bolder;}
p.a {font-style:italic;}
p.s {font-weight: bolder; font-style:italic;}
</style>

<div class="ui vertical stripe segment">
  <div class="ui text container">
    <p><a href="https://bitcointalk.org/index.php?topic=1201420.msg12667788#msg12667788">Bithire</a> is a global online market place for offering services and acquiring services. Bithire uses Bitcoin and the blockchain for providing a secure and decentralised payment solution. In addition, members can utilize our in-site currency HIRE token for micro-tipping, redeeming rewards, and more!</p>
    <blockquote>
    <h2>GET IT DONE!</h2>
    <p>Have a job you need done? Bithire is your team here to help you complete your vision!</p>
    <h2>OFFER YOUR SERVICES</h2>
    <p>Have a skill or talent you want to share? Time to get paid doing what you love! Offer your services on the BitHire network.</p>
    <h2>SECURITY AND TRUST</h2>
    <p>Secure transactions are powered bitcoin and the blockchain providing anonymity and security.</p>
    </blockquote>
    <p>Bithire will allow those with valuable skills to do work in exchange for Bitcoin and Hire Token!</p>
    <p>Whether it’s working as a virtual assistant, graphic designer, website designer, coding or even giving lessons, Bithire is the place to find the perfect person to hire.</p>
    <p>The website will be the first to offer completely blockchain based payments and furthermore, will make use of the HIRE token for tipping.</p>
    <p>In addition to tipping, HIRE token will be accepted on the site for paid advertising, as well as featuring your gig.</p>
    <p>To kick start the website, we shall be offering fee-less job posting for the first 6 months. After which, a small fee of 5% will be applied!</p>

    <p>Ok, I should just explain how the escrow system works:</p>
    <ul>
    <li><p>Freelancer accepts a job which is paid for up-front. </p></li>
    <li><p>The money is then held until delivery of work AND there are no pending issues. </p></li>
    <li><p>The freelancer has responsibility in ensuring the work delivered is as described in their advert. </p></li>
    <li><p>Disputes will mean that the money is held in escrow until the disputes are resolved.</p></li>
    <li><p>There won't be any restrictions on the size of jobs you are able to offer. If you are concerned that they will not pay, the site ensures that full payment is taken before the job is considered accepted. </p></li>
    <li><p>There may be cases where continuous jobs are required for an on-going project. The site will allow you to create custom jobs if an incremental payment option is desirable.</p></li>
    </ul>
    <p class="q">Hi, just wondering if your service caters to recruiters looking to assemble a team of freelancers rather than just one</p>
    <p class="a">That's an interesting use case, but i'm not sure what you mean? Do you mean you want a project to be completed with different freelancers ? </p>
    <p class="q">Well yes, for example I may need a web developer and someone to write whitepaper for a small business that I want to open</p>
    <p class="a">I appreciate this might be useful, but in reality, collaboration between freelancers requires something that an automated system cannot provide. It requires project management, and a human element of cooperation. Just taking a web developer, and an academic separately to do the job required may suffice. </p>
    <p class="a">One alternative which we have talked about building is the job request feature, which is quite common on other sites. You would be able to write out what you need to have done, and let the freelancers choose whether they want to take up the job or not. In building this, it may be possible to implement a similar feature to what you're asking that allows you to delegate different parts of the project to different freelancers through offering different jobs under the same project.</p>
    <p class="q">Thanks for raising this though, as there is some merit to your feature request. I'll definitely have a good think about how to do this best.</p>
    <p class="s">Then, sadly, the coin solves nor proposes anything viable as it would be completely centralized trusting you with our funds, why use this instead of the multiple trusted freelancing websites? The whole point of cryptocurrencies is to be a trustless system.... decentralized.There are multisigs, smartcontracts etc that would be what a project like this would benefit from else I see no use, only extreme risk.</p>
    <p class="a">We have not chosen to go the approach of developing a technically sound turing-complete scripting language for the coin to enable things like smart-contracts or even decentralised markets. Whilst you are right that our system is not a trustless one, it can be argued that almost every market where BTC is used as the medium of transaction sits on a secondary layer of trust aswell. The conscious choice was to create a service which we believe can operate on Crypto Currencies. The advantages over other payment solutions speak for themselves. </p>
    <p class="a">Like every trusted service, whether its localbitcoins, bittrex, bitfinex or even silk-road, each has had an opportunity to provide a stellar service that has earned them that trust. Following your logic, there really is no compelling reason as to why any functional redundancies of use for any bitcoin service exist at all - and yet they do. </p>
    <p class="a">We have a small yet humble beginning, and we're fine with building trust from the ground up. We realise that this will take time, but as i've already discussed with some other people in the thread, there are some really good use-cases which I don't see in other freelance services which we can build. So that is what we're going to do.</p>
    <p class="q">Okay this answers my questions. I'd still like it if I could receive some of the money upfront though, a lot of jobs I've taken have taken weeks or even months. I can't really afford to take on the job if I won't be paid at all until completion. Maybe you can implement a way to let users decide if they want to release some funds early? Like 50% up front and 50% on completion?</p>
    <p class="a">This is a reasonable feature request, but I can see it being abused. I guess if we did something like this, then the recruiter would have to choose to do so. We'll look into this.</p>
    <p class="q">Yeah but without this, I wouldn't be inclined to do larger jobs. Instead, i'd look at doing lots of smaller little jobs. This kind of takes away the potential of what sort of services could be offered.</p>
    <p class="s">If I understand correctly, you could just create custom jobs with set milestones as part of a longer project, and this would probably solve your problem as far as I understand.</p>
  </div>
</div>


<div class="ui vertical stripe segment">
  <div class="ui text container">
    <h3 class="ui header">Notes on an improved approach</h3>
    <p><em>“AND there are no pending issues ... The freelancer has responsibility in ensuring the work delivered is as described in their advert.”</em> A model with this degree of shallowness is unable to make useful predictions which might otherwise help to achieve the objective. Minimally, it should acknowledge and reflect current work in <a href="https://en.wikipedia.org/wiki/Online_dispute_resolution">online dispute resolution</a>.</p>
    <p>A deeper model would include aspects of harmonising expectations, thus increasing the likelihood of a successful transaction ...</p>
    <blockquote>
      <p>The best way to avoid a lot of complaints that come with freelancing is to screen clients. However, not every client from hell has a pair of horns sticking out of their forehead. Here are some signs that you may be making a deal with the devil:</p>

      <h4 class="ui header">Ambiguous expectations:</h4>
      <p>A client is employing you because they lack the skillset or resources to complete a project themselves. However, the client should have a clear idea of what they’re after. Failing that, they should be eager to help you help them figure it out. Clients who fail this test have project scopes balloon overnight, or they react with anger and confusion when their idea of what they wanted doesn’t match the freelancer’s blind attempts to give it to them.</p>

      <h4 class="ui header">Unappreciative:</h4>
      <p>A client’s expectations may not be explicitly tied to the project itself; they may expect behaviour, time, or discounts for no other reason other than they think they deserve it. Unfortunately, giving these clients what they want only reinforces their belief that the freelancer lives to work for them. The best way to avoid these clients is for freelancers to be upfront about how they work and how they expect the client to work. The client’s reaction to this news will tell the freelancer a lot.</p>

      <h4 class="ui header">Disrespectful:</h4>
      <p>Disrespect is tied to the client not seeing a freelancer as an equal. The best relationships are based around working with a client, not for them. Clients that fail to pay on time, refuse to communicate, or blow off appointments and/or suggestions without justification are clients who lack a professional respect vital for a good working relationship.</p>

      <h4 class="ui header">Devaluing hard work:</h4>
      <p>Nobody is thrilled to spend money if they don’t have to, but if a client devalues your work and efforts in an attempt to lower their bottom line, it’s a point of concern. The freelancer-client relationship should be a mutually beneficial one. Clients should feel they are getting a value out of their freelancers, and freelancers should feel valued by their clients. Things like a paid deposit and a contract should make both the freelancer and the client feel safer; the pair have entered a bond that explicitly states expectations and responsibilities.</p>

      <p>Here are some additional tips to avoid a client from hell before you sell them your soul:
        <ol>
          <li>Research the client and their past projects</li>
          <li>Discuss all aspects of a project before committing to it</li>
          <li>Be honest and clear; expect the same treatment</li>
          <li>After a few correspondences, evaluate the client’s communication skills; are they telling you everything, and are they concise about it? Do they respect work hours and reasonable turnaround time? Are they addressing your questions and concerns?</li>
          <li>Trust your gut and don’t enter into a relationship that makes you feel uncomfortable.</li>
        </ol>
      </p>
    </blockquote>

    <!--
    <p>Some necessary depth can be gained quite simply by recruiting from adequately sophisticated technology.</p>
    <blockquote><p>Artificial intelligence is also frequently employed in modeling the legal ontology, “an explicit, formal, and general specification of a conceptualization of properties of and relations between objects in a given domain.” [27]</p></blockquote>
    <p>The reference is to: <tt>“A. Wyner, An Ontology in OWL for Legal Case-Based Reasoning. Artificial Intelligence and Law, 16: 361-387”</tt>. More relevant to a cryptocurrency is OMG’s <a href="http://www.omg.org/spec/EDMC-FIBO/FND/1.0/Beta1/">EDMC - Financial Industry Business Ontology (FIBO) Foundations (EDMC-FIBO/FND)</a>, which provides individual ontologies for: Accounting Equity, Currency Amount, Agents, People, Agreements, Contracts, Goals, Jurisdiction , Legal Capacity, Legal Core, Formal Organizations , Legitimate Organizations , Organizations , Control, Ownership, Parties, Roles, Addresses, Countries, Locations, Relations and Business-facing Types, plus a separate Annotation vocabulary.</p>
    <p>The contemporary approach forgoes idiosyncratic micro-languages in favour of declarative representations processed with increasingly sophisticated tools, i.e. RDF and OWL, classical AI’s modern form.</p>
    <p>The next step might be to recast Szabo’s E syntax into RDF and OWL, see how far we can get ...</p>
    -->
    <h3>Smart contracts</h3>
    <blockquote>
      <h3>Technical Note-- A Computer-Readable Syntax</h3>
      <p>Here is a formal specification of the language's grammar in "Backus-Naur Form"(BNF).  The specification is for a planned computer-readable version of the language and there are a few minor differences, such as the use of brackets {} instead of tabs to denote nesting. BNF is used to define what linguists call "context-free grammars".  It is also used, as here, to define the syntax of languages that computers can also interpret and execute.  I also include some more discussion of the meanings of the words and structures, especially how the computer might interpret them. As you can see, this is an evolving language, a work in progress with many unresolved issues.  Your suggestions for changing or adding more kinds of contractual terms to our language are quite welcome.</p>
      <pre>
agent = Holder | Counterparty
    ## makes contract look different on each side

period = (startTime,finishTime)
# period is the window within which the performance must be
# executed, e.g. a European option must be exercised 
# between the start to finish of the business day on which
# it expires.

[for periodIterator "{" ...periodIterator.next... "}"] [then ... periodIterator.next...]*
# rights performed in temporal order.
# sequence of periods used as inputs to sequence of withinPeriod(p) events.
# can this be more general, an iterator of events?  but periods have
# a natural order while other kinds of events can occur in any order.
# each periodIterator.next generates an event which is caught by
# the next tempral event (withinPeriod() if the iterator generates
# periods, aftertime() or beforeTime() if it generates times) 
# *down* from the *for*.  The implicit "throw" occurs at periodIterator.next
# so we can still view it, just barely, as propagating up from
# the "throw".
# (this is different from the normal event semantics where throws
# propagate *up* the parse tree) -- should I change it to *up*
# and rewrite the schedule iterator code above?  but it confuses
# me &amp;  perhaps the comuter to put it *outside* the loop.

event = choiceOf(agent) | withinPeriod(period) |  
    performed(right)  | breachedPerformance(right) |
    threshold(amount,threshold) | afterTime(time) | beforeTime(time)


right = throw event at [ contract | right] | passEvent([right | contract])
# generates an event to be caught by the specified contract or right.
# if contract or right is not specified, the first parent when(event)
# is triggered.

# just use when withinPeriod(whenWritten,time)
# right = doBefore time { right }

# semantically equivalent:
# Holder right = O Counterparty obligation

right = getTitle(property)
# transfer property title from obligor to obligee
# see http://szabo.best.vwh.net/securetitle.html

right = null

right = [ when event "{" right "}" ]*
    ## envision an "instruction pointer" that 
    ## follows nesting and events as they occur.
    ## there can be more than one instruction pointer
    ## if there is an "also" or two events occur at
    ## the same time, but usually we only need to think
    ## about one.
    ## a clause is either active or  inactive.
    ## when a when clause is active, it is waiting for
    ## an event to occur.
    ## when the instruction pointer a nested when,
    ## the when goes from inactive to waiting.
    ## A series of when's at the same level
    ## all wait for any of them to be triggered.
    ## When it receives an event  thrown below
    ## it or at it, it becomes active.  Then
    ## the clauses below it become active up
    ## to the when's one level below.  The
    ## whenes at that level go from inactive
    ## to waiting.
    ## alternative design being considered: continue where left off
    ## unless an explicit "terminate" in the when

right = functionPerformance     
    ## functional specification of a specific 
    ## service goes here
    ## function sig, pre-, post-conditions

obligation = throw event at [contract | right]
# generates an event to be caught by the specified contract or right.
# if contract or right is not specified, the first parent when
# is triggered.

# semantically equivalent: Holder obligation = Counterparty right

obligation = surrenderTitle(property)
# transfer property title from obligor to right holder
# see http://szabo.best.vwh.net/securetitle.html

obligation = null

obligation = [ when event "{" obligation "}" ]*
    ## alternative design being considered: continue where left off
    ## unless an explicit "terminate" in the when

obligation = functionPerformance     
    ## functional specification of a specific 
    ## service goes here
    ## function sig, pre-, post-conditions

contract = agent [right | obligation] ["with" agent [right | obligation]]*
    ## "with" allows composing Holder and Counterparty 
        ## rights vs. each other

contract = [ when event "{" contract "}" ]*
      </pre>

      <h3>Basic Functions</h3>
      <pre>
doOn(right, period) = 
    when withinPeriod(p) { right }
# must perform "right" within (period)
# = zero-coupon bond = coupon
#

doOnDemand(right) = 
    when choiceOf(Holder) { right }
# must perform "right" anytime/on demand
#

doOn(contract, period) = 
    when withinPeriod(p) { contract }
# must perform "contract" within (period)
#

doOnDemand(contract) = 
    when choiceOf(Holder) { contract }
# must perform "contract" anytime/on demand
#
      </pre>

      <h3>More Examples</h3>
      <pre>
future(rightA, rightB, p) = 
   Holder doOn(rightA, p)   with   Counterparty doOn(rightB, p)
#
# [additional constraint p=p is not mere algebraic composition]
#
callOptionAmerican(rightA, rightB, t) = 
   when withinPeriod(whenWritten, t) 
    when choiceOf(Holder) 
        Holder rightA  with  Counterparty rightB 
#
callOptionEuro(rightA, rightB, p) =  
   when choiceOf(Holder) 
    Holder doOn(rightA, p)  
        with Counterparty doOn(rightB, p))
#
putOptionAmerican(rightA,rightB,t) = 
   when withinPeriod(whenWritten, t)
    when choiceOf(Holder) 
        Holder rightA   with   Counterparty rightB 
   
# event semantics need to store the choiceOf even
# by waiting for the next when.
putOptionEuro(rightA,rightB,p) = 
   when choiceOf(Holder) 
    Holder doOn(rightB, p) 
        with Counterparty doOn(rightA, p))
#
note(right) = demandDeposit(right) = 
   Holder doOnDemand(right)
# [distinction of bearer vs. account holder has not 
# been introduced]
#
zeroCouponBond(right,p) = doOn(right, p)
#
callableZeroCouponBond(right,p) = 
   when choiceOf(Holder) { right }
   when withinPeriod(p) { right }
#
bond(coupon, principal, schedule) = 
    for schedule {
       doOn(coupon, schedule.next)
    } then
    doOn(principal, schedule.next)
bond(coupon, principal, schedule) = 
    for schedule {
       doOn(coupon, schedule.next)
    } then
    doOn(principal, schedule.next)
      </pre>

      <h3>Frequently Asked Questions</h3>
      <pre>
Q: There are already languages for specifying financial contracts (e.g., [2]), what is the novelty here?
A: This the first specification language to generalize contractual structures to any kind of exclusive rights, not just money.  This is also the first language that incorporates the dynamic nature of many contracts, (their dependence on time or events) in a succinct, complete, and potentially executable manner. Surprisingly, this often makes the specification more not less succinct.

Q: Where's the money?
A: This language is targeted toward an economy of distributed software and devices performing services for each other.  A money economy can be constructed out of a barter economy but not vice versa.   Real online money is far more subtle than a mere shared variable (or even the specification of "bank notes" in this language). Money is just one kind of fungible exclusive right, and the structure of financial contracts are generalized by converting money terms into any fungible exclusive right.

Q: What assumptions are you making?
A: This is the most important question to ask of any novel scheme!   I have identified at least the following:
(1) I'm assuming away, for the moment, issues of the protection and enforcement of performance, which I've addressed elsewhere (http://szabo.vwh.best.com/ has many essays that focus on this topic).  An eventual goal is to create protocols to enforce the language's atoms and then to compose these atoms maintaining the enforceability.
(2) Two specific enforcement assumptions -- there exists a secure, agreed-upon time source, and the occurence of other defined events can be agreed upon by the parties and/or audited by third parties.
(3) I am assuming some kind of atomicity for each right atom performance -- for example, when an event triggers a "when", a functionPerformance in another thread is gracefully either  rolled back or completed.
(4) There are only two parties to the contract, the Holder and Counterparty.
(5) A contract comes in two mirror forms, one of which can be inferred from the other.  A party always sees himself as the Holder.  Obligations of the Holder can always be expressed in and inferred from rights of the Counterparty, and vice versa.
(6) I'm probably making other assumptions I haven't discovered yet -- if you find any please let me know!


Q: What are some problems with this language you'd like to see solved?
A: Implementations that satisfy the above assumptions for the particular language atoms, and also for compositions of the atoms.  (Of course, various protocols in the "financial cryptography" field, in my own proposals, in the E language, etc. provide many valuable building blocks for such solutions).
      </pre>

      <h3>Technical Notes -- Innovations in this Language</h3>
      <p>Specific keywords after each instruction that distinguish it as:</p>
      <ul>
        <li>asynchronous (also)</li>
        <li>asynchrononous and atomic (with) Since this is not guarunteed atomic, is the only sure property that both instructions must be complete before we move on?  In this case "X with Y" is equivalent to "X also Y then".</li>
        <li>synchronous (then).  this also blocks all equally or lower nested prior asynchronous calls.</li>
      </ul>
      <p>My messages are only-way -- they have no return arguments. (But then again, the whole point is to swap rights and perform services defined outside the scope of the language.  Actual "information processing" should be done using another language).</p>
      <p>E allows "then" by defualt.  An asynch "also"-style call must have an explicit "when" to wait for its return.  In my language these calls block at the next equally or higher nested "then"and there are no return arguments.  E has no equivalent of "with", probably becomes atomicity does not have proven reliability and doing "with" across trust boundaries (as usually done here)  requires a trusted escrow or, perhaps, some very weird crypto protocol.</p>
      <p>Events are asynch-callable methods that are active only when "when" is in the "waiting" state.  (Catch can also be in a "inactive" or "active" state).  They search for whenes starting from the leaves of the target named clause ("throw at target"). E doesn't have anything like this, as far as I know.  Would break capability discipline?  (But my intention is to implement all atoms securely -- surely there is some subset of events that can be sent securely, i.e. by never sending capabilities in their message args?)</p>
    </blockquote>
  </div>
</div>
