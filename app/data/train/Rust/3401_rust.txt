// Our use cases
use super::expander;

pub fn allocate_expander(par_eax: i32, par_edx: i32) -> expander::SoundExpander {
    let mut sound_expander = expander::SoundExpander::new();
    let mut par_eax = par_eax;
    let mut par_edx = par_edx;

    sound_expander.wave_format_ex.format_tag = expander::WAVE_FORMAT_PCM as u16;
    sound_expander.wave_format_ex.channels = 1;

    if 8 & par_edx != 0 {
        sound_expander.wave_format_ex.bits_per_sample = 16;
    } else {
        sound_expander.wave_format_ex.bits_per_sample = 8;
    }

    sound_expander.wave_format_ex.samples_per_second = 22050; // MixRate
    sound_expander.wave_format_ex.block_align = (sound_expander.wave_format_ex.channels * sound_expander.wave_format_ex.bits_per_sample) >> 3;
    sound_expander.wave_format_ex.cb_size = 0;
    sound_expander.wave_format_ex.average_bytes_per_second = ((sound_expander.wave_format_ex.samples_per_second as u16) * (sound_expander.wave_format_ex.block_align as u16)) as i32;
    par_edx = par_edx | 2;

    sound_expander.flags1 = par_edx;
    sound_expander.flags2 = par_eax;

    sound_expander.some_var_6680E8 = 0x10000;   // SomeConst6680E8
    sound_expander.some_var_6680EC = 0x10;      // SomeConst6680EC
    sound_expander.read_limit = 0x10000 & 0x10;
    sound_expander.memb_64 = 0;
    sound_expander.memb_24 = 0;
    sound_expander.memb_40 = 0;
    sound_expander.memb_28 = 0x14;
    sound_expander.flags0 = 0x10000;

    if 2 & par_edx != 0 {
        sound_expander.flags0 = sound_expander.flags0 | 0x80;
    } else if 4 & par_edx != 0 {
        sound_expander.flags0 = sound_expander.flags0 | 0x40;
    } else if 0x40 & par_edx != 0 {
        sound_expander.flags0 = sound_expander.flags0 | 0x20;
    }
 
    if 0x10 & par_eax != 0 {
        sound_expander.flags1 = sound_expander.flags1 | 0x20;
        sound_expander.loop_point = -1;
    } else {
        sound_expander.loop_point = 0;
    }

    sound_expander.memb_58 = -1;
    sound_expander.memb_5C = 1;
    sound_expander.memb_4C = 0x7FFF;
    sound_expander.memb_54 = 0;

    sound_expander.previous = Box::new(expander::SoundExpander::new());
    sound_expander.next = Box::new(expander::SoundExpander::new());

    sound_expander
}

pub fn allocate_sound(par_ecx: i32, par_ebx: i32) -> expander::SoundExpander {
    let mut edx = 0x0A;
    let mut eax = 0;
    
    match par_ebx {
        0x0D => eax = 1,
        0x0E => eax = 2,
        _ => eax = 0,
    }

    match par_ecx {
        0x0F => eax = eax | 4,
        _ => edx = edx | 0x20,
    }

    allocate_expander(eax, edx)
}

