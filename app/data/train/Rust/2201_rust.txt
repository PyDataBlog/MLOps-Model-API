use super::{FractionalHex,Hex};
use std::f32::consts::PI;

pub struct Orientation {
    f: Vec<f32>,
    b: Vec<f32>,
    start_angle: f32
}

impl Orientation {
    pub fn new(f: Vec<f32>,b: Vec<f32>,start_angle: f32) -> Orientation {
        Orientation {
            f: f,
            b: b,
            start_angle: start_angle
        }
    }

    pub fn pointy() -> Orientation {
        Orientation::new(
            vec![(3.0 as f32).sqrt(), (3.0 as f32).sqrt() / 2.0, 0.0, 3.0 / 2.0],
            vec![(3.0 as f32).sqrt() / 3.0, -1.0 / 3.0, 0.0, 2.0 / 3.0],
            0.5
        )
    }

    pub fn flat() -> Orientation {
        Orientation::new(vec![3.0 / 2.0, 0.0, (3.0 as f32).sqrt() / 2.0, (3.0 as f32).sqrt()],
                vec![2.0 / 3.0, 0.0, -1.0 / 3.0, (3.0 as f32).sqrt() / 3.0],
                0.0)
    }
}

pub struct Point {
    pub x: f32,
    pub y: f32
}

impl Point {
    pub fn new(x: f32,y: f32) -> Point {
        Point {
            x: x,
            y: y
        }
    }
}

pub struct Layout {
    orientation: Orientation,
    size: Point,
    origin: Point
}

impl Layout {
    pub fn new(orientation: Orientation,size: Point,origin: Point) -> Layout {
        Layout {
            orientation: orientation,
            size: size,
            origin: origin
        }
    }

    pub fn hex_to_pixel(&self,h: Hex) -> Point {
        let orient = &self.orientation;
        let x = (orient.f[0] * h.x as f32 + orient.f[1] * h.y as f32 ) * &self.size.x;
        let y = (orient.f[2] * h.x as f32  + orient.f[3] * h.y as f32 ) * &self.size.y;

        Point::new(x + &self.origin.x,y + &self.origin.y)
    }

    pub fn screen_to_hex(&self,p: Point) -> FractionalHex {
        let orient = &self.orientation;
        let pt = Point::new((p.x - &self.origin.x) / &self.size.x,(p.y - &self.size.y));
        let x: f32 = orient.b[0] * pt.x as f32  + orient.b[1] * pt.y as f32 ;
        let y: f32 = orient.b[2] * pt.x as f32  + orient.b[2] * pt.y as f32 ;

        FractionalHex::new(x,y,-x - y)
    }

    pub fn hex_corner_offset(&self,corner: i32) -> Point{
        let angle = 2.0 * PI * (&self.orientation.start_angle + corner as f32) / 6.0;
        Point::new(&self.size.x * angle.cos(), &self.size.y * angle.sin())
    }

    pub fn polygon_corners(&self,h: Hex) -> Vec<Point> {
        let mut corners: Vec<Point> = Vec::new();
        let center = &self.hex_to_pixel(h);
        for i in 1..6 {
            let offset = &self.hex_corner_offset(i);
            corners.push(Point::new(center.x + offset.x,center.y + offset.y))
        }
        corners
    }
}
