use std::num::{
    Float,
    cast
};
use std::f64;

pub use self::Angle::{Deg, Rad, Grad};

pub trait Trigonometry<T>: Sized {
    fn sin(self) -> T;
    fn cos(self) -> T;
    fn tan(self) -> T;
}

pub enum Angle<T> {
    Deg(T),
    Rad(T),
    Grad(T)
}

impl<T> Angle<T> {
    pub fn unwrap(self) -> T {
        match self {
            Rad(v) | Deg(v) | Grad(v) => v
        }
    }
}

impl<T> Angle<T>
where T: Float {
    pub fn to_rad(self) -> Self {
        Rad(match self {
            Rad(v) =>  v,
            Deg(v) =>  v * cast(f64::consts::PI / 180.0).unwrap(),
            Grad(v) => v * cast(f64::consts::PI / 200.0).unwrap()
        })
    }
    pub fn to_deg(self) -> Self {
        Deg(match self {
            Rad(v) =>  v * cast(180.0 / f64::consts::PI).unwrap(),
            Deg(v) =>  v,
            Grad(v) => v * cast(180.0 / 200.0).unwrap()
        })
    }
    pub fn to_grad(self) -> Self {
        Grad(match self {
            Rad(v) =>  v * cast(200.0 / f64::consts::PI).unwrap(),
            Deg(v) =>  v * cast(200.0 / 180.0).unwrap(),
            Grad(v) => v
        })
    }

}

impl<T> Trigonometry<T> for Angle<T>
where T: Float {
    fn sin(self) -> T {
        self.to_rad().unwrap().sin()
    }

    fn cos(self) -> T {
        self.to_rad().unwrap().cos()
    }

    fn tan(self) -> T {
        self.to_rad().unwrap().tan()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use std::num::Float;
    use std::f64;
#[test]
    fn to_radians() {
        assert_eq!(Deg(0.0).to_rad().unwrap(), Float::zero());
        assert_eq!(Deg(180.0).to_rad().unwrap(), f64::consts::PI);
    }

#[test]
    fn sin() {
        assert_eq!(Deg(0.0).sin(), Float::zero());
        assert!(Deg(180.0).sin().abs() < f64::EPSILON);
    }
}
