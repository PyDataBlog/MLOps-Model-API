use crate::userstore::entities::person::Person;
use chrono::prelude::*;
use postgres::transaction::Transaction;
use std::time::Instant;
use uuid;

pub struct PersonInteractor();

#[allow(dead_code)]
impl PersonInteractor {
    pub fn create_person<'a>(
        trans: &Transaction,
        person: &'a mut Person,
    ) -> Option<&'a mut Person> {
        let now = Instant::now();
        person.created_on = Some(Utc::now());

        let query: String = "
        INSERT INTO userstore.PERSON
        VALUES (DEFAULT,DEFAULT,$1,$2,$3,$4,$5,NULL) 
        RETURNING id, uuid;"
            .to_string();

        let stmt = trans.prepare(&query).unwrap();
        let row_inserted = stmt
            .query(&[
                &person.firstname,
                &person.lastname,
                &person.email,
                &person.phone,
                &person.created_on,
            ])
            .unwrap();

        let row_data = row_inserted.iter().next().unwrap();
        person.id = row_data.get("id");
        person.uuid = row_data.get("uuid");

        println!(
            "⏱ create_person[🆕👦] > elapsed: {} ms",
            (now.elapsed().as_secs() * 1_000) + (now.elapsed().subsec_nanos() / 1_000_000) as u64
        );

        //Return
        Some(person)
    }

    pub fn update_person<'a>(
        trans: &Transaction,
        person: &'a mut Person,
    ) -> Option<&'a mut Person> {
        let now = Instant::now();
        person.updated_on = Some(Utc::now());

        let query: String = "
        UPDATE userstore.PERSON SET (firstname, lastname, email, phone, updated_on) 
        = ($2,$3,$4,$5,$6)
        WHERE ID = $1;"
            .to_string();

        let stmt = trans.prepare(&query).unwrap();
        stmt.query(&[
            &person.id,
            &person.firstname,
            &person.lastname,
            &person.email,
            &person.phone,
            &person.updated_on,
        ])
        .unwrap();

        println!(
            "⏱ update_person[💾👦] > elapsed: {} ms",
            (now.elapsed().as_secs() * 1_000) + (now.elapsed().subsec_nanos() / 1_000_000) as u64
        );
        //Return
        Some(person)
    }

    pub fn delete_person(trans: &Transaction, person: &Person) {
        let now = Instant::now();
        let query: String = "
        DELETE FROM userstore.PERSON WHERE ID = $1;"
            .to_string();

        &trans.execute(&query, &[&person.id]).unwrap();
        println!(
            "⏱ delete_person[❌👦] > elapsed: {} ms",
            (now.elapsed().as_secs() * 1_000) + (now.elapsed().subsec_nanos() / 1_000_000) as u64
        );
    }

    pub fn get_person_by_uuid(trans: &Transaction, uuid: &uuid::Uuid) -> Option<Person> {
        let now = Instant::now();
        let mut result: Option<Person> = None;

        let query: String = "
        select *
        from userstore.person as pe
        where 1=1
        and uuid=$1
        "
        .to_string();

        for row in &trans.query(&query, &[&uuid]).unwrap() {
            result = Some(Person::new(
                row.get("id"),
                row.get("uuid"),
                row.get("firstname"),
                row.get("lastname"),
                row.get("email"),
                row.get("phone"),
                row.get("created_on"),
                row.get("updated_on"),
            ));
        }

        println!(
            "⏱ get_person[👦] > elapsed: {} ms",
            (now.elapsed().as_secs() * 1_000) + (now.elapsed().subsec_nanos() / 1_000_000) as u64
        );
        //return
        result
    }

    pub fn get_person_by_id(trans: &Transaction, id: i32) -> Option<Person> {
        let now = Instant::now();
        let mut result: Option<Person> = None;

        let query: String = "
        select *
        from userstore.person as pe
        where 1=1
        and id=$1
        "
        .to_string();

        for row in &trans.query(&query, &[&id]).unwrap() {
            result = Some(Person::new(
                row.get("id"),
                row.get("uuid"),
                row.get("firstname"),
                row.get("lastname"),
                row.get("email"),
                row.get("phone"),
                row.get("created_on"),
                row.get("updated_on"),
            ));
        }

        println!(
            "⏱ get_person[👦] > elapsed: {} ms",
            (now.elapsed().as_secs() * 1_000) + (now.elapsed().subsec_nanos() / 1_000_000) as u64
        );
        //return
        result
    }

    pub fn get_all_person(trans: &Transaction) -> Vec<Person> {
        let now = Instant::now();
        let mut result: Vec<Person> = Vec::new();

        let query: String = "
        select *
        from userstore.person as pe
        where 1=1
        order by firstname;
        "
        .to_string();

        for row in &trans.query(&query, &[]).unwrap() {
            let person: Person = Person::new(
                row.get("id"),
                row.get("uuid"),
                row.get("firstname"),
                row.get("lastname"),
                row.get("email"),
                row.get("phone"),
                row.get("created_on"),
                row.get("updated_on"),
            );

            result.push(person);
        }

        println!(
            "⏱ get_all_person[👨‍👩‍👧‍👧] > elapsed: {} ms",
            (now.elapsed().as_secs() * 1_000) + (now.elapsed().subsec_nanos() / 1_000_000) as u64
        );
        //return
        result
    }
}
