extern crate rand;
use rand::{SeedableRng, StdRng};

mod grasp;
mod data_parser;
mod read_file;
use read_file::{create_reader, read_data};

fn euc2d(c1: [f32; 2], c2: [f32; 2]) -> f32 {
    ((c1[0] - c2[0]).powi(2) + (c1[1] - c2[1]).powi(2)).sqrt()
}

fn main() {
    // Read the needed data to run this program.
    //
    // These functions will make sure that, if nothing is passed as an argument
    // in the command line to this program, it will still try to read the data
    // from the standard input.
    let mut input = create_reader();
    let data = read_data(&mut input);

    // Now we have the data within the program. Time to parse it.
    let parsed_data = data_parser::parse(data.as_str());

    // Echo the data back to the user, for verification.
    println!("Data verification:\n\n{:?}\n\n", parsed_data);

    // Create and seed a random number generator.
    //
    // (You can use rand::thread_rng for a RNG with a random seed, but giving a
    // fixed seed makes the results predictable, which is good for testing.)
    let seed: usize = 31415;
    let seed: &[_] = &[seed as usize]; // because reasons; see rand docs
    let mut rng: StdRng = SeedableRng::from_seed(seed);

    // problem data
    let group: grasp::ProblemType = parsed_data;
    let max_iters: i32 = 50;
    let max_no_improv: i32 = 50;
    let greediness_factor: f32 = 0.3;

    // solving the actual problem
    println!("{:?}",
             grasp::search(
                 group,                // the problem data itself (which I still
                                       // do not fully understand what it is)

                 max_iters,            // maximum number of iterations to do
                                       // when searching for the best solution

                 max_no_improv,        // no idea

                 greediness_factor,    // alpha parameter, dunno what it does

                 &mut rng,             // instance of the random number
                                       // generator

                 // the cost function (first argument is a reference to the best
                 // solution found so far, second argument is a reference to
                 // `group`)
                 |best_so_far, group| {
                     // simple example of a cost function: distance between two
                     // points
                     let mut distance: f32 = 0.;

                     for (idx, &c1) in best_so_far.iter().enumerate() {
                         let c2 = if idx == best_so_far.len() - 1 {
                             best_so_far[0]
                         } else {
                             best_so_far[idx + 1]
                         };

                         distance += euc2d(group[c1].clone(), group[c2].clone());
                     }

                     distance
                 }
             )
    );
}
