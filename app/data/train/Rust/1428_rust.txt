// Copyright (C) 2015, Alberto Corona <alberto@0x1a.us>
// All rights reserved. This file is part of core-utils, distributed under the
// GPL v3 license. For full terms please see the LICENSE file.

#![crate_type = "lib"]
#![feature(path_relative_from,exit_status)]

extern crate term;
use std::io::prelude::Write;

use std::process;
use std::env;
use std::path::{PathBuf,Path};

pub enum Status {
    Ok,
    Error,
    OptError,
    ArgError,
}

pub fn exit(status: Status) {
    process::exit(status as i32);
}

pub fn set_exit_status(status: Status) {
    env::set_exit_status(status as i32);
}


pub fn path_err(status: Status, mesg: String, item: PathBuf) {
    match term::stdout() {
        Some(mut term) => {
            term.fg(term::color::RED).unwrap();
            (write!(term, "{}: {}\n",item.display(), mesg)).unwrap();
            term.reset().unwrap();
            exit(status);
        }
        None => {},
    };
}

pub fn err(prog: &str, status: Status, mesg: String) {
    match term::stdout() {
        Some(mut term) => {
            term.fg(term::color::RED).unwrap();
            (write!(term, "{}: {}\n", prog, mesg)).unwrap();
            term.reset().unwrap();
            exit(status);
        }
        None => {},
    };
}

pub fn copyright(prog: &str, vers: &str, yr: &str, auth: Vec<&str>) {
    print!("{} (core-utils) {}\n\
    Copyright (C) {} core-utils developers\n\
    License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\n\
    This is free software: you are free to change and redistribute it.\n\
    There is NO WARRANTY, to the extent permitted by law.\n\n", prog, vers, yr);
    print!("Written by ");
    for pers in auth.iter() {
        print!("{} ", pers);
    }
    print!("\n");
}

pub fn prog_try(prog: &str) {
    println!("{}: Missing arguments\n\
    Try '{} --help' for more information", prog, prog);
    set_exit_status(Status::ArgError);
}

pub trait PathMod {
    fn last_component(&self) -> PathBuf;
    fn first_component(&self) -> PathBuf;
    fn rel_to(&self, rel_from: &PathBuf) -> PathBuf;
}

impl PathMod for PathBuf {
    fn last_component(&self) -> PathBuf {
        let last = match self.components().last() {
            Some(s) => { PathBuf::from(s.as_os_str()) },
            None => { PathBuf::new() },
        };
        return last;
    }
    fn first_component(&self) -> PathBuf {
        let first = match self.components().nth(0) {
            Some(s) => { PathBuf::from(s.as_os_str()) },
            None => { PathBuf::new() },
        };
        return first;
    }
    fn rel_to(&self, rel_from: &PathBuf) -> PathBuf {
        self.relative_from(&rel_from).unwrap_or(&PathBuf::new()).to_path_buf()
    }
}

impl PathMod for Path {
    fn last_component(&self) -> PathBuf {
        let last = match self.components().last() {
            Some(s) => { PathBuf::from(s.as_os_str()) },
            None => { PathBuf::new() },
        };
        return last;
    }
    fn first_component(&self) -> PathBuf {
        let first = match self.components().nth(0) {
            Some(s) => { PathBuf::from(s.as_os_str()) },
            None => { PathBuf::new() },
        };
        return first;
    }
    fn rel_to(&self, rel_from: &PathBuf) -> PathBuf {
        self.relative_from(&rel_from).unwrap_or(&PathBuf::new()).to_path_buf()
    }
}
