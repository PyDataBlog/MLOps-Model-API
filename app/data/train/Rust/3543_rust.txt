// Copyright (C) 2015, Alberto Corona <alberto@0x1a.us>
// All rights reserved. This file is part of core-utils, distributed under the
// GPL v3 license. For full terms please see the LICENSE file.

#![crate_type = "bin"]
#![crate_name = "rm"]
#![feature(path_ext)]

static VERS: &'static str = "0.1.0";
static PROG: &'static str = "rm";

extern crate getopts;
extern crate util;

use getopts::{Options};
use util::{Status};

use std::env;
use std::fs;
use std::fs::{PathExt};
use std::path::{PathBuf};

fn exists(path: &PathBuf) -> bool {
    if !path.exists() {
        util::err(PROG, Status::Error, String::from("cannot remove '".to_string()
                                                    + path.to_str().unwrap() +
                                                    "': No such file or directory"
                                                   ));
    }
    return true;
}

fn rm_file(file: &PathBuf, verbose: bool) {
    match fs::remove_file(file) {
        Ok(_) => {
            if verbose {
                println!("Removed: '{}'", file.display());
            }
        },
        Err(e) => {
            util::err(PROG, Status::Error, e.to_string());
            panic!();
        }
    };

}

fn rm_dir(dir: &PathBuf, recurse: bool, verbose: bool) {
    if recurse {
        match fs::remove_dir_all(dir) {
            Ok(_) => {
                if verbose {
                    println!("Removed: '{}'", dir.display());
                }
            },
            Err(e) => {
                util::err(PROG, Status::Error, e.to_string());
                panic!();
            }
        };
    } else {
        match fs::remove_dir(dir) {
            Ok(_) => {
                if verbose {
                    println!("Removed: '{}'", dir.display());
                }
            },
            Err(e) => {
                util::err(PROG, Status::Error, e.to_string());
                panic!();
            }
        };
    }
}

fn rm_target(path: &PathBuf, recurse: bool, verbose: bool) {
    if exists(path) {
        if path.is_file() {
            rm_file(path, verbose);
        } else if path.is_dir() {
            rm_dir(path, recurse, verbose);
        }
    }
}

fn print_usage(opts: Options) {
    print!("Usage: rm [OPTION...] FILE...\n\
    Remove FILE(s) {}\n\
    Examples:
    rm -r dir\tDeletes `dir` and all of its contents", opts.usage(""));
}

fn main() {
    let args: Vec<String> = env::args().collect();
    let mut opts = Options::new();

    opts.optflag("v", "verbose", "Verbosely print operation");
    opts.optflag("r", "recursive", "Remove a directory and all of its contents");
    opts.optflag("h", "help", "Print the help menu");
    opts.optflag("", "version", "Print the version of rm");

    let matches = match opts.parse(&args[1..]) {
        Ok(m) => { m },
        Err(e) => {
            util::err(PROG, Status::OptError, e.to_string());
            panic!(e.to_string())
        }
    };

    let verb = matches.opt_present("v");
    let recurse = matches.opt_present("r");

    if matches.opt_present("h") {
        print_usage(opts);
    } else if matches.opt_present("version") {
        util::copyright(PROG, VERS, "2015", vec!["Alberto Corona"]);
    } else if !matches.free.is_empty() {
        for item in matches.free.iter() {
            rm_target(&PathBuf::from(&item), recurse, verb);
        }
    } else if matches.free.is_empty() {
        util::prog_try(PROG);
    }
}
