extern crate stopwatch;
use stopwatch::{Stopwatch};

fn main() {
    let timer = Stopwatch::start_new();
    //digits are stored in reverse order (least significant first) as an optimization
    match expand(196, 100000) {
        Ok(iter) => println!("converged after {} iterations", iter),
        Err(max_iters) => println!("did not converge after {} iterations", max_iters)
    }
    //print status
    println!("total execution time: {} ms", timer.elapsed_ms());
}

fn expand(number: u64, max_iters: i64) -> Result<i64, i64> {
    println!("expand {}", number);
    let mut digits = to_digits(number);
    //iterations will continue until palindromicity improves
    for iter in 1 .. max_iters + 1 {
        reverse_add(&mut digits);
        if iter % 10000 == 0 {
            println!("{} {}", iter, digits.len());
        }
        if is_palindrome(&digits) {
            return Ok(iter);
        }
    }
    //return iteration count as error value
    Err(max_iters)
}

fn to_digits(n:u64) -> Vec<u8> {
    let mut rem = n;
    let mut digits:Vec<u8> = Vec::new();
    while rem > 0 {
        let digit = (rem % 10) as u8;
        rem /= 10;
        digits.push(digit);
    }
    return digits;
}

/*
note that digits here are in reverse order (least significant digit first)
e.g. the number 349 should be represented as vec![9,4,3]
this lets us easily grow the array when a new digit is created by overflow, as we can simply
append it.  Otherwise we'd have to prepend, which is slower.
*/
fn reverse_add(digits: &mut Vec<u8>) {
    //first fold in half and sum, to cut down on additions
    let digits_len = digits.len();
    for i in 0 .. (digits_len + 1) / 2 {
        let j = digits_len - 1 - i;
        let sum = digits[i] + digits[j];
        digits[i] = sum;
        digits[j] = sum;
    }
    //now propagate overflow left to right (least significant digit to most significant)
    let mut overflow = 0;
    for i in 0 .. digits_len {
        digits[i] += overflow;
        if digits[i] >= 10 {
            digits[i] -= 10;
            overflow = 1;
        } else {
            overflow = 0;
        }
    }
    //finally add extra digit if we need it
    if overflow > 0 {
        //digits are in reverse order, so this new most-significant digit can just be put on the end
        digits.push(overflow);
    }
}


fn is_palindrome(digits: &Vec<u8>) -> bool {
    let digits_len = digits.len();
    for i in 0 .. digits_len/2 {
        if digits[i] != digits[digits_len - 1 - i] {
            return false;
        }
    }
    return true;
}
