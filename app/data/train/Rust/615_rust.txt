use std::io::BufReader;
use std::fs::File;
use std::str::FromStr;
use std::io;
use std::io::prelude::*;
use std::collections::BinaryHeap;

use std::cmp::Reverse;

#[derive(Debug)]
struct MaxHeap{
    heap:BinaryHeap<u64>,
    count: usize
}

impl MaxHeap {
    fn new() -> MaxHeap{
        let heap = BinaryHeap::new();
        let count = 0;
        MaxHeap {
            heap,
            count
        }
    }

    fn push(&mut self, new_value: u64) {
        self.count = self.count + 1;
        self.heap.push(new_value);
    }

    fn top(&self) -> u64 {
        let v = self.heap.peek().expect("max heap underflow");
        v.clone()
    }
    
    fn pop(&mut self) -> u64 {
        let v = self.heap.pop().expect("max heap underflow");
        self.count = self.count - 1;
        v
    }
}

#[derive(Debug)]
struct MinHeap {
    heap:BinaryHeap<Reverse<u64>>,
    count: usize
        
}

impl MinHeap {
    fn new() -> MinHeap{
        let heap = BinaryHeap::new();
        let count = 0;
        MinHeap {
            heap,
            count
        }
    }

    fn top(&self) -> u64 {
        let Reverse(v) = self.heap.peek().expect("min heap underflow");
        v.clone()
    }

    fn push(&mut self, new_value: u64) {
        self.count = self.count + 1;
        self.heap.push(Reverse(new_value));
    }

    fn pop(&mut self) -> u64 {
        let Reverse(v) = self.heap.pop().expect("min heap underflow");
        self.count = self.count - 1;
        v
    }
}

#[test]
fn min_heap_test1() {
    let mut h1 = MinHeap::new();
    h1.push(21);
    h1.push(10);
    h1.push(20);
    h1.push(30);
    h1.push(15);
    assert_eq!(5, h1.count);
    assert_eq!(h1.pop(), 10);
    assert_eq!(h1.pop(), 15);
    assert_eq!(h1.pop(), 20);
    assert_eq!(h1.pop(), 21);
    assert_eq!(h1.count, 1);
}

#[test]
fn max_heap_test1() {
    let mut h1 = MaxHeap::new();
    h1.push(21);
    h1.push(10);
    h1.push(20);
    h1.push(30);
    h1.push(15);
    assert_eq!(5, h1.count);
    assert_eq!(30, h1.pop());
    assert_eq!(21, h1.pop());
    assert_eq!(20, h1.pop());
    assert_eq!(15, h1.pop());
    assert_eq!(h1.count, 1);
}


fn insert_to_heaps(min_heap:&mut MinHeap, max_heap:&mut MaxHeap, value: u64, median: u64){
    if value > median {
        min_heap.push(value);
    }
    else {
        max_heap.push(value);
    }

    if min_heap.count > max_heap.count {
        let mut diff = min_heap.count - max_heap.count;
        while diff > 1 {
            let v = min_heap.pop();
            max_heap.push(v);
            diff = min_heap.count - max_heap.count;
        }
    }
    else {
        if max_heap.count > min_heap.count {
            let mut diff = max_heap.count - min_heap.count;
            while diff > 1 {
                let v = max_heap.pop();
                min_heap.push(v);
                diff = max_heap.count - min_heap.count;
            }
        }
    }
}

/*
#[test]
fn insert_test1()
{
    let mut mn = MinHeap::new();
    let mut mx = MaxHeap::new();
    for i in 0..35 {
        insert_to_heaps(&mut mn, &mut mx, i);
        if mn.count > mx.count {
            assert_eq!(mn.count - 1, mx.count);
        }
        if mx.count > mn.count {
            assert_eq!(mx.count - 1, mn.count);
        }
    }
    println!("min {:?} max = {:?}", mn, mx);
}*/

fn median_sum(v:&Vec<u64>) -> u64 {
    let mut junk = Vec::new();
    if v.len() < 1 {
        return 0;
    }
    let mut median = v[0] as u64;
    let mut curr_median = median;
    let mut mn = MinHeap::new();
    let mut mx = MaxHeap::new();
    mx.push(v[0]);
    junk.push(v[0]);
    for i in 1..v.len() {
        let value = v[i];
        junk.push(value);
        insert_to_heaps(&mut mn, &mut mx, value, curr_median);
        if mn.count > mx.count {
            curr_median = mn.top();
        }
        else {
            curr_median = mx.top();
        }
        
        median = median + curr_median;
        
        assert!(i+1 == (mn.count + mx.count));
    //    println!("array = {:?} min = {:?}, max {:?}", junk, mn, mx);
    }

    median % 10000
}

#[test]
fn medians_sum_test1() {
    let v = vec![1,666,10,667,100,2,3];
    let sum = median_sum(&v);
    assert_eq!(142, sum);
}

#[test]
fn medians_sum_test2() {
    let v = vec![6331,2793,1640,9290,225,625,6195,2303,5685,1354];
    let sum = median_sum(&v);
    assert_eq!(9335, sum);
}



fn print_medians(file_name: &str) -> io::Result<u64> {
    let f = File::open(file_name)?;
    let reader = BufReader::new(f);
    let mut v = Vec::new();
    for line in reader.lines() {
        let line = line.unwrap();
        let value = u64::from_str(&line).expect("error parsing value");
        v.push(value);
    }
    
    Ok(median_sum(&v))
}

fn main() {
    for arg in std::env::args().skip(1) {
        let value = print_medians(&arg).expect("failed to read");
        println!("answer = {}", value);
    }

}
