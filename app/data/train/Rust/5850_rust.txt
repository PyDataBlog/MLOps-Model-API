fn test1() {
    let mut v = vec![100, 32, 57]; //vec! is a macro
    for i in &mut v {
        *i += 50;
    }

    println!("iterate v");
    for i in &v {
        println!("{}", i);
    }

    let mut v1 = Vec::new();
    // v1.push(5.01); //type infer according to first value inserted
    v1.push(1);
    v1.push(3);
    v1.push(5);
    // v1.push(5.01); //compile error
    println!("iterate v1");
    for i in &v1 {
        println!("{}", i);
    }

    let i1 = v1.get(1);
    println!("v1[0] = {}", v1[0]);
}

fn test2() {
    let s1 = String::from("tic");
    let s2 = String::from("tac");

    let s1_2 = process_string1(&s1);
    println!("s1_2={}", s1_2);
    println!("s1={}", s1);

    let s2_2 = process_string2(s2);
    println!("s2_2={}", s2_2);
    // println!("s2={}", s2); //s2 has been moved, s2 is invalid here; value borrowed here after move

    let s3 = String::from("head");
    let s4 = String::from("shoulder");
    let s5 = String::from("knee");
    let s6 = String::from("toe");
    let sbody = s3 + "_" + &s4 + "_" + &s5 + "_" + &s6 + "_" + "ears";
    println!("sbody={}", sbody);
    println!("s4={}", s4);
    println!("s5={}", s5);
    println!("s6={}", s6);
    // println!("s3={}", s3); //s3 has been move before here, so s3 is invalid here; compile error
    //

    let str_hello_russia = "Здравствуйте";
    // let str_hello_russia_idx1 = &str_hello_russia[0]; //compile error
    // println!("str_hello_russia_idx1={}", str_hello_russia_idx1);
    let str_hello_russia_slice1 = &str_hello_russia[0..4]; //string index?
    println!(
        "str_hello_russia={}, str_hello_russia_slice1={}",
        str_hello_russia, str_hello_russia_slice1
    );

    let str_hello = "hello";
    let str_hello_idx1 = &str_hello[0..1]; //[0, 1), it is [0], string can only access by slice! I don't like this!
    println!("str_hello_idx1={}", str_hello_idx1);

    let a1 = [1, 2, 3, 5];
    println!("a1[0]={}, a1.len={}", a1[0], a1.len());
    println!("a1[last]={}", a1[a1.len() - 1]);
}

fn process_string1(s: &String) -> String {
    let mut snew = String::new();
    snew.push_str(s); //s is already a reference here
    snew.push_str("_ending");
    return snew;
}

fn process_string2(s: String) -> String {
    let mut snew = String::new();
    snew.push_str(&s); //push_str only accept reference as its param
    snew.push_str("_ending");
    return snew;
}

fn main() {
    println!("main; -begin");

    test2();

    println!("main; -end");
}
