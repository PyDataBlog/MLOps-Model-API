mod areas;
mod area_frame_allocator;
mod paging;
mod info;

use self::paging::{PAGE_SIZE, PhysicalAddress};
use self::area_frame_allocator::{AreaFrameAllocator};
use spin::{Once, Mutex, MutexGuard};

pub use self::paging::{Page, VirtualAddress};
pub use self::paging::entry::{EntryFlags};

pub const KERNEL_OFFSET: usize = 0o177777_776_000_000_000_0000;

static MEMORY_CONTROLLER: Once<Mutex<MemoryController>> = Once::new();

pub struct MemoryController {
    active_table: paging::ActivePageTable,
    frame_allocator: AreaFrameAllocator,
}

impl MemoryController {
    pub fn map(&mut self, page: Page, flags: EntryFlags) {
        self.active_table.map(page, flags, &mut self.frame_allocator);
    }
    //TODO impl
}

pub fn controller<'a>() -> MutexGuard<'a, MemoryController> {
    MEMORY_CONTROLLER.try().expect("Memory not yet initialized").lock()
}

//TODO Figure out if we want Copy and Clone on this
#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Clone, Copy)]
pub struct Frame {
    number: usize,
}

impl Frame {
    fn containing_address(address: PhysicalAddress) -> Frame {
        Frame { number: address.get() / PAGE_SIZE }
    }

    fn start_address(&self) -> PhysicalAddress {
        PhysicalAddress::new(self.number * PAGE_SIZE)
    }

    fn range_inclusive(start: Frame, end: Frame) -> FrameIter {
        FrameIter {
            start: start,
            end: end,
        }
    }
}

struct FrameIter {
    start: Frame,
    end: Frame,
}

impl Iterator for FrameIter {
    type Item = Frame;

    fn next(&mut self) -> Option<Frame> {
        if self.start <= self.end {
            let frame = self.start.clone();

            self.start.number += 1;
            
            Some(frame)
        } else {
            None
        }
    }
}

pub trait FrameAllocator {
    fn allocate_frame(&mut self) -> Option<Frame>;
    fn deallocate_frame(&mut self, frame: Frame);
}

/// Align downwards. Returns the greatest x with alignment `align`
/// so that x <= addr. The alignment must be a power of 2.
pub fn align_down(addr: usize, align: usize) -> usize {
    if align.is_power_of_two() {
        addr & !(align - 1)
    } else if align == 0 {
        addr
    } else {
        panic!("`align` must be a power of 2");
    }
}

/// Align upwards. Returns the smallest x with alignment `align`
/// so that x >= addr. The alignment must be a power of 2.
pub fn align_up(addr: usize, align: usize) -> usize {
    align_down(addr + align - 1, align)
}

pub fn init(boot_info: &::bootinfo::BootInfo) {
    println!("Initializing Memory");
    areas::init(boot_info);
    info::init(boot_info);

    let mut frame_allocator = area_frame_allocator::AreaFrameAllocator::new(PhysicalAddress::new(0), info::kernel().end_physical());

    let active_table = paging::remap(&mut frame_allocator);

    MEMORY_CONTROLLER.call_once(|| {
        Mutex::new(MemoryController {
            active_table,
            frame_allocator,
        })
    });
}