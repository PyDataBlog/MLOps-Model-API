extern crate rustc_serialize;

use std::fs::File;
use std::io::prelude::*;
use rustc_serialize::hex::{FromHex, ToHex};

fn xor_hex_strings(str1: &str, str2: &str) -> Option<String> {
    if str1.len() != str2.len() {
        None
    } else {
        let bytes1 = str1.from_hex().expect("could not parse hex string");
        let bytes2 = str2.from_hex().expect("could not parse hex string");

        let mut vec = Vec::new();
        for (a, b) in bytes1.iter().zip(bytes2) {
            vec.push(a ^ b);
        }

        Some(vec.to_hex())
    }
}

fn score_phrase(phrase: &str, score: &mut f64) {
    for letter in phrase.to_lowercase().chars() {
        match letter {
            'a' => *score += 8.167,
            'b' => *score += 1.492,
            'c' => *score += 2.782,
            'd' => *score += 4.253,
            'e' => *score += 12.702,
            'f' => *score += 2.228,
            'g' => *score += 2.015,
            'h' => *score += 6.094,
            'i' => *score += 6.966,
            'j' => *score += 0.153,
            'k' => *score += 0.772,
            'l' => *score += 4.025,
            'm' => *score += 2.406,
            'n' => *score += 6.749,
            'o' => *score += 7.507,
            'p' => *score += 1.929,
            'q' => *score += 0.095,
            'r' => *score += 5.987,
            's' => *score += 6.327,
            't' => *score += 9.056,
            'u' => *score += 2.758,
            'v' => *score += 0.978,
            'w' => *score += 2.360,
            'x' => *score += 0.150,
            'y' => *score += 1.974,
            'z' => *score += 0.074,
            _ => *score -= 20.0,
        }
    }
}

fn find_best_phrase(phrases: &[String]) -> String {
    let mut score_vec = vec![0.0; phrases.len()];
    for (phrase, mut score) in phrases.iter().zip(score_vec.iter_mut()) {
        score_phrase(phrase, &mut score);
    }
    let max = score_vec.iter().map(|x| *x as i64).max().unwrap();
    let pos = score_vec.iter().position(|x| (*x as i64) == max).unwrap();

    phrases[pos].to_string()
}

fn find_phrase(phrase: &str) -> Option<String> {
    let mut vec = Vec::new();
    for i in 0..u8::max_value() {
        let v = vec![i; phrase.len() / 2]; // Divide by 2 since 2 characters is 1 u8
        match xor_hex_strings(phrase, v.to_hex().as_str()) {
            Some(x) => match String::from_utf8(x.from_hex().unwrap()) {
                Ok(y) => vec.push(y),
                Err(_) => continue,
            },
            None => continue,
        }
    }

    if vec.is_empty() {
        None
    } else {
        Some(find_best_phrase(&vec))
    }
}

fn main() {
    let mut input = File::open("4.txt").expect("file not found");

    let mut content = String::new();
    input.read_to_string(&mut content).expect("couldn't read file");

    let lines: Vec<&str> = content.lines().collect();
    let potential_phrases: Vec<String> = lines.iter().map(|x| find_phrase(x)).filter(|x| x.is_some()).map(|x| x.unwrap()).collect();

    println!("{}", find_best_phrase(&potential_phrases));
}
