create or replace PROCEDURE PROC_SEPARAR_NOMBRES (
  TABLA IN VARCHAR2, 
  P1 IN VARCHAR2,
  P2 IN VARCHAR2 DEFAULT NULL,
  P3 IN VARCHAR2 DEFAULT NULL,
  APELLIDOS IN BOOLEAN DEFAULT FALSE, 
  ACTUALIZAR IN BOOLEAN DEFAULT FALSE)
AS
  AUX NUMBER := 0;
  V_LIMIT NUMBER := 1000;
  V_REGEXP VARCHAR2(200) := '(((DE LAS|DE LOS|DE LA|DEL|DE)+\s+?){0,1}\w+)+?';
  
  TYPE MigCurTyp IS REF CURSOR;
  mi_cursor MigCurTyp;
  
  CADENA VARCHAR2(500) := NULL;
  V_ROWID ROWID;
  N1 VARCHAR2(100);
  N2 VARCHAR2(100);
  A1 VARCHAR2(100);
  A2 VARCHAR2(100);
  EXP_NOMBRES VARCHAR2(100) := P1;
BEGIN
  -- CONSTRUCCION DE LA CADENA DE NOMBRES
  IF P2 IS NOT NULL THEN EXP_NOMBRES := EXP_NOMBRES || ' || '' '' || ' || P2 ; END IF;
  IF P3 IS NOT NULL THEN EXP_NOMBRES := EXP_NOMBRES || ' || '' '' || ' || P3; END IF;
  
  DBMS_OUTPUT.PUT_LINE(EXP_NOMBRES);
  -- SE CREAN LOS CAMPOS PARA ALMACENAR LOS NOMBRES SEPARADOS
  -- NOTESE QUE SI LA TABLA YA LOS TIENE, EL PARAMETRO ACTUALIZAR DEBE SER TRUE
  IF actualizar = FALSE THEN
    EXECUTE IMMEDIATE 'ALTER TABLE ' || TABLA || ' ADD (NOMBRE_1 VARCHAR2(80))';
    EXECUTE IMMEDIATE 'ALTER TABLE ' || TABLA || ' ADD (NOMBRE_2 VARCHAR2(80))';
    EXECUTE IMMEDIATE 'ALTER TABLE ' || TABLA || ' ADD (APELLIDO_1 VARCHAR2(80))';
    EXECUTE IMMEDIATE 'ALTER TABLE ' || TABLA || ' ADD (APELLIDO_2 VARCHAR2(80))';
  END IF;
  
  DBMS_OUTPUT.PUT_LINE('SELECT ROWID, UPPER(' || EXP_NOMBRES || ') NOMBRES  FROM ' || TABLA);
  
  OPEN MI_CURSOR FOR
    'SELECT ROWID, UPPER(' || EXP_NOMBRES || ') NOMBRES  FROM ' || TABLA;
  FETCH MI_CURSOR
  INTO V_ROWID, CADENA;
  
  WHILE mi_cursor%found
  LOOP
      N1 := NULL;
      N2 := NULL;
      A1 := NULL;
      A2 := NULL;
      
      IF REGEXP_SUBSTR(CADENA, V_REGEXP, 1, 4) IS NULL THEN
        N1 := REGEXP_SUBSTR(CADENA, V_REGEXP, 1, 1);
        A1 := REGEXP_SUBSTR(CADENA, V_REGEXP, 1, 2);
        A2 := REGEXP_SUBSTR(CADENA, V_REGEXP, 1, 3);
      ELSIF REGEXP_SUBSTR(CADENA, V_REGEXP, 1, 3) IS NULL THEN
        N1 := REGEXP_SUBSTR(CADENA, V_REGEXP, 1, 1);
        A1 := REGEXP_SUBSTR(CADENA, V_REGEXP, 1, 2);
      /**
        LOS DOS SIGUIENTES CASOS SON EN CASO QUE LA PERSONA TENGA TRES NOMBRES
        ESTA PENDIENTE POR VERIFICAR
      */
      ELSIF REGEXP_SUBSTR(CADENA, V_REGEXP, 1, 5) IS NOT NULL THEN
        N1 := REGEXP_SUBSTR(CADENA, V_REGEXP, 1, 1);
        N2 := REGEXP_SUBSTR(CADENA, V_REGEXP, 1, 2) || ' ' || REGEXP_SUBSTR(CADENA, V_REGEXP, 1, 3);
        A1 := REGEXP_SUBSTR(CADENA, V_REGEXP, 1, 4);
        A2 := REGEXP_SUBSTR(CADENA, V_REGEXP, 1, 5);
      ELSIF REGEXP_SUBSTR(CADENA, V_REGEXP, 1, 6) IS NOT NULL THEN
        N1 := REGEXP_SUBSTR(CADENA, V_REGEXP, 1, 1);
        N2 := REGEXP_SUBSTR(CADENA, V_REGEXP, 1, 2) || ' ' || REGEXP_SUBSTR(CADENA, V_REGEXP, 1, 3)  || ' ' || REGEXP_SUBSTR(CADENA, V_REGEXP, 1, 4);
        A1 := REGEXP_SUBSTR(CADENA, V_REGEXP, 1, 5);
        A2 := REGEXP_SUBSTR(CADENA, V_REGEXP, 1, 6);
      ELSE
        N1 := REGEXP_SUBSTR(CADENA, V_REGEXP, 1, 1);
        N2 := REGEXP_SUBSTR(CADENA, V_REGEXP, 1, 2);
        A1 := REGEXP_SUBSTR(CADENA, V_REGEXP, 1, 3);
        A2 := REGEXP_SUBSTR(CADENA, V_REGEXP, 1, 4);
      END IF;
      
      /* para mantener consistencia, si es una actualizacion se inicializan los campos para tener una actualizacion limpia sin datos anteriores */
      IF ACTUALIZAR = TRUE THEN
        EXECUTE IMMEDIATE 
          'UPDATE ' || TABLA || ' SET
            NOMBRE_1 = NULL, NOMBRE_2 = NULL, APELLIDO_1 = NULL, APELLIDO_2 = NULL WHERE ROWID = ''' || V_ROWID || '''';
      END IF;
      
      IF APELLIDOS = TRUE THEN
        EXECUTE IMMEDIATE 
          'UPDATE ' || TABLA || ' SET
            NOMBRE_1 = ''' || UPPER(A1) || ''', NOMBRE_2 = ''' || UPPER(A2) || ''', APELLIDO_1 = ''' || UPPER(N1) || ''', APELLIDO_2 = ''' || UPPER(N2) || ''' WHERE ROWID = ''' || V_ROWID || '''';
      ELSE
        EXECUTE IMMEDIATE 'UPDATE ' || TABLA || ' SET
            NOMBRE_1 = ''' || UPPER(N1) || ''', NOMBRE_2 = ''' || UPPER(N2) || ''', APELLIDO_1 = ''' || UPPER(A1) || ''', APELLIDO_2 = ''' || UPPER(A2) || ''' WHERE ROWID = ''' || V_ROWID || '''';
      END IF;
        
    AUX:=AUX+1;
    IF AUX = V_LIMIT THEN
      AUX := 0;
      COMMIT;
    END IF;
   
    FETCH MI_CURSOR
    INTO V_ROWID, CADENA;
  END LOOP;
  COMMIT;

END PROC_SEPARAR_NOMBRES;