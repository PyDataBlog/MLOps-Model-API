---
title: 算法学习 - dijkstras 
layout: post
date: 2016-12-14 12:47
tag:
- algorithms
- golang
- dijkstras
blog: true
---

#### 概述
![Sort Algorithms]({{ site.url }}/assets/images/algorithms-001.png)  

dijstras 主要的目标是高效得找到两个点之间的最短路径。

#### 算法实现的步骤描述（变量名下面 golang 实现）

1. 创建一个数组（dists），用来保存起点(包含)到每个点的最短距离，初始状态是空。
2. 初始化数组，起点到所有点的值都设为 Infinite (实际是 math.MaxInt32)，把起点到起点是0。traces (也可以是 map) 记录我们已经得到的最小距离的点。
3. 如果 graph 的点存在，重复下面部署。  
	a. 找到 dists 最小的值，且 traces 不存在的点 (u)  
	b. 把 u 加入 traces  
	c. 计算所有点到 u 的距离，如果不在 traces 中，且 dists[u] + u 到点(j)的距离小于 dists[j]，更新 dists 的值。  
4. 得到起点到所有点的最短距离，如果只是到特定的点，找到则退出。


![Sort Algorithms]({{ site.url }}/assets/images/dijkstra.gif)  


#### dijkstras 的 Golang 实现

```
package main

import (
	"log"
	"math"
)

func main() {
	graph := [][]int{
		{0, 4, 0, 0, 0, 0, 0, 8, 0},
		{4, 0, 8, 0, 0, 0, 0, 11, 0},
		{0, 8, 0, 7, 0, 4, 0, 0, 2},
		{0, 0, 7, 0, 9, 14, 0, 0, 0},
		{0, 0, 0, 9, 0, 10, 0, 0, 0},
		{0, 0, 4, 14, 10, 0, 2, 0, 0},
		{0, 0, 0, 0, 0, 2, 0, 1, 6},
		{8, 11, 0, 0, 0, 0, 1, 0, 7},
		{0, 0, 2, 0, 0, 0, 6, 7, 0},
	}
	dijkstras(graph, 0)
}

func dijkstras(graph [][]int, src int) {
	var (
		dists   = make([]int, len(graph))
		traces = make([]bool, len(graph))
	)
	for i, _ := range graph {
		dists[i] = int(math.MaxInt32)
	}

	dists[src] = 0
	for _, points := range graph {
		u := minDistance(dists, traces)
		traces[u] = true
		for j, _ := range points {
			if !traces[j] && graph[u][j] != 0 && dists[u]+graph[u][j] < dists[j] {
				dists[j] = dists[u] + graph[u][j]
			}
		}
	}

	for i, j := range dists {
		log.Println(i, j)
	}
}

func minDistance(dists []int, traces []bool) int {
	var (
		min   int = int(math.MaxInt32)
		index int = -1
	)
	for i, dist := range dists {
		if !traces[i] && dist < min {
			min = dist
			index = i
		}
	}
	return index
}
```

#### 相关资源

http://www.geeksforgeeks.org/greedy-algorithms-set-6-dijkstras-shortest-path-algorithm/  
https://en.wikipedia.org/wiki/Dijkstra's_algorithm  
