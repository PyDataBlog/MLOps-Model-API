Request for Help
===================

Before we get started, we should say that we know Markdown is not the best way to generate a user guide for a system as complex as this. See 
[the open ticket to make this better.](https://github.com/RobertFischer/AWSDeployment/issues/2) We are very open to contributions on this front.

Overview
==========

The goal of the system is that a user should be able to come up with an AWS deployment configuration, specify it declaratively within Groovy scripts, 
and then execute those scripts to bring that configuration to life in AWS. Errors in the configuration should be reported with clear messaging
containing meaningful calls to action. 

Furthermore, the user should be able to build off of those scripts, adding new scripts to create new deployments leveraging the produced artifacts, 
migrating the produced artifacts through those executions, and undeploying the produced artifacts using the same script.

How It Works in Theory
=========================

The system is built around a *Deployment Plan*. The deployment plan is the entire understanding of the intended deployment, including the order of operations
that would arrive at the intended deploment, as well as the artifacts that are produced inside the intended deployment.

Specifying the Deployment Plan
---------------------------------

The deployment plan is specified by *deployment scripts*, which are usually Groovy files. A deployment script is responsible for 
telling the plan how to manage one or more *artifacts*, which are any product in AWS (eg: an EC2 instance, an ELB, an S3 bucket, etc.). 
The deployment plan is executed in one of two modes: *deploy* mode or *undeploy* mode.  These modes determine which kinds of actions 
are executed.  There are three kinds of actions a script can specify: *deploy* actions, *migrate* actions, and *undeploy* actions.  
Within an action, the user has access to existant artifacts, to the raw AWS Java SDK, to helper functions, and to the full power of the 
Groovy language and ecosystem. The user can basically do whatever they would like. Each of the actions, however, have slightly different
contexts and semantics, determined by the execution mode.


Executing the Plan in Deploy Mode
------------------------------------

The goal of executing the plan in deploy mode is to deploy the plan: we are creating new artifacts in AWS. When executing in deploy mode,
the plan is executed as follows: for each script, the system waits until the dependent scripts have executed, and then checks for the artifacts 
that the script knows how to generate. 

If none of the artifacts exist, the *deploy* actions are executed. These actions execute within the deployment state, which is the collection
of all the artifacts produced by the dependent scripts. The action executions result in the create of new artifacts, which can be consumed by 
later actions and later scripts.

If all the artifacts exist, the *migrate* actions of the script are executed. These actions execute within the deployment state, and that
state includes all the artifacts produced by the previous *deploy* run of this script. No new artifacts are produced by this, although
existing artifacts can be modified or even replaced. The intent is for users to make modifications that might have to be done during each 
deployment (eg: updating `yum`, etc.)

If only some but not all of the artifacts exist, the *undeploy* actions of the script are executed, followed by the *deploy* actions. The 
undeploy actions execute within the deployment state, with mock versions for any artifacts that do not exist. The deploy action are then 
executed as above.

Executing the Plan in Undeploy Mode
-------------------------------------

The goal of executing the plan in undeploy mode is to undeploy the plan: we are dismantling existing artifacts in AWS. When executing in 
undeploy mode, the plan is executed as follows: for each script, the system waits until scripts dependent on it have been executed, and then
checks for the artifacts that this script had generated through a deploy-mode run.

If none of the artifacts exist, no actions are executed.

If only some but not all of the artifacts exist, the *undeploy* actions of the script are executed, followed by the *deploy* actions. The 
undeploy actions execute within the deployment state, with mock versions for any artifacts that do not exist. 

How It Works in Practice (CLI Version)
======================================

*TBI* (To Be Implemented)

How It Works in Practice (Embedded Version)
==============================================

The user constructs an instance of `AWSDeploymentPlan` by passing in a collection of `AWSDeploymentScripts`. The `AWSDeploymentPlan` 
is passed into an `AWSDeployer` along with the AWS credentials instance. From there, call `deploy()`, `migrate()`, or `undeploy()`.
