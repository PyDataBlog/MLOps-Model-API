# Node.js

`JavaScript` 最初是只能在瀏覽器 ( 前端 ) 執行的語言，但在 `Node.js` 出現之後，`JavaScript` 也可以在伺服器 ( 後端 ) 使用。

- Node.js 官方網站：<https://nodejs.org/en/>
- Node.js 官方文檔：<https://nodejs.org/en/docs/>

## 目錄

- [1. 安裝](#安裝)
- [2. 指令](#指令)
  - [node](#node)
  - [npm](#npm)
- [3. 編程](#編程)
  - [模塊](#模塊)
  - [進程](#進程)
- [附錄 - 透過 Chrome 開發者工具偵錯 Node.js 程式](#偵錯)

## 安裝

Node.js 官方下載點： <https://nodejs.org/en/download/>

![nodejs-download](images/nodejs-download.png)

如果沒有特殊需求的話，都按照默認設定安裝即可。

:arrow_up: [回目錄](#目錄)

## 指令

安裝完成 Node.js 之後，會多出 [`node`](#node) 以及 [`npm`](#npm) 指令可以使用。

:arrow_up: [回目錄](#目錄)

## node

`node` 指令是 node.js 中用來執行 javascript 檔案的指令。假設我現在有一個檔案 ( `hello-world.js` )，其內容如下：

```js
console.log('hello world');
```

註：`console.log()` 相當於是 C 的 `printf()`。

使用的方法很簡單，給它檔案名稱就可以了：

```sh
node hello-world.js
```

將會得到結果：

```
hello world
```

如果你覺得每次執行都要透過 `node` 指令執行太麻煩的話，你可以在程式的開頭加上，指定要用 Node.js 來啟動的訊息：

```js
#!/bin/env node
```

這樣一來，你可以直接以檔案名稱來執行了，如：

```sh
./hellow-world.js
```

將會得到一樣的結果：

```
hello world
```

當然，你也可以傳遞參數進去：

```sh
./hellow-world.js 123 456
```

有關參數的用法請參閱 [Node.js 編程 - 進程](#進程)。

更多的 `node` 指令用法請參閱 [Node.js 官方文檔 - CLI](https://nodejs.org/api/cli.html)。

:arrow_up: [回目錄](#目錄)

## npm

有關 npm 的指令請參閱 [npm 指令](../npm#指令)。

:arrow_up: [回目錄](#目錄)

## 編程

在 Node.js 中，是以 JavaScript 作為使用語言，依照各版本的不同而與 ECMAScript 的[支援進度](http://node.green/)有所不同。

以下介紹兩個 Node.js 編程中，不可或缺的兩個部分：[模塊](#模塊)、[進程](#進程)。

:arrow_up: [回目錄](#目錄)

## 模塊

Node.js 程式以模塊 ( module ) 作為單位，每一個檔案都是一個模塊，模塊間的通訊採用的是 CommonJS 規範。

在瀏覽器當中，全局對象是 `window`，而在 Node.js 中，全局對象是 `module`。

註：全局對象指的是最頂層的物件，比如在瀏覽器中的 `location`，它實際上指的是 `window.location`，但因為 `window` 是全局對象，所以可以直接縮寫為 `location`。

CommonJS 使用 `require` 和 `exports` 來進行模塊間的輸入與輸出。

`require` 和 `exports` 都是 `module` 上的一個屬性，因為 `module` 是全局對象所以可以縮寫。

`require` 是用來輸入，而 `exports` 則是用來輸出。

假設我有兩個檔案：

- output.js

  ```js
  exports.a = 123;
  ```

- input.js

  ```js
  var a = require('./output.js').a;
  console.log('a from output.js is: ' + a);
  ```

output.js 輸出了一個變數 `a`，其值為 `123`；而 input.js 從 output.js 輸入了一個變數 `a` 並且把它印了出來。現在如果我們執行了 input.js 的話，將會得到：

```
a from output.js is: 123
```

任何對 `module.exports` 的修改都會反映在該模塊的輸出上，因此你也可以把整個 `exports` 改寫掉：

- output.js

  ```js
  module.exports = 123;
  ```

- input.js

  ```js
  var a = require('./output.js');
  console.log('a from output.js is: ' + a);
  ```

將會得到一樣的結果。

對於 `require` 函數來說，給定的目標如果是一個相對路徑 ( 如：`./xxx.js` ) 的話，它會依照那個路徑去讀取模塊，而如果目標只是一個名字的話 ( 如 `example` )，它將會當作外部模塊 ( `node_modules` ) 去讀取，讀取的目標則由該外部模塊的描述檔 package.json 中的 main 欄位來決定。

假設我現在有一個外部模塊 example：

- ./node_modules/example/package.json

  ```json
  {
    "name": "example",
    "version": "1.0.0",
    "main": "index.js"
  }
  ```

- ./node_modules/example/index.js

  ```js
  exports.i_am_external_module = true;
  ```

而我的主程式長這樣：

- ./test.js

  ```js
  var isExternalModule = require('example').i_am_external_module;
  console.log('Is "example" an external module? ' + isExternalModule);
  ```

執行它將會得到：

```
Is "example" an external module? true
```

更多有關模塊的用法，請參閱 [Node.js 官方文檔 - modules](https://nodejs.org/dist/latest/docs/api/modules.html)。

:arrow_up: [回目錄](#目錄)

## 進程

進程 ( process ) 指的是執行 Node.js 程式時，和環境有關的各種資料。

- 參數

  在 Node.js 中，執行程式時如果帶有參數的話：

  ```sh
  node example.js 123 456
  ```

  你可以透過 `process.argv` 來取得這些參數：

  ```js
  console.log(process.argv);
  ```

  執行後將會得到：

  ```
  [ 'C:\\Program Files\\nodejs\\node.exe',
    'C:\\Users\\Ika\\Desktop\\nodejs-process-example\\example.js',
    '123',
    '456' ]
  ```

  因此，使用 `process` 可以很輕易的寫出 Node.js 的命令列程式。

- 環境變數

  透過 `process.env` 可以取得當前執行的環境變數，例如 `PATH`：

  ```js
  console.log(process.env.PATH);
  ```

  以 node 執行 ( `node example.js` )：

  ```
  C:\Program Files\nodejs;
  ...
  ```

  透過 npm 腳本執行 ( `npm run test`, test script: `node example.js` )：

  ```
  C:\Users\Ika\Desktop\nodejs-process-example\node_modules\.bin;
  C:\Program Files\nodejs;
  ...
  ```

  可以發現，透過 npm 腳本執行的話，環境變數會自動加上 `node_modules` 資料夾。

  另外，所有存入 process.env 的變數都會自動轉換成字串，因此如果你存入其他類型的數值的話：

  ```js
  process.env.TEST = true;
  ```

  當你取出的時候：

  ```js
  console.log('process.env.TEST: ' + JSON.stringify(process.env.TEST));
  ```

  將會得到轉換成字串的值：

  ```
  process.env.TEST: "true"
  ```

:arrow_up: [回目錄](#目錄)

## 偵錯

只要在執行 node 程式的時候加上 `--inspect --debug-brk` 選項即可，如：

```sh
node --inspect --debug-brk ./test.js
```

執行之後 Node.js 將會告訴你要在 Chrome 上打開這個網址以進行偵錯：

```
Debugger listening on port 9229.
Warning: This is an experimental feature and could change at any time.
To start debugging, open the following URL in Chrome:
    chrome-devtools://devtools/remote/serve_file/XXXXX/inspector.html?experiments=true&v8only=true&ws=127.0.0.1:9229/YYYYY
```

你只要用 Chrome 打開它給的網址就會進入偵錯模式了：

![nodejs-debug](./images/nodejs-debug.png)

:arrow_up: [回目錄](#目錄)
