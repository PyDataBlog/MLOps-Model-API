# 0x00 - x86 | Assemblye Giris

```c++
---
layout: post
title: "0x00 - x86 | Assemblye Giris"
date: 30-05-2016 02:03:00
comments: true
categories:
    - blog
tags:
    - x86
    - Assembly
    - Linux
    - Programming
    - Reverse Engineering
    - Exploit Development
    - Shellcode
---
```

Selamlar bu blog yazımızda temel x86 assemblyden bahsedip temeli attiktan sonra ilerleyen zamanlarda ogrendigimiz bilgilerle **shellcode** gelistirip, **exploit development** mevzularina dalicaz.

# Assembly nedir ? 

Assembly low level bir dil olup gunumuzde cogu programcinin, muhendisin ogrenmeye pek hevesli olmadigi bir dildir. Gunumuzde bu dil ile nadiren program gelistirilir ve cogunlukla malware analizi/gelistirilmesi, exploit development, cracking ve donanim ile iletisim kurulacagi zaman kullanilmaktadir. Assembly zor bir dil olmasina karsin sanildiginin aksine eglenceli ve islemci ile bire bir hasir nesir oldugu icin asiri hizli bir dil olup bilgisayar uzerinde tam hakimiyet saglanabilir hatta bilgisayara takla bile attirilabilir.

Assembly islemciden islemciye degisen bir dildir **intel** islemcilerde farkli **arm** islemcilerde farklidir. Aslinda mantik ayni olsada degisen sadece registerlar ve bazi instructionlar. Biz **intel** islemciler uzerinden ogrenmeye basliyacaz. Tabi assembly sadece islemciden islemciye degismiyor assembly **intel** islemciler icinde bile degisebiliyor yani **x86** mimarisinde farkli **x64** mimarisinde de bazi farkliliklar gozukmekte. Biz **x86** mimarisi icin assembly ile devam edicez. 

Assembly'nin birde yazilis sekilleri var. Bunlar **Intel** ve **AT&T** olmak uzere ikiye ayriliyorlar. Asagida her iki yazim turununde bir ornegi bulunmakta **AT&T** tarzi cogunlukla **Linux** sistemlerde kullaniliyor tabi bu **Linux**'da **Intel** tarziyla yazamiyoruz anlamina gelmiyor. Biz **Intel** tarzini kullanicaz.


**AT&T** tarzinda once kaynak sonra hedef gosterilir. Kaynak **$** ile isaretlenirken hedef **%** ile belirtilir.
```nasm
# AT&T tarzi
movl  $0x3,%ax
movl  $0xff,%ebx
int   $0x80
```

**Intel** tarzinda ise **AT&T**'nin tam tersi once hedef sonra kaynak gosterilir. **AT&T**'de ki gibi **$,%** isaretleri yoktur sadedir.
```nasm
; Intel tarzi
mov  ax,0x3
mov  ebx,0xff
int 0x80
```


Ilk defa assembly ogrenmeye calisanlar icin yukarida ki komutlari anlamlandirmak azda olsa zor olacaktir zaten oradaki amac kodlari anlamlandirabilmek degil yazilis bicimlerine ornek vermek. 


# Registerlar

Registerlar islemci uzerinde bulunan hafiza alanlaridir ve iclerinde **Genel Amacli Kaydediciler**, **Ozel Amacli Kaydediciler**, **Bolum Kaydediciler**, **Durum Kaydediciler**, **XMM** ve **MMX** diye ayrilip gidiyorlar. Biz **Genel Amacli Kaydediciler**, **Ozel Amacli Kaydediciler**, **Bolum Kaydedicileri** ve **Durum Kaydedicileri** ni gorecez **XMM** ve **MMX** registerlariyla suanlik isimiz yok.


Alttaki gorselde genel amacli kaydediciler ve iki adet ozel amacli kaydedici bulunmakta.

![registers](https://i.hizliresim.com/N1ko95.png)


Yukarida ki resimde genel amacli registerların hangileri oldugu yazilmis biz bunlari daha detaylı bir sekilde ele alalim.

Genel amacli registerlarimiz;

  * EAX
  * EBX
  * ECX
  * EDX
  * ESI
  * EDI
  
Ozel Amacli Registerlarimiz;

  * ESP
  * EBP
  * EIP (Bu register bazi kaynaklarda ayri segment olarak islenir)

Bolum Kaydedicilerimiz;

  * SS (Stack Segment)
  * CS (Code Segment)
  * DS (Data Segment)
  * FS,GS,ES (Extra Segments)

Durum Kaydedicilerimiz;

  * EFLAGS
    * CF (Carry Flag)
    * PF (Parity Flag)
    * AF (Adjust Flag)
    * ZF (Zero Flag)*
    * SF (Sign Flag)
    * TF (Trap Flag)
    * IF (Interruption Flag)
    * DF (Direction Flag)
    * OF (Overflow Flag)
    * NT (Nested Task flag)
    * RF (Resume Flag)
    * ID (Identification Flag)

<dl>
  <dt>Genel Amacli Kaydediciler</dt>
</dl>

Yukarida listeledigim ve gorselde gordugunuz gibi 6 adet genel amacli registerimiz mevcut. Gorsel uzerinden ilerlersek genel amacli registerlarimizin kendi icerisinde parcalandigini goruyoruz. **EAX** registerini ele alalim. **EAX** registerinin basindaki **E** harfi **Extended** anlamina geliyor turkce mealiyle **Genisletilmis** veya **Uzatilmis**. **EAX** 32 bitlik bir register olmasina karsin biz bu 32 bitlik registerin 16 bitlik kismina ve 8 bitlik kisimlarina erisebiliyoruz.

  * **EAX** = 32 bit
    * **AX** = 16 Bit
      * **AH** = 8 Bit (Burada ki **H** harfi **Hight** anlamina geliyor)
      * **AL** = 8 Bit (Burada ki **L** harfi **Low** anlamina geliyor)

```nasm
|63..32|31..16|15-8|7-0|
               |AH.|AL.|
               |AX.....|
       |EAX............|
|RAX...................|
```

Genel amacli registerlarin kullanim amaclari;

  * **EAX** = Accumulator register diye gecer ve aritmetik islemlerin sonuclari, giris/cikis erisimleri, sistem cagri numaralari, fonksiyon geri donus degerlerini tutan registerimizdir.

  * **EBX** = Base register diye gecer. Bu registerimiz henuz gormedigimiz **Bolum Register**larinda gorecegimiz **DS** bolumundeki veriler icin taban adresini ayni zamanda bazi intteruplarin geri donus adresini ve sistem cagrisi yapilacaksa ilk parametreyi alir.

  * **ECX** = Counter register diye gecer. Bir islemin kac kez calistigina ait degeri tutar ayni zamanda donguler ve string islemleri icin kullanilmaktadir. Sistem cagrisi yapilacaksa ikinci parametreyi tutar. (__fastcall'da isler degisiyor buraya takilmayin bu parantez icinde yazilanlar az cok asm bilenler icin)

  * **EDX** = Data register diye gecer. Giris cikis islemlerinde kullanilir. Sistem cagrisi yapilacaksa ucuncu parametreyi alir ayrica **EAX** registerinin bir nevi yardimcisidir soyleki **EAX** registerinin 64 bitlik bir rol oynamasina yardimci olur.

  * **ESI** = Source index register diye gecer. **DS** segmentindeki stringlerin veya bellek dizelerini kopyalarken kullanilan ayni zamanda **REPZ-** sinifina ait tum instructionlarinin ozellikle kullandigi, string islemlerinde verinin okundugu adresi tutar.

  * **EDI** = Destination index register diye gecer. String islemlerinde **ESI** ile calisir ve string islemlerinde hedefin adresini tutar.

<dl>
  <dt>Ozel Amacli Kaydediciler</dt>
</dl>

Ozel amacli kaydedicilerimizde genel amacli registerlarimiz gibi 32 bittir. Baslarindaki **E** harfi **Extended** anlamini tasir. 

Ozel amacli registerlarin kullanim amaclari;

  * **ESP** = Stack pointer diye gecer. **DS** segmenti gibi henuz gormedigimiz **SS** segmentindeki en ustte bulunan verinin adresini tutar.

  * **EBP** = Base pointer diye gecer. **SS** segmentindeki en altta bulunan verinin adresini tutar.

  * **EIP** = Instruction pointer diye gecer. Calistirilacak bir sonraki instructionun adresini tutar. Sadece okunabilir bir alandir yani dogrudan degistiremezsiniz burayi. Ileride exploit development mevzularinda cogu isimiz bu register ile olacak ve exploit development ile ugrasanlarin en samimi dostudur, hukmedebildikten sonra.

<dl>
  <dt>Bolum Kaydediciler</dt>
</dl>

Bolum kaydedicilerimiz, genel amacli kaydediciler ve ozel amacli kaydedicilerin aksine 16 bitlik kaydedicilerdir.

  * **SS** = Stack segment diye gecer. Iki uc cumle ile ozetlenmeyecek kadar onemli oldugu icin alttaki #Stack basligi altinda inceleyecez.

  * **FS**, **GS**, **ES** = Bu segmentler extra segmentlerimizdir. Kullanicinin buralarla pek isi olmaz bu segmentler aslinda isletim sistemlerine aittir.

  * **CS** = Code segment diye gecer. Programin calistirilabilir kodlarinin oldugu kisimdir. Buradaki kodlarin degistirilmesi programin crash olmasina neden olabilir. Patchleme islemleri bu alanda yapilir ve **.text** olarakda gecer.

  * **DS** = Data segment diye gecer. Bu segment, deger atanmis global ve static degiskenlerin bulundugu alandir.

```c++
char cNick[] = "x-t0xid";
int iDeg = 1337;
```

Bunlarin disinda **BSS** ve **Heap** segmentimizde mevcut hemen onlardanda bahsedelim.

  * **BSS** = **BSS** in eski bir assembler tarafindan acilimi **Block Started by Symbol** olarak gecmekte. **BSS**, **DS** in aksine henuz deger atanmamis degiskenlerin tutuldugu alandir. 


```c++
int32_t iJoje;
extern char __Joje[];
```


  * **Heap** = Heap segmenti **DS** ve **BSS** segmentinin bitisinde baslar. Bu alana **malloc**, **calloc**, **HeapCreate** gibi fonksiyonlar yardimi ile ulasilmaktadir. 

```c++
char *cHmss;
cHmss = (char *)malloc(0xa);
```

<br/>
<center><img src="https://i.hizliresim.com/Dd3A86.jpg" alt="Drawing" style="width: 200px;"/></center>
<br/>


<dl>
  <dt>Durum Kaydediciler (EFLAGS)</dt>
</dl>

Durum kaydedicilerimiz 32 bit ve ozel islevi olan bir registerimizdir. Bu registerin icindeki her bit bir bayragi temsil etsede bazi bitler anlamsizdir. Bu bayraklar programin isleyisini direk olarak etkiler. 


```c++
Bit    Label     Desciption
---------------------------
0      "CF"      Carry flag
2      "PF"      Parity flag
4      "AF"      Auxiliary carry flag
6      "ZF"      Zero flag
7      "SF"      Sign flag
8      "TF"      Trap flag
9      "IF"      Interrupt enable flag
10     "DF"      Direction flag
11     "OF"      Overflow flag
12-13  "IOPL"    I/O Priviledge level
14     "NT"      Nested task flag
16     "RF"      Resume flag
17     "VM"      Virtual 8086 mode flag
18     "AC"      Alignment check flag (486+)
19     "VIF"     Virutal interrupt flag
20     "VIP"     Virtual interrupt pending flag
21     "ID"      ID flag
```


Flaglarimiz yukarida gordugunuz gibi bazilarini yukarida listelemedik sebebi ise bir coguyla isimiz olmayacak ama yinede bilmekte fayda var. Yukaridaki flaglarimiz sadece iki deger aliyor bunlar **1(set)** ve **0(reset)** dir. Simdi bu flaglarin ne ise yaradiklarina bakalim.

  * **0 -CF** = Carry flag olarak gecer ve elde bayragi olarak bilinir. Matematiksel islemler cercevesinde sikca kullanilan bayragimizdir. Isaretsiz tasma oldugu zaman **set(1)** edilir. Overflow olmadigi zaman **reset(0)** durumundadir.

  * **2 -PF** = Parity flag olarak gecer. Eslik veya esitlik bayragi olarak bilinir. Sonucun dusuk degerli baytindaki **1** lerin cift oldugunu gosterir. 

  * **4 -AF** = Auxiliary carry flag olarak gecer. Ara elde bayragi olarak bilinir. **EAX** registerinin 8 bitlik **AL** kisminda yapilan islemlerde elde kalirsa bu bayrak **1(set)** edilir aksi taktirde durumu **0(reset)** dir.

  * **6 -ZF** = Zero flag olarak gecer. Onemli bir bayraktir cogu dallanma veya karsilastirma bu bayrak ile yapilir. Bir islemin sonucu sifir ise bu bayrak **1(set)** edilir aksi taktirde **0(reset)** dir.

  * **7 -SF** = Sign flag olarak gecer. İsaret biti olarak bilinir. Bir islemin sonucu negatif oldugu zaman bu bayrak **1(set)** edilir sonuc pozitifse bayrak **0(reset)** degerini alir ve genellikle en onemli bitin degerini alir. 

  * **8 -TF** = Trap flag olarak gecer. Tek adim biti olarak bilinir. Bir program debugger yardimi ile acildigi zaman bu bayrak **1(set)** edilir ve instructionlari tek tek isler yani program adim adim isler aksi taktirde **0(reset)** degerini tasir.

  * **9 -IF** = Interrupt flag olarak gecer. Kesme bayragi olarak bilinir. CPU'nun interruplara yanit verip vermeyecegini belirler. Bu flag **1(set)** edildigi zaman maskelenebilir interruplar kullanilabilir.

  * **10 -DF** = Direction flag olarak gecer. Yon bayragi olarak bilinir. String islemleri yaparken kullanilir **1(set)** edildigi zaman index registerinin degeri bir azalir **(0)reset** durumunda tam tersine index registerinin degeri bir artar.

  * **11 -OF** = Overflow flag olarak gecer. Tasma bayragi olarak bilinir. **1(set)** edildigi zaman isaret tasmasi oldugu anlamina gelir.

  * **12-13 -IOPL** = Input/Output priviledge level olarak gecer. Bu bayrak gecerli surecin ayricalik duzeyini tutar. Alttaki resimden ayricalik duzeylerini gorebilirsiniz.

<center><img src="https://i.hizliresim.com/jWBDvn.png" alt="Drawing" style="width: 300px;"/></center>
<br/>

  * **14 -NT** = Nested task flag olarak gecer. Bu flag korumali modda kullanilir ve **1(set)** edildigi zaman calisan surecin sonraki surecle baglantili oldugu anlamina gelir aksi taktirde **0(reset)** degerini alir.

  * **16 -RF** = Resume flag olarak gecer. 

  * **17 -VM** = Virtual 8086 mode flag olarak gecer. 8086 uyumluluk destegi oldugu zaman bu flag **1(set)** edilir aksi taktirde **0(reset)** durumundadir.

  * **18 -AC** = Alignment check flag olarak gecer. Hizalama bayragi olarak bilinir.  

  * **19 -VIF** = Virutal interrupt flag olarak gecer. 

  * **20 -VIP** = Virtual interrupt pending flag olarak gecer. Interrupt bekleniyorsa **1(set)** edilir aksi taktirde **0(reset)** durumdadir.

  * **21 -ID** = Identification flag olarak gecer. 

<br/>

# Stack

Stack dilimizde **yigin** anlamina gelmektedir ve gecici degiskenlerin saklandigi bir hafiza alanidir. Yukarida bahsettigimiz **SS** segmenti buranin adresini ve **ESP** stackde ki offsetleri isaret eder. Stack **LIFO(Last in first out)** ilk giren son cikar mantigiyla calismaktadir. Tum yerel degiskenler, fonksiyon parametreleri ve geri donus degerleri burada olusturulur.

![lifo](https://i.hizliresim.com/gWXG4R.png) 


Gorselde **PUSH** ve **POP** instructionlari yabanci gelebilir. Assembly instructionlarini farkli bir basliga sakladigim icin pek bahsetmedik. Ama bu iki instructiondan bahsedeyim. Stack'e birseyler saklamak icin **PUSH** instructionunu kullaniriz. Alttaki orneklere bakabilirsiniz.

```nasm

mov eax,0xa ; mov instructionu yardimiyla eax registerina 10 sayisini tasiyoruz.
push eax ; eax registerindaki 10 degerini stack e yolluyoruz.
push 0xdeadbeef
```


**POP** instructioni ise stackden deger cekmek icin kullanilir. Alttaki orneklere bakabilirsiniz.

```nasm
push 0xdeadbeef ; 0xdeadbeef'i stacke yerlestiriyoruz.
pop eax ; pop instructionu ile stackdeki son degeri yani 0xdeadbeef'i eax registerine aliyoruz.
push eax ; eax registerina aldigimiz 0xdeadbeef'i tekrardan stacke yolluyoruz.
```

# Son

Ilk yazimiz burada bitiyor bir sonraki **assembly** i konu alan yazimizda **assembly** instructionlarindan bahsedicez. Yazimda farkettiginiz eksiklikleri, sunuda eklersen iyi olur tarzinda onerilerinizi ve en onemlisi yazida farkettiginiz hatalarim varsa mail olarak iletin lutfen duzeltelim.
