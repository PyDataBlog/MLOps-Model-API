import cPickle
import logging
import numpy
import os
import time
from collections import deque
from copy import deepcopy
from datetime import datetime
from pytz import timezone
from threading import Event, Thread

from coinbase.wallet.client import Client

from jarvis.utils.messaging.client import TwilioMessenger
from jarvis.modules.base import JarvisThreadedModule

def configure_debug_logging():
    logging.basicConfig(level=logging.DEBUG)

def load_coinbase_config():
    coinbase_key = os.environ.get('COINBASE_KEY')
    coinbase_secret = os.environ.get('COINBASE_SECRET')

    if not all([coinbase_key, coinbase_secret]):
        raise Exception('Coinbase config not configured properly')

    return (coinbase_key, coinbase_secret)

def load_from_file(path):
    if os.path.exists(path):
        with open(path,'r') as f:
            return cPickle.loads(f.read())

    return None

def store_to_file(path, obj):
    with open(path,'w') as f:
        f.write(cPickle.dumps(obj))

class CoinbaseClient(object):

    def __init__(self):
        self.api_key, self.api_secret = load_coinbase_config()
        self.client = Client(self.api_key, self.api_secret)

    def do(self, func, *args, **kwargs):
        return getattr(self.client,func)(*args, **kwargs)

class TickerTimeseries(object):

    def __init__(self, max_length, recent_cutoff,
            load_path=None, poll_period=30, name=None):
        self.timeseries = load_from_file(load_path)
        if not self.timeseries:
            self.timeseries = deque(maxlen=max_length)
        self.large_movement_timeseries = deepcopy(self.timeseries)
        self.recent_cutoff = recent_cutoff
        self.max_length = max_length
        self.poll_period = poll_period
	self.name = name

    def append(self, val):
        self.timeseries.append(val)
        self.large_movement_timeseries.append(val)

    @property
    def head(self):
        return self.timeseries[-1]

    @property
    def tail(self):
        return self.timeseries[0]

    @property
    def mean(self):
        return numpy.mean(self.timeseries)

    @property
    def length(self):
        return len(self.timeseries)

    @classmethod
    def anomaly(cls, series, recent_cutoff):
        '''
            Naive anomaly detection. Given a series it computes
            the standard deviation and returns True if any of the values
            in the last :recent_cutoff points are are more than
            3 standard deviationsm above the mean

            :series array of timeseries data
            :recent_cutoff only consider anomalies on the most recent points
        '''
        std_dev = numpy.std(series)
        mean    = numpy.mean(series)

        for point in series[-recent_cutoff:]:
            abs_diff = abs(point - mean)
            if abs_diff >= std_dev * 3 and abs_diff >= 3:
                return True

        return False

    def is_anomalous(self):
        # If we don't have enough data, don't do anything
        if len(self.timeseries) < self.recent_cutoff:
            return False

        return self.anomaly(self.timeseries, self.recent_cutoff)

    @classmethod
    def large_movement(self, series):
        if float(abs(series[0] - series[-1])) / series[0] > 0.03:
            return True

        return False

    def is_large_movement(self):
        if self.large_movement(self.large_movement_timeseries):
            msg = MOVEMENT_NOTIFICATION % \
                    (self.name,
		     len(self.large_movement_timeseries) * self.poll_period / 60,
                     self.large_movement_timeseries[0],
                     self.large_movement_timeseries[-1])
            self.large_movement_timeseries = deque(
               [self.large_movement_timeseries[-1]],
               maxlen=self.max_length)
            return msg

        return None


ANOMALY_NOTIFICATION = \
'''Anomalous bitcoin price activity detected. Mean price over the
past %d minutes is %.2f, current price is %.2f'''

MOVEMENT_NOTIFICATION = \
'''Large %s movement detected. Price %d minutes ago was %.2f,
current price is %.2f'''

class CoinbaseWatcher(object):

    POLL_PERIOD = 30
    RECENT_DATA = 60 * 5
    MAX_LENGTH_MULTIPLE = 12 * 24
    COOLDOWN_TICKS = 10

    BTCTICKERPATH = "/tmp/bitccointicker"
    ETHTICKERPATH = "/tmp/ethticker"
    MSGPATH       = "/tmp/bitcoinmsgs"

    def __init__(self, stop):
        recent_points = self.RECENT_DATA / self.POLL_PERIOD

        self.twilio_client = TwilioMessenger()
        self.coinbase_client = CoinbaseClient()
        self.btc_timeseries = TickerTimeseries(
                max_length=recent_points*self.MAX_LENGTH_MULTIPLE,
                recent_cutoff=recent_points,
                load_path=self.BTCTICKERPATH,
                poll_period=self.POLL_PERIOD,
                name='Bitcoin')
        self.eth_timeseries = TickerTimeseries(
                max_length=recent_points*self.MAX_LENGTH_MULTIPLE,
                recent_cutoff=recent_points,
                load_path=self.ETHTICKERPATH,
                poll_period=self.POLL_PERIOD,
                name='Ethereum')
        self.cooldown = 0
        self.stop = stop

        self.sent_messages = load_from_file(self.MSGPATH)
        if not self.sent_messages:
            self.sent_messages = deque(maxlen=3)

    @property
    def raw_btc_timeseries(self):
        return self.btc_timeseries.timeseries

    @property
    def raw_eth_timeseries(self):
        return self.eth_timeseries.timeseries

    @property
    def in_cooldown(self):
        self.cooldown = max(0,self.cooldown - 1)
        if self.cooldown <= 0:
            return False

        return True

    def initiate_cooldown(self):
        self.cooldown = self.COOLDOWN_TICKS

    def start(self):
        while not self.stop.is_set():
            try:
                spot_price = self.coinbase_client.do(
                        'get_spot_price',currency_pair='BTC-USD')
                self.btc_timeseries.append(float(spot_price['amount']))

                # coinbase client doesn't actually support currency_pair
                rates = self.coinbase_client.do('get_exchange_rates')
                self.eth_timeseries.append(1 / float(rates['rates']['ETH']))
                if not self.in_cooldown:
                    msg = self.btc_timeseries.is_large_movement()
                    if msg:
                        self.twilio_client.send_message(msg)
                        self.sent_messages.append((msg, time.time()))
                        self.initiate_cooldown()

		    msg = self.eth_timeseries.is_large_movement()
                    if msg:
                        self.twilio_client.send_message(msg)
                        self.sent_messages.append((msg, time.time()))
                        self.initiate_cooldown()
            except Exception:
               logging.exception("Exception in main loop")

            time.sleep(self.POLL_PERIOD)

        store_to_file(self.MSGPATH,self.sent_messages)
        store_to_file(self.BTCTICKERPATH,self.btc_timeseries.timeseries)
        store_to_file(self.ETHTICKERPATH,self.eth_timeseries.timeseries)

class CoinbaseWatcherModule(JarvisThreadedModule):

    def init_module(self, event):
        self.coinbase_watcher = CoinbaseWatcher(event)
        return Thread(target=self.coinbase_watcher.start)

    def get_recent_messages(self):
        return [
                  (msg, self.convert_timestamp(timestamp)) \
                  for (msg,timestamp) in \
                  reversed(self.coinbase_watcher.sent_messages)
               ]

    @classmethod
    def convert_timestamp(cls, timestamp):
        pacific = timezone("US/Pacific-New")
        utc = timezone("UTC")
        return utc.localize(datetime.utcfromtimestamp(
            timestamp)).astimezone(pacific).strftime('%Y-%m-%d %H:%M:%S')

    def get_bitcoin_ticker_timeseries(self):
        seconds_per_point = self.coinbase_watcher.POLL_PERIOD
        now = time.time()

        return [
            {
             'date' : self.convert_timestamp(now-seconds_per_point*i),
             'value' : val
            } for i,val in enumerate(reversed(
                self.coinbase_watcher.raw_btc_timeseries))
        ][::-1]

    def get_eth_ticker_timeseries(self):
        seconds_per_point = self.coinbase_watcher.POLL_PERIOD
        now = time.time()

        return [
            {
             'date' : self.convert_timestamp(now-seconds_per_point*i),
             'value' : val
            } for i,val in enumerate(reversed(
                self.coinbase_watcher.raw_eth_timeseries))
        ][::-1]
if __name__ == '__main__':
    configure_debug_logging()
    watcher = CoinbaseWatcher()
    watcher.start()
