# old single process tictactoe game to be rewritten....

import numpy
import os

class TicTacToePlayer:

	def __init__(self, playerType, playerName, ttt_game_settings):
		if playerType not in ['AI', 'Terminal']:
			raise(ValueError())
		self.type=playerType
		self.name=playerName
		self.board_size = ttt_game_settings['board_size']
		self.nr_of_positions = ttt_game_settings['board_size'][0]*ttt_game_settings['board_size'][1]

	def playMove(self, board):
		if self.type == 'AI':
			return numpy.random.randint(1,self.nr_of_positions+1)
		elif self.type == 'Terminal':
			return self.playFromTerminal(board)

	def playFromTerminal(self,board):
		os.system('cls' if os.name == 'nt' else 'clear')
		print(board)
		while True:
			try:
				moveAttempt = input("%s! Play a position (1-%i): " % (self.name, self.nr_of_positions))
				if ((1 <= int(moveAttempt) <= self.nr_of_positions)):
					row = (int(moveAttempt)-1) // self.board_size[1]
					col = (int(moveAttempt)-1) % self.board_size[1]
					if board[row,col] == 0:
						break # valid move!
					else:
						print("That position is already taken!")
				else:
					print("That is not an integer between 1 and %i!" % self.nr_of_positions)
			except ValueError:
				print("That is not an integer!")
		return int(moveAttempt)

	def getName(self):
		return self.name
	
    
class TicTacToeGame:
	def __init__(self, player1Name="player1", playerMinus1Name="player2", player1Type="Terminal", playerMinus1Type="Terminal"\
					, settings=dict(board_size=(3,3), win_length=3)):

		self.game, self.board_size, self.win_length = self.initializa_game(settings)
		self.player1 = TicTacToePlayer(\
			playerType=player1Type,\
			playerName=player1Name,\
			ttt_game_settings=settings)
		self.playerMinus1 = TicTacToePlayer(\
			playerType=playerMinus1Type,\
			playerName=playerMinus1Name,\
			ttt_game_settings=settings)

	def getGame(self):
		return self.game

	def initializa_game(self,settings):
		board_size_in = settings['board_size']
		win_length = settings['win_length']
		board_size = numpy.asarray(board_size_in,dtype='int')
		if len(board_size) != 2: raise(ValueError('Not a good size!'))
		if win_length > min(board_size) or not isinstance(win_length, int): raise(ValueError('Not a X in rows config.'))
		return [], board_size, win_length


	def getBoard(self):
		board = numpy.zeros(shape=self.board_size)
		currPlayerIs1 = True
		for move in self.game:
			row = (int(move)-1) // self.board_size[1]
			col = (int(move)-1) % self.board_size[1]
			board[row,col] = 1 if currPlayerIs1 else -1
			currPlayerIs1 = not currPlayerIs1
		return board

	def playMove(self,move):
		if int(move) in self.game \
		or int(move) > self.board_size[0]*self.board_size[1]:
			return False #invalid move
		else:
			self.game.append(int(move))
			return True

	def play(self):
		currPlayerIs1 = True
		while True:
			moveAttempt = self.player1.playMove(self.getBoard()) if currPlayerIs1 else self.playerMinus1.playMove(self.getBoard())
			if self.playMove(moveAttempt):
				currPlayerIs1 = not currPlayerIs1
			
				gameHasEnded, endMessage = self.checkGameEnded()
				if gameHasEnded:
					print(endMessage)
					print(self.getBoard())
					print("Thank you for playing Tic-Tac-Toe!")
					break
	   

	def checkWinner(self):
		board = self.getBoard()
		lastmove = self.game[-1]
		row = (int(lastmove)-1) // self.board_size[1]
		col = (int(lastmove)-1) % self.board_size[1]
		lastmove = (row,col)

		currPlayerName = self.player1.getName() if len(self.game) % 2 == 1 else self.playerMinus1.getName()

		num_N = self.checkStreak(lastmove,'N')
		num_S = self.checkStreak(lastmove,'S')
		if 1+num_N + num_S == self.win_length:
			return True, "%s won!" % currPlayerName

		num_E = self.checkStreak(lastmove,'E')
		num_W = self.checkStreak(lastmove,'W')
		if 1+num_E + num_W == self.win_length:
			return True, "%s won!" % currPlayerName

		num_NE = self.checkStreak(lastmove,'NE')
		num_SW = self.checkStreak(lastmove,'SW')
		if 1+num_NE + num_SW == self.win_length:
			return True, "%s won!" % currPlayerName

		num_SE = self.checkStreak(lastmove,'SE')
		num_NW = self.checkStreak(lastmove,'NW')
		if 1+num_SE + num_NW == self.win_length:
			return True, "%s won!" % currPlayerName
		
		return False, ""

	def checkStreak(self,position,direction):
		if direction == 'N':
			parsed_dir = (-1,0)
		elif direction =='S':
			parsed_dir = (1,0)
		elif direction == 'E':
			parsed_dir = (0,1)
		elif direction == 'W':
			parsed_dir = (0,-1)
		elif direction == 'NW':
			parsed_dir = (-1,-1)
		elif direction == 'SW':
			parsed_dir = (1,-1)
		elif direction == 'NE':
			parsed_dir = (-1,1)
		elif direction == 'SE':
			parsed_dir = (1,1)
		next_pos = numpy.asarray(position)+numpy.asarray(parsed_dir)
		board = self.getBoard()
		if next_pos[0] <0 or next_pos[1] < 0: return 0
		if next_pos[0] >= self.board_size[0] or next_pos[1] >= self.board_size[1]: return 0
		player_here = board[position[0],position[1]]
		next_player = board[next_pos[0],next_pos[1]]

		if player_here != next_player:
			return 0
		else:
			return self.checkStreak(next_pos,direction) + 1

	def checkGameEnded(self):
		gameHasEnded, endMessage = self.checkWinner()
		if not gameHasEnded:
			if len(self.game) == self.board_size[0]*self.board_size[1]:
				gameHasEnded = True
				endMessage = "Its a tie!"
		
		return gameHasEnded, endMessage
			
if __name__ == "__main__":
	ttt_game_settings = dict(board_size=(4,4), win_length=3)

	myGame = TicTacToeGame(player1Name="Ludvig", playerMinus1Name="PC", playerMinus1Type="AI",settings=ttt_game_settings)
	myGame.play()
