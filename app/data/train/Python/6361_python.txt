#!/usr/bin/env python
from flask import Flask, render_template, request, jsonify, session, redirect, escape, url_for
import MySQLdb
import bcrypt
from esipy import App
from esipy import EsiClient
from esipy import EsiSecurity
from esipy.exceptions import APIException
import time
import json
import requests
import datetime
import math

app = Flask(__name__)

class ServerError(Exception):pass

class DB:
	conn = None
	
	def connect(self):
		config = {}
		execfile("config.conf",config)

		self.conn = MySQLdb.connect(
		host=config['dbHost'],
		user=config['dbUser'],
		passwd=config['dbPass'],
		db=config['dbBase']
		)
		self.conn.autocommit(True)
		self.conn.set_character_set('utf8') 

	def query(self, sql, args=None):
		try:
			cursor = self.conn.cursor()
			cursor.execute(sql,args)
		except (AttributeError, MySQLdb.OperationalError):
			self.connect()
			cursor = self.conn.cursor()
			cursor.execute(sql,args)
		return cursor

if __name__ == '__main__':
	config = {}
	execfile("config.conf",config)
	serverIP = config['serverIP']
	serverPort = config['serverPort']

	rounds = 10

	debug = config['debug']

	cer = config['ssl_cer']
	key = config['ssl_key']
	context = (cer,key)

	app.secret_key = config['appKey']

	esi_app = App.create('https://esi.tech.ccp.is/latest/swagger.json?datasource=tranquility')

	security = EsiSecurity(
		app=esi_app,
		redirect_uri=config['callbackURL'],
		client_id=config['clientID'],
		secret_key=config['secretKey']
		)
	client = EsiClient(security=security)
	scopes = ['esi-location.read_location.v1','esi-skills.read_skillqueue.v1','esi-skills.read_skills.v1','esi-clones.read_clones.v1']

db = DB()

def profit():
	extractorID = "40519"
	injectorID = "40520"
	plexID = "44992"
	priceList = []
	url = "http://api.eve-central.com/api/marketstat/json?regionlimit=10000002&typeid="
	try:
		prices = requests.get(url+extractorID).json()[0]
		extractorPrice = prices['buy']['fivePercent']
		extractorPricen= prices['sell']['fivePercent']
		prices = requests.get(url+injectorID).json()[0]
		injectorPrice = prices['sell']['fivePercent']
		injectorPricen= prices['buy']['fivePercent']
		prices = requests.get(url+plexID).json()[0]
		plexPrice = prices['buy']['fivePercent']
		plexPricen= prices['sell']['fivePercent']

		injectorsMonth = 3.888

		profit = round(((injectorsMonth * (injectorPrice - extractorPrice)) - (plexPrice * 500))/1000000,2)
		nonoptimal = round(((injectorsMonth * (injectorPricen - extractorPricen)) - (plexPricen * 500))/1000000,2)
		return "<a href='https://market.madpilot.nl/static/graph/farm-month.png'>Projected profits: (min)"+str(nonoptimal)+"mil - (max)"+str(profit)+"mil </a>"
	except:
		return "<a href='https://market.madpilot.nl/static/graph/farm-month.png'>Projected profits: (min)"+str(0)+"mil - (max)"+str(0)+"mil </a>"

def isk(extractors):
	extractorID = "40519"
	injectorID = "40520"
	plexID = "44992"
	priceList = []
	url = "http://api.eve-central.com/api/marketstat/json?regionlimit=10000002&typeid="
	try:
		prices = requests.get(url+extractorID).json()[0]
		extractorPrice = prices['buy']['fivePercent']
		extractorPricen= prices['sell']['fivePercent']
		prices = requests.get(url+injectorID).json()[0]
		injectorPrice = prices['sell']['fivePercent']
		injectorPricen= prices['buy']['fivePercent']
		prices = requests.get(url+plexID).json()[0]
		plexPrice = prices['buy']['fivePercent']
		plexPricen= prices['sell']['fivePercent']

		maxProfit = round(((injectorPrice - extractorPrice) * extractors)/1000000,2)
		minProfit = round(((injectorPricen - extractorPricen) * extractors)/1000000,2)
	except:
		maxProfit = 0
		minProfit = 0

	return [maxProfit, minProfit]

def isReady(char_id):
	checkDelay = 1800
	cur = db.query("SELECT UNIX_TIMESTAMP(updated) FROM cache_table WHERE character_id = %s",[char_id])
	lastChecked = cur.fetchone()
	curTime = int(time.time())
	if lastChecked:
		lastCheckedEpoch = lastChecked[0]
		if (curTime - lastCheckedEpoch) < checkDelay:
			print("Checktime is less than "+str(checkDelay)+" Seconds (current: "+str(curTime - lastCheckedEpoch)+"). Skipping")
			return False
		return True
	return True


@app.route('/')
def index():
	error = None
	if 'username' not in session:
		error = "Not logged in"
		return redirect(url_for('login', error=error))

	secure = security.get_auth_uri(scopes=scopes)

	cur = db.query("SELECT id FROM users WHERE user = %s;", [session['username']])
	for row in cur.fetchall():
		userID = row[0]

	characters = []
	cur = db.query("SELECT character_id, access_token, refresh_token, expires, expires_in, added, updated FROM characters WHERE owner_id = %s;", [userID])

	allSP = 0
	extractableSP = 0
	numExtract = 0

	for row in cur.fetchall():
	
		epoch = round(time.time())
		expires = row[3] - row[4] - epoch
		if expires < 0:
			expires = 0
		refresh = {u'access_token': row[1], u'refresh_token': row[2], u'expires_in': expires}

		security.update_token(refresh)

		ready = isReady(row[0])
		if not ready:
			cur = db.query("SELECT * FROM cache_table WHERE character_id=%s",[row[0]])
			cache = cur.fetchall()[0]

		#Get character name
		charName = esi_app.op['get_characters_names'](character_ids=[row[0]])
		result = client.request(charName)
		charName = json.loads(result.raw)[0].get('character_name')
		print "Character "+charName
		#Get character location

		if ready:
			charLocation = esi_app.op['get_characters_character_id_location'](character_id=row[0])
			result = client.request(charLocation)
			location = json.loads(result.raw)
			sol = esi_app.op['get_universe_systems_system_id'](system_id=location.get('solar_system_id'))
			sol = json.loads(client.request(sol).raw).get('name')

			cur = db.query("INSERT INTO cache_table (character_id,char_location) VALUES (%s,%s) ON DUPLICATE KEY UPDATE char_location=%s",[row[0],result.raw,result.raw])
		else:
			location = json.loads(cache[3])
			sol = esi_app.op['get_universe_systems_system_id'](system_id=location.get('solar_system_id'))
			sol = json.loads(client.request(sol).raw).get('name')

		#Get current training skill + queue
		if ready:
			charTrain = esi_app.op['get_characters_character_id_skillqueue'](character_id=row[0])
			result = client.request(charTrain)
			training = json.loads(result.raw)
			cur = db.query("INSERT INTO cache_table (character_id,char_queue) VALUES (%s,%s) ON DUPLICATE KEY UPDATE char_queue=%s",[row[0],result.raw,result.raw])
		else:
			training = json.loads(cache[4])

		currentlyTrainingStart = training[0].get('start_date')
		currentlyTrainingEnd = training[0].get('finish_date')
		startTrainEpoch = int(time.mktime(time.strptime(currentlyTrainingStart, "%Y-%m-%dT%H:%M:%SZ")))
		endTrainEpoch = int(time.mktime(time.strptime(currentlyTrainingEnd, "%Y-%m-%dT%H:%M:%SZ")))

		if endTrainEpoch < epoch:
			while endTrainEpoch < epoch and len(training)>1:
				del training[0]
				currentlyTrainingStart = training[0].get('start_date')
				currentlyTrainingEnd = training[0].get('finish_date')
				startTrainEpoch = int(time.mktime(time.strptime(currentlyTrainingStart, "%Y-%m-%dT%H:%M:%SZ")))
				endTrainEpoch = int(time.mktime(time.strptime(currentlyTrainingEnd, "%Y-%m-%dT%H:%M:%SZ")))

		trainedSpCur = training[0].get('training_start_sp') - training[0].get('level_start_sp')
		endQueue = training[-1].get('finish_date')
		currentlyTraining = training[0].get('skill_id')
		currentlyTrainingLevel = training[0].get('finished_level')
		curSkillStartSP = training[0].get('level_start_sp')
		curSkillEndSP = training[0].get('level_end_sp')
		curSkillSP = curSkillEndSP - curSkillStartSP

		#Get currently training name
		skillName = esi_app.op['get_universe_types_type_id'](type_id=currentlyTraining)
		result = client.request(skillName)
		skillName = json.loads(result.raw).get('name')

		#Get character total sp
		if ready:
			charSkill = esi_app.op['get_characters_character_id_skills'](character_id=row[0])
			result = client.request(charSkill)
			sp = json.loads(result.raw)
			totalSp = sp.get('total_sp')
			cur = db.query("INSERT INTO cache_table (character_id,char_skills) VALUES (%s,%s) ON DUPLICATE KEY UPDATE char_skills=%s",[row[0],result.raw,result.raw])
		else:
			sp = json.loads(cache[5])
			totalSp = sp.get('total_sp')

		#Get current training skill rank
		skillRank = esi_app.op['universe_types_type_id'](type_id=currentlyTraining)
		result = client.request(skillRank)
		skillDogma = json.loads(result.raw).get('dogma_attributes')
		
		print skillDogma
		skillRank = 5
		# for skill in skillDogma:
		# 	if skill.get('attribute_id') == 275:
		# 		skillRank = skill.get('value')
		# 		break;

		startTrainEpoch = int(time.mktime(time.strptime(currentlyTrainingStart, "%Y-%m-%dT%H:%M:%SZ")))
		endTrainEpoch = int(time.mktime(time.strptime(currentlyTrainingEnd, "%Y-%m-%dT%H:%M:%SZ")))
		totalTrainTime = endTrainEpoch - startTrainEpoch
		trainedTime = epoch - startTrainEpoch

		# skillStartSP = (250 * math.pow(5.65685,currentlyTrainingLevel-1))
		# skillEndSP = (250 * math.pow(5.65685,currentlyTrainingLevel))



		spPerSec = float(curSkillSP) / float(totalTrainTime)
		trainedSP = int(spPerSec * trainedTime)

		totalSp += trainedSP
		allSP += totalSp

		#Prettify dates
		timeLeftCurrent = datetime.datetime.strptime(currentlyTrainingEnd, "%Y-%m-%dT%H:%M:%SZ").replace(microsecond=0) - datetime.datetime.now().replace(microsecond=0)
		endQueueLeft = datetime.datetime.strptime(endQueue, "%Y-%m-%dT%H:%M:%SZ").replace(microsecond=0) - datetime.datetime.now().replace(microsecond=0)

		currentlyTrainingEnd = time.strftime("%Y-%m-%d %H:%M",time.gmtime(int(time.mktime(time.strptime(currentlyTrainingEnd, "%Y-%m-%dT%H:%M:%SZ")))))
		endQueue = time.strftime("%Y-%m-%d %H:%M",time.gmtime(int(time.mktime(time.strptime(endQueue, "%Y-%m-%dT%H:%M:%SZ")))))

		#Get Cybernetics skill
		for skill in sp.get('skills'):
			if skill.get('skill_id') == 3411:
				cyberLevel = skill.get('current_skill_level')
				break;

		#Get character attributes
		#Assume 2700(max) for now, until attributes are added to ESI

		startTime = time.mktime(time.strptime(currentlyTrainingStart, "%Y-%m-%dT%H:%M:%SZ"))
		timeDone = epoch - startTime
		spAdded = int(timeDone / 60 / 60 * 2700)

		if totalSp > 5500000:
			exSP = totalSp - 5000000
			extractableSP += exSP
			exSP = int(exSP / 500000)
			numExtract += exSP

		totalSp = format(totalSp, "8,d")

		queueStatus = None
		if endTrainEpoch < epoch:
			queueStatus = "Queue empty!"

		characters.append(
			{
			"characterName": charName, 
			"characterID": row[0], 
			"characterImage": "https://image.eveonline.com/Character/"+str(row[0])+"_64.jpg", 
			"totalSP": totalSp, 
			"characterLocation": sol, 
			"currentEnd":currentlyTrainingEnd, 
			"queueEnd": endQueue, 
			"currentlyTraining": currentlyTraining, 
			"timeLeftCurrent": timeLeftCurrent,
			"endQueueLeft": endQueueLeft,
			"currentlyTrainingLevel": currentlyTrainingLevel,
			"currentlyTrainingName": skillName,
			"cyberneticsLevel": cyberLevel,
			"queueStatus": queueStatus
			})
		print "----------"

	allSP = format(allSP, "8,d")
	extractableSP = format(extractableSP, "8,d")
	stats = [{
		"allSP": allSP,
		"exSP": extractableSP,
		"numEx": numExtract
		}]
	profits = isk(numExtract)
	return render_template('index.html',secUrl=secure, characters=characters, stats=stats, profit=profit(), profits=profits)

@app.route('/login', methods=['GET', 'POST'])
def login():
	error = None
	error = request.args['error']

	if 'username' in session:
		return redirect(url_for('index'))

	try:
		if request.method == 'POST':
			username = request.form['username']
			cur = db.query("SELECT COUNT(1) FROM users WHERE user = %s", [username])
			if not cur.fetchone()[0]:
				raise ServerError('Incorrect username / password')
			password = request.form['password']
			cur = db.query("SELECT pass FROM users WHERE user = %s;", [username])
			for row in cur.fetchall():
				if bcrypt.hashpw(password.encode('utf-8'), row[0]) == row[0]:
					session['username'] = request.form['username']
					return redirect(url_for('index'))
			raise ServerError('Incorrect username / password')
	except ServerError as e:
		error = str(e)

	return render_template('login.html', error=error)

@app.route('/logout')
def logout():
	session.pop('username', None)
	return redirect(url_for('index'))

@app.route('/register', methods=['GET', 'POST'])
def register():
	error = None
	if 'username' not in session:
		try:
			if request.method == 'POST':
				username = request.form['username']
				password = request.form['password']
				email    = request.form['email']

				if not username or not password or not email:
					raise ServerError('Fill in all fields please')

				password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt(rounds))
				cur = db.query("INSERT INTO users (`user`, `pass`, `email`) VALUES (%s,%s,%s)", [username, password, email])
		except ServerError as e:
			error = str(e)
			return render_template('register.html', error=error)

		if config['registerEnabled']:
			return render_template('register.html')
		error = "Registration is disabled by the admin"
		return redirect(url_for('login', error=error))
	if session['username'] == 'admin':
		return render_template('register.html')
	error = "Only available to admins"
	return redirect(url_for('login', error=error))

@app.route('/userPage', methods=['GET','POST'])
def userPage():
	return "User! :-)"

@app.route('/oauth')
def oauth():
	code = request.args.get('code')
	if not code:
		return redirect(url_for('index'))
	token = security.auth(code)
	access_token = token['access_token']
	refresh_token = token['refresh_token']
	expires_in = token['expires_in']

	cur = db.query("SELECT id FROM users WHERE user = %s;", [session['username']])
	for row in cur.fetchall():
		userID = row[0]
	verify = security.verify()
	charID = verify.get('CharacterID')
	print userID
	print charID
	print token
	print token['access_token']
	print token['refresh_token']
	print token['expires_in']
	epoch = round(time.time())
	expires = epoch + int(expires_in)
	cur = db.query("INSERT INTO characters (owner_id, character_id, access_token, refresh_token, expires, expires_in) VALUES (%s,%s,%s,%s,%s,%s) ON DUPLICATE KEY UPDATE access_token=%s, refresh_token=%s, expires=%s, expires_in=%s",[userID,charID,access_token,refresh_token,expires,int(expires_in),access_token,refresh_token,expires,int(expires_in)])
	return redirect(url_for('index'))

if __name__ == '__main__':
	if config['ssl']:
		app.run(
			host=serverIP,
			port=serverPort,
			ssl_context=context,
			debug=debug
		)

	else:
		app.run(
			host=serverIP,
			port=serverPort,
			debug=debug
		)