module Fuelcell
  module Help
    # Formats help text to be displayed on the command line. The formatter
    # works with help text structured in a hash.
    class UsageFormatter < BaseFormatter

      def call(data)
        usage = data[:usage] || {}
        text  = format_cmd(usage)
        opts  = format_opts(usage[:opts], text.size + 1)
        text += ' ' + opts unless opts.empty?

        "#{text}\n"
      end

      # Format the options so that they wrap at the max width of the terminal
      # and that they align after the command path.
      #
      # @param opts [Hash]
      # @param align [Int]
      # @return [String]
      def format_opts(opts, align_width)
        text = ''
        line_width = align_width
        opts.each do |opt|
          text, line_width = append_opts(text, opt, line_width, align_width)
        end
        text.strip
      end

      # Format the label and the path which make the up
      # the first line of usage text.
      #
      # @param data [Hash]
      # @return [Array] formatted text, size of text
      def format_cmd(data)
        "#{data[:label]} #{data[:path]}"
      end

      # Append a single opt text to the usage line. Ensure wrapping
      # occurs correctly & wrapped opt aligns with the start of the
      # first opt.
      #
      # The align width is the amount of padding necessary in order to align
      # all the opt text from the left.
      #
      # @param text [String] text of all currently appended options
      # @param opt  [String] text of the current option
      # @param line_width [Int] width of the current line including padding
      # @param align_width [Int] opts will align to this width after wrapping
      def append_opts(text, opt, line_width, align_width)
        str = opt_display(opt)
        if (line_width + str.size) < max_width
          return append_current_line(text, str, line_width)
        end

        append_nextline(text, str, align_width)
      end

      # Used to append to the usage line when its shorted then the terminal
      # window
      #
      # @param text [String] the current usage line
      # @param str [String] the string to be appended
      # @param line_width [Int] width of current line
      # @return [Array] append text & size
      def append_current_line(text, str, line_width)
        line_width += str.size + 1
        text << str + ' '
        [text, line_width]
      end

      # Used append a newline to the usage and wrap the text because it
      # is long then the terminal width
      #
      def append_nextline(text, str, align_width)
        text = text.strip + "\n"
        text << (' ' * align_width) + str
        [text, text.size]
      end

      def opt_display(data)
        text = "#{short_opt(data)} #{long_opt(data)}".strip
        "[#{text}]"
      end
    end
  end
end
