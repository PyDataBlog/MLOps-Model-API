# Encoding: utf-8

require 'askari/type'

# The .stub_key_value macro sets up *many* let declarations of facts about an HBase key
# value and its place in a schema:
#
# * row_key
# * row_key_encoded
# * row_key_type
# * family
# * family_encoded
# * qualifier_name
# * qualifier_schema
# * qualifier_type
# * qualifier
# * qualifier_encoded
# * value_type
# * value
# * value_encoded
# * timestamp
# * key_value: a double resembling an HBase KeyValue
module KeyValueHelpers
  def stub_key_value(options = {})
    stub_key_value_qualifier_schema(options)
    stub_key_value_row_key(options)
    stub_key_value_family(options)
    stub_key_value_qualifier(options)
    stub_key_value_value(options)
    stub_key_value_timestamp(options)
    stub_key_value_itself(options)
  end

  private

  def stub_key_value_prefix(options)
    prefix = options.fetch(:prefix, '')
    prefix == '' ? '' : "#{prefix}_"
  end

  def stub_key_value_qualifier_schema(options)
    prefix = stub_key_value_prefix(options)
    qualifier_name = options.fetch(:qualifier_name)

    let("#{prefix}qualifier_name") { qualifier_name.to_sym }
    let("#{prefix}qualifier_schema") { relation_schema.qualifiers[qualifier_name.to_s] }
  end

  def stub_key_value_row_key(options)
    prefix = stub_key_value_prefix(options)
    row_key = options.fetch(:row_key)

    let("#{prefix}row_key")  { row_key }
    let("#{prefix}row_key_type") { Askari::Type[relation_schema.row_key_type] }

    stub_key_value_row_key_encoded(options)
  end

  def stub_key_value_family(options)
    prefix = stub_key_value_prefix(options)

    let("#{prefix}family") { (send "#{prefix}qualifier_schema").family_name }
    let("#{prefix}family_encoded") { (send "#{prefix}family").to_java_bytes }
  end

  def stub_key_value_qualifier(options)
    prefix = stub_key_value_prefix(options)
    qualifier = options.fetch(:qualifier)

    let("#{prefix}qualifier") { qualifier }

    let("#{prefix}qualifier_type") do
      Askari::Type[(send "#{prefix}qualifier_schema").qualifier_type]
    end

    stub_key_value_qualifier_encoded(options)
  end

  def stub_key_value_value(options)
    prefix = stub_key_value_prefix(options)
    value = options.fetch(:value)

    let("#{prefix}value") { value }

    let("#{prefix}value_type") do
      Askari::Type[(send "#{prefix}qualifier_schema").value_type]
    end

    stub_key_value_value_encoded(options)
  end

  def stub_key_value_timestamp(options)
    prefix = stub_key_value_prefix(options)
    timestamp = options.fetch(:timestamp)

    let("#{prefix}timestamp") { timestamp }
  end

  def stub_key_value_row_key_encoded(options)
    prefix = stub_key_value_prefix(options)

    let("#{prefix}row_key_encoded") do
      (send "#{prefix}row_key_type").encode(options.fetch(:row_key))
    end
  end

  def stub_key_value_qualifier_encoded(options)
    prefix = stub_key_value_prefix(options)

    let("#{prefix}qualifier_encoded") do
      (send "#{prefix}qualifier_type").encode(options.fetch(:qualifier))
    end
  end

  def stub_key_value_value_encoded(options)
    prefix = stub_key_value_prefix(options)

    let("#{prefix}value_encoded") do
      (send "#{prefix}value_type").encode(options.fetch(:value))
    end
  end

  def stub_key_value_itself(options)
    prefix = stub_key_value_prefix(options)

    let("#{prefix}key_value") do
      double(
        "#{prefix}key_value",
        row: (send "#{prefix}row_key_encoded"),
        family: (send "#{prefix}family_encoded"),
        qualifier: (send "#{prefix}qualifier_encoded"),
        value: (send "#{prefix}value_encoded"),
        timestamp: options.fetch(:timestamp))
    end
  end
end

shared_context 'key-value', :key_value do |relation_name|

  let(:relation_schema) { schema.current_version.relation(relation_name) }

  extend KeyValueHelpers

end
