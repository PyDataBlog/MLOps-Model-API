require 'spec_helper'

module RubEmUp
  module Core
    describe LoopingScene do
      let(:velocity)    { Utils::Velocity[10, 90] }
      let(:valid_types) { [:front, :rear]         }

      let(:looping_scene) do
        LoopingScene.new(:rear, Utils::Velocity[5, :backward])
      end

      describe '#new' do
        it 'can create instance with valid type and velocity' do
          valid_types.each do |valid_type|
            LoopingScene.new(valid_type, velocity)
          end
        end

        it 'can not create instance without arguments' do
          expect { LoopingScene.new }.to raise_error(ArgumentError)
        end
      end

      describe 'attributes' do
        describe 'type' do
          it 'should expose the type via getter' do
            looping_scene.type.should eq :rear
          end

          it 'should not expose the type via setter' do
            looping_scene.should_not respond_to :rear=
          end
        end

        describe 'velocity' do
          it 'should expose the velocity via getter' do
            looping_scene.velocity.should eq Utils::Velocity[5, :backward]
          end

          it 'should not expose the velocity via setter' do
            looping_scene.should_not respond_to :velocity=
          end
        end

        describe 'size' do
          it 'should expose the size via getter' do
            looping_scene.size.should eq SIZE[:background][looping_scene.type]
          end

          it 'should not expose the velocity via setter' do
            looping_scene.should_not respond_to :size=
          end
        end

        describe 'offset' do
          it 'should expose the offset via getter' do
            looping_scene.offset.should eq Utils::Vector[0, 0]
          end

          it 'should not expose the offset via setter' do
            looping_scene.should_not respond_to :offset=
          end
        end

        describe 'tile_size' do
          it 'should expose the tile size via getter' do
            looping_scene.tile_size.should(
              eq SIZE[:looping_scene][looping_scene.type])
          end

          it 'should not expose the tile size via setter' do
            looping_scene.should_not respond_to :tile_size=
          end
        end
      end

      describe '#local_offset' do
        before(:each) do
          @looping_scene = LoopingScene.new(:rear,
                                            Utils::Velocity[5, :backward])
        end

        context 'at the start of the game' do
          it 'should be [0, 0]' do
            @looping_scene.local_offset.should eq Utils::Vector[0, 0]
          end
        end

        context 'somewhere throughout the game' do
          it 'should get to [0, 0] at some point' do
            @looping_scene.update(@looping_scene.tile_size.x /
                                  @looping_scene.velocity.speed)

            @looping_scene.local_offset.x.should be_within(0.001).of(0)
            @looping_scene.local_offset.y.should be_within(0.001).of(0)
          end

          it 'should change according to the speed' do
            @looping_scene.update(1 / @looping_scene.velocity.speed)

            @looping_scene.local_offset.x.should be_within(0.001).of(-1)
            @looping_scene.local_offset.y.should be_within(0.001).of(0)
          end
        end
      end

      describe '#visible_tiles' do
        let(:tiles_per_screen) do
          SIZE[:screen].x.fdiv(@looping_scene.tile_size.x).ceil
        end

        before(:each) do
          @looping_scene = LoopingScene.new(:rear,
                                            Utils::Velocity[5, :backward])
        end

        context 'at the start of the game' do
          it 'returns the first tiles' do
            @looping_scene.visible_tiles.should(
              eq 0.upto(tiles_per_screen).to_a)
          end

          it 'returns tiles_per_screen + 1 number of tiles' do
            @looping_scene.visible_tiles.should(
              have(tiles_per_screen + 1).items)
          end
        end

        context 'somewhere throughout the game' do
          it 'should change when the scene moves with one tile' do
            @looping_scene.update(@looping_scene.tile_size.x /
                                  @looping_scene.velocity.speed)

            @looping_scene.visible_tiles.should(
              eq 1.upto(tiles_per_screen + 1).to_a)
          end

          it 'should loop back to the begining' do
            @looping_scene.update(@looping_scene.size.x /
                                  @looping_scene.velocity.speed)

            @looping_scene.visible_tiles.should(
              eq 0.upto(tiles_per_screen).to_a)
          end
        end
      end

      describe '#update' do
        before(:each) do
          @looping_scene = LoopingScene.new(:rear,
                                            Utils::Velocity[5, :backward])
        end

        it 'should reset the offset to make the scene loop' do
          @looping_scene.update(@looping_scene.size.x /
                                @looping_scene.velocity.speed)

          @looping_scene.offset.x.should be_within(0.001).of(0)
          @looping_scene.offset.y.should be_within(0.001).of(0)
        end

        it 'should move the scene according to the time passed' do
          @looping_scene.update(1 / @looping_scene.velocity.speed)

          @looping_scene.offset.x.should be_within(0.001).of(-1)
          @looping_scene.offset.y.should be_within(0.001).of(0)
        end
      end
    end
  end
end
