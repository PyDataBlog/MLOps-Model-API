package ujicha

import (
	"net"
	"net/http"
	"errors"
	"encoding/json"
	"bytes"
)

type serviceInfo struct {
	Name string `json:"name"`
	Address string `json:"address"`
}

type bffInfo struct {
	Name string `json:"name"`
	Address string `json:"address"`
	DisplayName string `json:"display_name"`
}

func getLocalIP() (string, error) {
	addresses, err := net.InterfaceAddrs()

	if err != nil {
		return "", errors.New("Failed to get local ip address.")
	}

	for _, address := range addresses {
		if ipnet, ok := address.(*net.IPNet); ok && !ipnet.IP.IsLoopback() {
			return ipnet.IP.String(), nil
		}
	}

	return "", errors.New("Failed to get local ip address.")
}

func RegisterService(serviceName string) error {
	localIP, err := getLocalIP()

	if err != nil {
		return err
	}

	service := serviceInfo {
		Name: serviceName,
		Address: localIP,
	}

	b, err := json.Marshal(service)

	if err != nil {
		return err
	}

	addr := "http://ujicha:8081/v1/service"
	res, err := http.Post(addr, "application/json", bytes.NewBuffer(b))

	if err != nil {
		return err
	}

	defer res.Body.Close()

	switch res.StatusCode {
	case 409:
		return nil
	case 201:
		return nil
	default:
		return errors.New("Failed to register service")
	}
}

func RegisterBff(bffName string, displayName string) error {
	localIP, err := getLocalIP()

	if err != nil {
		return err
	}

	bff := bffInfo {
		Name: bffName,
		Address: localIP,
		DisplayName: displayName,
	}

	b, err := json.Marshal(bff)

	if err != nil {
		return err
	}

	addr := "http://ujicha:8081/v1/bff"
	res, err := http.Post(addr, "application/json", bytes.NewBuffer(b))

	if err != nil {
		return err
	}

	defer res.Body.Close()

	switch res.StatusCode {
	case 409:
		return nil
	case 201:
		return nil
	default:
		return errors.New("Failed to register bff")
	}
}
