package demo

import (
	_ "fmt"
	cp "github.com/eka-tel72/go-chipmunk62/chipmunk"
)

/*
#include <stdlib.h>

int Random(void)
{
	return rand();
}

void Seed(unsigned int i)
{
	srand(i);
}

*/
import "C"

type tumble struct {
	*demoClass
	rogueBoxBody *cp.Body
}

var tumbleInst = &tumble{
	&demoClass{
		name:     "Tumble",
		timestep: 1.0/180.0,
	},
	nil,
}

func (t *tumble) Update(space *cp.Space, dt float64) {
	fdt := cp.Float(dt)
	cp.BodyUpdatePosition(t.rogueBoxBody, fdt)
	cp.SpaceStep(space, fdt)
}

func tumbleAddBox(space *cp.Space, pos cp.Vect, mass, width, height cp.Float) {
	body := cp.SpaceAddBody( space, cp.BodyNew(mass, cp.MomentForBox(mass, width, height)) )
	cp.BodySetPos(body, pos)

	shape := cp.SpaceAddShape(space, cp.BoxShapeNew(body, width, height))
	cp.ShapeSetElasticity(shape, 0.0)
	cp.ShapeSetFriction(shape, 0.7)
}

func tumbleAddSegment(space *cp.Space, pos cp.Vect, mass, width, height cp.Float) {
	body := cp.SpaceAddBody( space, cp.BodyNew(mass, cp.MomentForBox(mass, width, height)) )
	cp.BodySetPos(body, pos)

	shape := cp.SpaceAddShape(space, cp.SegmentShapeNew(body, cp.V(0.0, (height - width)/2.0), cp.V(0.0, (width - height)/2.0), width/2.0))
	cp.ShapeSetElasticity(shape, 0.0)
	cp.ShapeSetFriction(shape, 0.7)
}

func tumbleAddCircle(space *cp.Space, pos cp.Vect, mass, radius cp.Float) {
	body := cp.SpaceAddBody( space, cp.BodyNew(mass, cp.MomentForCircle(mass, 0.0, radius, cpvzero)) )
	cp.BodySetPos(body, pos)

	shape := cp.SpaceAddShape(space, cp.CircleShapeNew(body, radius, cpvzero))
	cp.ShapeSetElasticity(shape, 0.0)
	cp.ShapeSetFriction(shape, 0.7)
}

func (t *tumble) Init() *cp.Space {
	C.Seed(45073)
	space := cp.SpaceNew()
	cp.SpaceSetGravity(space, cp.V(0, -600))

	rogueBoxBody := cp.BodyNew(infinity, infinity)
	cp.BodySetAngVel(rogueBoxBody, 0.4)

	a := cp.V(-200, -200)
	b := cp.V(-200,  200)
	c := cp.V( 200,  200)
	d := cp.V( 200, -200)
	seg := [][]cp.Vect {{a, b}, {b, c}, {c, d}, {d, a}}
	for i := 0; i < len(seg); i++ {
		vs := seg[i]
		shape := cp.SpaceAddShape(space, cp.SegmentShapeNew(rogueBoxBody, vs[0], vs[1], 0.0))
		cp.ShapeSetElasticity(shape, 1.0)
		cp.ShapeSetFriction(shape, 1.0)
		cp.ShapeSetLayers(shape, notGrabableMask)
	}

	mass := cp.Float(1.0)
	width := cp.Float(30.0)
	height := width*2
	for i := 0; i < 7; i++ {
		for j := 0; j < 3; j++ {
			pos := cp.V(cp.Float(i)*width - 150, cp.Float(j)*height - 150)
			switch (C.Random()%3000)/1000 {
			default:
				tumbleAddCircle(space, cp.Vadd(pos, cp.V(0.0, (height - width)/2.0)), mass, width/2.0)
				tumbleAddCircle(space, cp.Vadd(pos, cp.V(0.0, (width - height)/2.0)), mass, width/2.0)
			case 0:
				tumbleAddBox(space, pos, mass, width, height)
			case 1:
				tumbleAddSegment(space, pos, mass, width, height)
			}
		}
	}

	t.rogueBoxBody = rogueBoxBody
	return space
}

func (t *tumble) Destroy(space *cp.Space) {
	freeSpaceChildren(space)
	cp.BodyFree(t.rogueBoxBody)
	cp.SpaceFree(space)
}

