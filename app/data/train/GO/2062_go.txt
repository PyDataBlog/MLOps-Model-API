package main

import (
	"crypto/md5"
	"flag"
	"fmt"
	"log"
	"os"
	"runtime/pprof"
	"strconv"
	"sync"
)

var prefix = []byte{0x6f, 0x6a, 0x76, 0x74, 0x70, 0x75, 0x76, 0x67}
var cpuprofile = flag.String("cpuprofile", "", "write cpu profile to file")

func find(l int) {
	cg := gen(1000000000)
	c1 := hash(cg)
	c2 := hash(cg)
	c3 := hash(cg)
	c4 := hash(cg)
	c5 := hash(cg)
	c6 := hash(cg)
	c7 := hash(cg)
	c8 := hash(cg)
	c := merge(c1, c2, c3, c4, c5, c6, c7, c8)

	var p1 uint32
	var p2 uint32
	var p1s uint32
	var p2m uint32
	p1s = 32
	p2m = 0xff
	for hash := range c {
		six := uint32(hash[2] & 0xf)
		seven := uint32(hash[3] >> 4)
		if p1s != 0 {
			p1s -= 4
			p1 |= six << p1s
		}

		if p2m&(1<<six) != 0x00 {
			p2m ^= 1 << six
			p2 |= seven << ((7 - six) << 2)
		}
		fmt.Printf("part one: %08x          part two: %08x\r", p1, p2)

		if p1s == 0 && p2m == 0 {
			break
		}
	}
	fmt.Printf("part one: %08x          part two: %08x\n", p1, p2)
}

func gen(max int64) <-chan int64 {
	out := make(chan int64)
	go func() {
		var i int64
		for i = 0; i < max; i++ {
			out <- i
		}
		close(out)
	}()
	return out
}

func hash(in <-chan int64) <-chan []byte {
	out := make(chan []byte)
	go func() {
		for i := range in {
			m := md5.Sum(strconv.AppendInt(prefix, i, 10))
			if m[0] == 0x00 && m[1] == 0x00 && (m[2]&0xf0 == 0x00) {
				out <- m[:]
			}
		}
		close(out)
	}()
	return out
}

func main() {
	flag.Parse()
	if *cpuprofile != "" {
		f, err := os.Create(*cpuprofile)
		if err != nil {
			log.Fatal(err)
		}
		pprof.StartCPUProfile(f)
		defer pprof.StopCPUProfile()
	}

	find(5)
}

func merge(cs ...<-chan []byte) <-chan []byte {
	var wg sync.WaitGroup
	out := make(chan []byte, 2)

	// Start an output goroutine for each input channel in cs.  output
	// copies values from c to out until c is closed, then calls wg.Done.
	output := func(c <-chan []byte) {
		for n := range c {
			out <- n
		}
		wg.Done()
	}
	wg.Add(len(cs))
	for _, c := range cs {
		go output(c)
	}

	// Start a goroutine to close out once all the output goroutines are
	// done.  This must start after the wg.Add call.
	go func() {
		wg.Wait()
		close(out)
	}()
	return out
}
