package write

import (
    "os"
    "archive/zip"
    "io"
    "bytes"
    "io/ioutil"
    "strings"
    "fmt"
    "path/filepath"
    "bufio"
)

// ZipTargetAttempt1 : Used to zip a target File. Returns a string as a result, and an error. 
func ZipTargetAttempt1(target string) (result string, err error) {
    file, fileErr := os.Open(target) // Opens a stream to the target file 
    // Needs to check to see if the ile is relative or abs 
    defer file.Close() // defer statement runs this bit after all other code is done (eqv. to a final in try/catch)
    // ie, close stream once this function is done running 
    
    if fileErr != nil {
        err = fileErr
        return 
    } 
    
    zipper := zip.NewWriter(file) // creates a new stream writer on the given stream 
    defer zipper.Close()
    
    header := zip.FileHeader{ Name: "test.zip", Method: zip.Store }
    
    writer, writeErr := zipper.CreateHeader(&header)
    
    if writeErr != nil {
        err = writeErr
        return 
    }
    
    _, err = io.Copy(writer, file)
    
    if err != nil {
        // err = ioErr // errors.New(ioErr)
        return 
    }
        
        // Seems like code should be working 100%- but it doesnt seem to be writing the file to the disk anywhere 
    
    
    //call compressor on target file to point to stream 
    //save results of compression on file to disk in same dir 
    
    return 
    
}

// ZipTarget : Used to zip a target File. Returns the name of the created file, or an error. 
func ZipTarget(targetFile string) (newFileName string, err error) {
    
    //file, err := os.Open(targetFile) // Should use this method to get file info (ie, extension + raw name)
    //defer file.Close()
    
    //InnerPanic(err)
    
    fileContents, err := ioutil.ReadFile(targetFile) // gets contents as []byte from string filename 
    InnerPanic(err)
    
    buff := new(bytes.Buffer) // create byte buffer to use as zip file contents, basiclly 
 
    zipWriter := zip.NewWriter(buff) // buffer has io.Writer.Read() func, and can be provided to this function - due to supporting io.Writer interface
    
    fileChunks := strings.Split(targetFile, "\\")
    fileName := fileChunks[len(fileChunks) - 1]
    
    zipFile, err := zipWriter.Create(fileName) // needs to just be filename 
    InnerPanic(err)
    
    _, err = zipFile.Write(fileContents)
    InnerPanic(err)
    
    err = zipWriter.Close() 
    InnerPanic(err)
    
    fileExtension := strings.Split(fileName, ".")[1]
    newFileName = strings.Replace(targetFile, fileExtension, "zip", 1)
    
    err = ioutil.WriteFile(newFileName, buff.Bytes(), 0600) 
    InnerPanic(err)

    return 
    
}

// ZipTargetDirectory : Accepts a directory name as a string. Zips the directory, and leaves the 
//      resulting zip file in the parent directory of the given directory. This function returns 
//      the name of the created file, or an error. 
func ZipTargetDirectory(targetDirectory string) (newFileName string, err error) {
    
    files, err := ioutil.ReadDir(targetDirectory)
    InnerPanic(err)
    
    // create zip file, write byte as file to zip 
    buff := new(bytes.Buffer) // create byte buffer to use as zip file contents, basiclly 
    zipWriter := zip.NewWriter(buff)
    
    for _, file := range files {
        // fileData := new([]byte)
        if file.IsDir() {
            // call rec method here 
            // pull all files from lower dir and move to correct dir in new zip method 
            // assembleZippedDir(file.Name())
        } else {
            // create new file in zip 
            // get bytes from file 
            // add to file in zip 
            // move on to next file 
            fileData := new([]byte) // get from file 
            zipFile, err := zipWriter.Create(file.Name()) // needs to just be filename 
            InnerPanic(err)
    
            _, err = zipFile.Write(*fileData)
            InnerPanic(err)
        }
    }
    
    err = zipWriter.Close() 
    InnerPanic(err)
    
    return 
}

// AssembleZip : Assembles a target directory into a zip file 
func AssembleZip(targetDirectory string) (newName string, err error) {
    
    files, err := ioutil.ReadDir(targetDirectory)
    
    buff := new(bytes.Buffer) 
    zipWriter := zip.NewWriter(buff)
    
    contents := new([]byte)
    
    for _, file := range files {
        if file.IsDir() {
           // TODO: try to use fileHeader to get this wokring..   (zipWriter.CreateHeader())
           writer, err := zipWriter.Create(file.Name())
           InnerPanic(err)
           
           // get dir as bytes 
            dirFile, err := os.Open(targetDirectory + "\\" + file.Name())
            InnerPanic(err)
            
            scanner := bufio.NewScanner(dirFile)
            scanner.Split(bufio.ScanBytes)
            
            //creates a file, but the file is empty, and does not properly identify as a dir 
            for scanner.Scan() {
                // move bytes to writer 
                fmt.Println(scanner.Bytes())
                n, err := writer.Write(scanner.Bytes())
                InnerPanic(err)
                
                fmt.Println(n)
            }
       } else {
            contents = getFileBytes(targetDirectory + "\\" + file.Name())
            InnerPanic(err)
       }
        
        // write whatever file we are currently on to zip file 
        zipFile, err := zipWriter.Create(file.Name()) // needs to just be filename, relative path 
        InnerPanic(err)
        
        _, err = zipFile.Write(*contents)
        InnerPanic(err)
    }
    
    err = zipWriter.Close() 
    InnerPanic(err)
    
    
    err = ioutil.WriteFile(filepath.VolumeName(targetDirectory) + "\\test.zip", buff.Bytes(), 0600) 
    InnerPanic(err)
    
    return 
}

func getFileBytes(file string)  (*[]byte) {
    contentsValue, err := ioutil.ReadFile(file)
    InnerPanic(err)
    return &contentsValue
}

func getDirBytes(dir string) (contents *[]byte) {
    // here we need to get all files in dir 
    // build a []byte as needed to give to zip file, and return that to be written to zip file 
    // any other dirs in this file have this method called on it as well 
    
    files, err := ioutil.ReadDir(dir)
    InnerPanic(err)
    
    for _, f := range files {
        b, err := ioutil.ReadFile(f.Name())
        //Create file Header 
        //Write file to directory 
        //Write bytes to file 
        //Close 
        
        InnerPanic(err)
        
        if b == nil {
            break
        }
    }
    
    //return bytes for dir 
    
    return 
}

// InnerPanic : Calls panic if the provided error is not nil.
func InnerPanic(err error) {
    // This is piss awful error handling, but a decent testing method 
    if err != nil {
        fmt.Println(err)
        panic(err)
    }
}