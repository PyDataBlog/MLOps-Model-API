/*

Gzips and deletes log files generated by glog http://github.com/golang/glog


Basic usage:

	glogrotate -base=/var/log -maxage=240h myapp myotherapp

glogrotate will not touch the current log files. There are different timeouts for the INFO, WARNING, and ERROR log levels.

*/
package main

import (
	"flag"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"
)

const (
	defaultDeleteInfoAfter = 30 * 24 * time.Hour
	defaultWarnMult        = 2
	defaultErrorMult       = 3
)

var (
	base            = flag.String("base", "/var/log/", "log subdir")
	deleteInfoAfter = flag.Duration("maxage", defaultDeleteInfoAfter, "delete INFO files older than this")
	warnMult        = flag.Int("warn", defaultWarnMult, "multiplier relative to maxage for WARNING files")
	errorMult       = flag.Int("error", defaultErrorMult, "multiplier relative to maxage for ERROR/FATAL files")
	verbose         = flag.Bool("v", false, "verbose")
)

func main() {
	flag.Parse()

	for _, log := range flag.Args() {
		clean(*base+"/"+log, log)
	}
}

func clean(dir, name string) {
	if *verbose {
		fmt.Printf("clean %s/%s*...\n", dir, name)
	}
	fs, err := filepath.Glob(dir + "/" + name + "*")
	if err != nil {
		fatalf("file error: %s", err)
	}

	doNotTouch := map[string]struct{}{}
	var candidates []string

	for _, f := range fs {
		if t, err := os.Readlink(f); err == nil {
			// it's a symlink to the current file.
			a := filepath.Join(filepath.Dir(f), t)
			doNotTouch[a] = struct{}{}
			continue
		}
		candidates = append(candidates, f)
	}

	for _, f := range candidates {
		if _, ok := doNotTouch[f]; ok {
			if *verbose {
				fmt.Printf("don't touch: %s\n", f)
			}
			continue
		}
		// we want the date from 'one.rz-reqmngt1-eu.root.log.ERROR.20150320-103857.29198'
		// (might have a .gz suffix)
		fields := strings.Split(f, ".")
		if len(fields) < 3 {
			fatalf("unexpected filename: %q", f)
		}
		if fields[len(fields)-1] == `gz` {
			fields = fields[:len(fields)-1]
		}
		var dAfter time.Duration
		level := fields[len(fields)-3]
		switch level {
		case "INFO":
			dAfter = *deleteInfoAfter
		case "WARNING":
			dAfter = time.Duration(*warnMult) * (*deleteInfoAfter)
		case "ERROR", "FATAL":
			dAfter = time.Duration(*errorMult) * (*deleteInfoAfter)
		default:
			fatalf("weird log level: %q", level)
		}
		d, err := time.Parse("20060102", strings.SplitN(fields[len(fields)-2], "-", 2)[0])
		if err != nil {
			fatalf("invalid date: %s", err)
		}
		if d.Before(time.Now().Add(-dAfter)) {
			if *verbose {
				fmt.Printf("delete %s\n", f)
			}
			os.Remove(f)
			continue
		}
		if !strings.HasSuffix(f, ".gz") {
			if *verbose {
				fmt.Printf("gzipping %s...\n", f)
			}
			if err := exec.Command("gzip", f).Run(); err != nil {
				fatalf("gzip: %s", err)
			}
		}
	}
}

func fatalf(f string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, f, args)
	fmt.Fprint(os.Stderr, "\n")
	os.Exit(1)
}
