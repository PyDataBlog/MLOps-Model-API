package uriuti

import (
	
  "bytes"
  "crypto/tls"
  "errors"
  "io/ioutil"
  "net/http"
  "text/template"
  "strings"
 
)

//Relaces parameters to values in SOAP/REST URLs
func BuildURL(urlTemplate string, data map[string]interface{}) (url string, err error) {
  //Avoind Panic Crashing
  defer func() {
    if err := recover(); err != nil {
      errMsg := err.(string) + " : Panic recovered in BuildURL"
      err = errors.New(errMsg)
    }
  }() 

  t:= template.Must(template.New("url").Parse(urlTemplate))
  buf := &bytes.Buffer{}
  if err := t.Execute(buf, data); err != nil {
      return "", errors.New(err.Error() + ": Problem when adding parameters to URL REST/SOAP")
  }
  s := buf.String()

  return s, nil
  
}

//Executes REST resquest to the specific URL
func CallURLREST(URL string, user string, pass string, methodCall string) (in string, err error){
  
  //Avoind Panic Crashing
  defer func() {
    if err := recover(); err != nil {
      errMsg := err.(string) + " : Panic recovered in CallURLREST"
      err = errors.New(errMsg)
    }
  }() 
  var bodyParams string
  var jsonStr []byte 
 
  if methodCall == "POST" {

    bodyParams = URL[strings.Index(URL, "{"): len(URL)]
    URL = URL[0: strings.Index(URL, "{")]
    jsonStr = []byte(bodyParams)

  }

  //Adding security header
  //Build the request
  req, err := http.NewRequest(methodCall, URL, bytes.NewBuffer(jsonStr))
  if err != nil {
    err = errors.New(err.Error() + ": New request Error")
    return
  }

  //adding security to header
  req.Header.Add(user, pass)

  // For control over HTTP client headers,
  // redirect policy, and other settings,
  // create a Client
  // A Client is an HTTP client
  
  tr := &http.Transport{
    TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
  }
  client := &http.Client{Transport: tr}
  

  // Send the request via a client
  // Do sends an HTTP request and
  // returns an HTTP response
  resp, err := client.Do(req)
  if err != nil {
    err = errors.New(err.Error() + ": Error sending request")
    return
  }

  body, err := ioutil.ReadAll(resp.Body) 
  if err != nil {
    err = errors.New(err.Error() + ": Error accesing body data in REST call")
    return
  }

  // Callers should close resp.Body
  // when done reading from it
  // Defer the closing of the body
  defer resp.Body.Close()

  //parsing body response
  in = string(body)

  return in, nil

}

//Executes SOAP resquest to the specific URL
func CallURLSOAP(URL string, soapMessage string) (in string, err error) {

  //Avoind Panic Crashing
  defer func() {
    if err := recover(); err != nil {
      errMsg := err.(string) + " : Panic recovered in CallURLSOAP"
      err = errors.New(errMsg)
    }
  }() 
  
  tr := &http.Transport{
    TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
  }
  
  httpClient := &http.Client{Transport: tr}
  
  resp, err := httpClient.Post(URL, "text/xml; charset=utf-8", bytes.NewBufferString(soapMessage)) 
  if err != nil {
    err = errors.New(err.Error() + ": Error calling SOAP webservice")
  }
  body, err := ioutil.ReadAll(resp.Body) 
  if err != nil {
    err = errors.New(err.Error() + ": Error accesing body data in Soap call")
    return
  }
  
  // Callers should close resp.Body
  // when done reading from it
  // Defer the closing of the body
  defer resp.Body.Close()
  
  //parsing body response
  in = string(body)

  return in, nil

}
