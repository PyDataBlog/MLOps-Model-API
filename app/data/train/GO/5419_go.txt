package main

import "fmt"

// Here’s a function that takes two ints and returns their sum as an int.
func plus(a int, b int) int {
	// Go requires explicit returns, i.e. it won’t automatically return the value of the last expression.
	return a + b
}

// When you have multiple consecutive parameters of the same type, you may omit the type name for the like-typed parameters
// up to the final parameter that declares the type.
func plusPlus(a, b, c int) int {
	return a + b + c
}

// Go has built-in support for multiple return values.
// This feature is used often in idiomatic Go, for example to return both result and error values from a function.

// The (int, int) in this function signature shows that the function returns 2 ints.
func vals() (int, int) {
	return 3, 7
}

// Variadic functions can be called with any number of trailing arguments.
// This means accepting a variable number of arguments.
// For example, fmt.Println is a common variadic function.

// Here’s a function that will take an arbitrary number of ints as arguments.
func sum(nums ...int) {
	fmt.Print(nums, " ")
	total := 0
	for _, num := range nums {
		total += num
	}
	fmt.Println(total)
}

func mult(nums ...int) int {

	total := 1
	fmt.Println(nums)
	for _, num := range nums {
		total *= num
	}

	return total
}

// Go supports anonymous functions, which can form closures.
// Anonymous functions are useful when you want to define a function inline without having to name it.

// This function intSeq returns another function, which we define anonymously in the body of intSeq.
// The returned function closes over the variable i to form a closure.

func intSeq() func() int {
	i := 0
	return func() int {
		i++
		return i
	}
}

// This fact function calls itself until it reaches the base case of fact(0).

func fact(n int) int {
	if n == 2 {
		return 2
	}
	return n * fact(n-1)
}

// Go supports pointers, allowing you to pass references to values and records within your program.

// We’ll show how pointers work in contrast to values with 2 functions: zeroval and zeroptr.
// zeroval has an int parameter, so arguments will be passed to it by value.
// zeroval will get a copy of ival distinct from the one in the calling function.
func zeroval(ival int) {
	ival = 0
}

// zeroptr in contrast has an *int parameter, meaning that it takes an int pointer.
// The *iptr code in the function body then dereferences the pointer from its memory address to the current value at that address.
// Assigning a value to a dereferenced pointer changes the value at the referenced address.
func zeroptr(iptr *int) {
	*iptr = 0
}

// Go’s structs are typed collections of fields.
// They’re useful for grouping data together to form records.

type person struct {
	name string
	age  int
}

// Go supports methods defined on struct types.
type rect struct {
	width, height int
}

// This area method has a receiver type of *rect.
func (r *rect) area() int {
	return r.height * r.width
}

// Methods can be defined for either pointer or value receiver types.
// Here’s an example of a value receiver.
func (r rect) perim() int {
	return 2*r.width + 2*r.height
}

func main() {

	// Maps are Go’s built-in associative data type (sometimes called hashes or dicts in other languages).
	// To create an empty map, use the builtin make: make(map[key-type]val-type).
	// Set key/value pairs using typical name[key] = val syntax.

	newMap := make(map[string]int)

	newMap["k1"] = 7
	newMap["k2"] = 13

	// Printing a map with e.g. Println will show all of its key/value pairs.
	fmt.Println("map:", newMap)

	// Get a value for a key with name[key].
	v1 := newMap["k1"]
	fmt.Println("v1:", v1)

	// The builtin len returns the number of key/value pairs when called on a map.
	fmt.Println("len:", len(newMap))

	// The builtin delete removes key/value pairs from a map.
	delete(newMap, "k2")
	fmt.Println("map:", newMap)

	// The optional second return value when getting a value from a map indicates if the key was present in the map.
	// This can be used to disambiguate between missing keys and keys with zero values like 0 or "".
	// Here we didn’t need the value itself, so we ignored it with the blank identifier _.
	_, prs := newMap["k2"]
	fmt.Println("prs:", prs)

	_, chk := newMap["k1"]
	fmt.Println("chk:", chk)

	// You can also declare and initialize a new map in the same line with this syntax.
	otherMap := map[string]int{"foo": 1, "bar": 2}
	fmt.Println("map:", otherMap)

	// range iterates over elements in a variety of data structures.
	// Let’s see how to use range with some of the data structures we’ve already learned.

	// Here we use range to sum the numbers in a slice. Arrays work like this too.
	numbers := []int{2, 3, 4}
	sumOfNumbers := 0
	for _, num := range numbers {
		sumOfNumbers += num
	}
	fmt.Println("sum:", sumOfNumbers)

	// range on arrays and slices provides both the index and value for each entry.
	// Above we didn’t need the index, so we ignored it with the blank identifier _.
	// Sometimes we actually want the indexes though.
	for i, num := range numbers {
		if num == 3 {
			fmt.Println("index:", i)
		}
	}

	// range on map iterates over key/value pairs.
	kvs := map[string]string{"a": "apple", "b": "banana"}
	for k, v := range kvs {
		fmt.Printf("%s -> %s\n", k, v)
	}
	// range can also iterate over just the keys of a map.
	for k := range kvs {
		fmt.Println("key:", k)
	}

	// range on strings iterates over Unicode code points. The first value is the starting byte index of the rune and the second the rune itself.
	for i, c := range "go" {
		fmt.Println(i, c)
	}

	// Functions
	result := plus(1, 2)
	fmt.Println("1+2=", result)

	result = plusPlus(1, 2, 3)
	fmt.Println("1+2+3=", result)

	// Here we use the 2 different return values from the call with multiple assignment.
	first, second := vals()
	fmt.Println(first)
	fmt.Println(second)

	// If you only want a subset of the returned values, use the blank identifier _.
	_, second = vals()
	fmt.Println(second)

	// Variadic functions can be called in the usual way with individual arguments.
	sum(1, 2)
	sum(1, 2, 3)

	// If you already have multiple args in a slice, apply them to a variadic function using func(slice...) like this.
	nums := []int{1, 2, 3, 4}
	sum(nums...)

	fmt.Println("mult =", mult(2, 3, 5))

	// Closures.
	// We call intSeq, assigning the result (a function) to nextInt.
	// This function value captures its own i value, which will be updated each time we call nextInt.
	nextInt := intSeq()

	// See the effect of the closure by calling nextInt a few times.
	fmt.Println(nextInt())
	fmt.Println(nextInt())
	fmt.Println(nextInt())

	// To confirm that the state is unique to that particular function, create and test a new one.
	newInts := intSeq()
	fmt.Println(newInts())

	// Recursive function
	fmt.Println(fact(7))

	// Pointers
	i := 1
	fmt.Println("initial:", i)

	zeroval(i)
	fmt.Println("zeroval:", i)

	// The &i syntax gives the memory address of i, i.e. a pointer to i.
	zeroptr(&i)
	fmt.Println("zeroptr:", i)

	// Pointers can be printed too.
	fmt.Println("pointer:", &i)

	// zeroval doesn’t change the i in main, but zeroptr does because it has a reference to the memory address for that variable.

	// Structs
	// This syntax creates a new struct.
	fmt.Println(person{"Bob", 20})

	// You can name the fields when initializing a struct.
	fmt.Println(person{name: "Alice", age: 30})

	// Omitted fields will be zero-valued.
	fmt.Println(person{name: "Fred"})

	// A & prefix yields a pointer to the struct.
	fmt.Println(&person{name: "Ann", age: 40})

	// Access struct fields with a dot.
	s := person{"Sean", 50}
	fmt.Println(s.name)

	// You can also use dots with struct pointers,
	// The pointers are automatically dereferenced.
	sp := &s
	fmt.Println(sp.age)

	// Methods.
	// Structs are mutable.
	sp.age = 51
	fmt.Println(sp.age)

	r := rect{width: 10, height: 5}

	fmt.Println("area: ", r.area())
	fmt.Println("perim: ", r.perim())

	// Go automatically handles conversion between values and pointers for method calls.
	// You may want to use a pointer receiver type to avoid copying on method calls or to allow the method to mutate the receiving struct.
	rp := &r
	fmt.Println("area: ", rp.area())
	fmt.Println("perim:", rp.perim())
}
