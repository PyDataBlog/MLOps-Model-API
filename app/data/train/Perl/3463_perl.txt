package Sleipnir::Promise;
use Moo;

use Function::Parameters ':strict';
use Types::Standard qw/ InstanceOf Bool /;
use Carp qw/ confess /;
use Sleipnir::Future;
use Sleipnir::Try::Utils;

use parent 'Exporter';
BEGIN { our @EXPORT = qw/ promise / }

use namespace::clean;

has future => (
    is      => 'lazy',
    isa     => InstanceOf['Sleipnir::Future'],
    builder => '_build_future',
);

has completed => (
    is      => 'rwp',
    isa     => Bool,
    default => 0,
);

method _build_future {
    Sleipnir::Future::_mk_future; # identity
}

fun promise() { __PACKAGE__->new }

method fulfill($value) {
    confess "Can't fulfill an already completed promise" if $self->completed;
    $self->_set_completed(1);
    $self->future->_trigger->send( Try->check($value) ? $value : success $value);
    ()
}

method break($msg) {
    confess "Can't break an already completed promise" if $self->completed;
    $self->_set_completed(1);
    $self->future->_trigger->send( Try->check($msg) ? $msg : failure $msg);
    ()
}

1;
