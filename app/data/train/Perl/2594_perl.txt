#!/usr/bin/perl

use warnings;
use strict;

use File::Find::Rule;           # depends on Text::Glob

open my $ifh, '<', 'bindings.hh';

my %expected_types;
while (<$ifh>) {
  if (/int32_t +(\w+)\(.*?,.*?, *(.*?)\);/) {
    $expected_types{$1} = $2;
  }
}

close $ifh;

my @register_bindings;

open my $ofh, '>', 'thebindings.cc';

print $ofh <<EOD;
// This file was GENERATED by bindings.pl.

#include <cstdint>                 // for int32_t
#include <cstdlib>                 // for size_t
#include "config.h"
#include "bindings.hh"
#include "install.hh"              // for MAX_DIMS
#if HAVE_LIBSOFA_C
# include "sofa.h"
#endif
#include "historicephemerides.h"

int32_t luxerror(char const*, int32_t, ...);

EOD

my @files = File::Find::Rule->name('*.cc')->in('.');
print "Treating " . scalar(@files) . " files.\n";

foreach my $file (@files) {
  open $ifh, '<', $file;
  while (<$ifh>) {
    my @data;
    if (/^BIND\((.*?)\)/) {
      @data = split /\s*,\s*/, $1;
      my $f = "lux_$data[1]_$data[2]_";
      my $declare = $expected_types{$f};
      if (not $declare) {
        print "NOT FOUND: $f from line $. in $file\n";
        exit(1);
      }
      $declare =~ s/\(.*?\)/$data[0]/;
      print $ofh "#if $data[7]\n" if $data[7];
      print $ofh <<~EOD;
      int32_t lux_$data[0]_$data[2](int32_t narg, int32_t ps[]) {
        $declare;
        int32_t result = $f(narg, ps, $data[0]);
        if (result < 0)
          luxerror("Error in $data[3]", 0);
        return result;
      }
      EOD
      print $ofh "#endif\n" if $data[7];
      print $ofh "\n";
      {
        my $text = '';
        $text .= "#if $data[7]\n" if $data[7];
        $text .= "  register_lux_$data[2](lux_$data[0]_$data[2], \"$data[3]\", $data[4], $data[5], $data[6]);\n\n";
        $text .= "#endif\n" if $data[7];
        push @register_bindings, $text;
      }
    } elsif (/^REGISTER\((.*?)\)/) {
      @data = split /\s*,\s*/, $1;
      {
        my $text = '';
        $text .= "#if $data[6]\n" if $data[6];
        $text .= <<~EOD;
          int32_t lux_$data[0](int32_t, int32_t []);
          register_lux_$data[1](lux_$data[0], "$data[2]", $data[3], $data[4], $data[5]);
        EOD
        $text .= "#endif\n" if $data[6];
        $text .= "\n";
        push @register_bindings, $text;
      }
    }
  }
  close $ifh;
}

print $ofh <<EOD;
void register_the_bindings()
{
EOD
foreach my $b (@register_bindings) {
  print $ofh $b;
}
print $ofh <<EOD;
}
EOD
close $ofh;

#     #define REGISTER(func, fs, name, minarg, maxarg, fsspec)        \
# void register_lux_ ## func ## _ ## fs (void) __attribute__((constructor)); \
# void register_lux_ ## func ## _ ## fs (void) { \
#   register_lux_ ## fs( lux_ ## func, #name, minarg, maxarg, fsspec );    \
# }

# #define BIND(func, type, fs, name, minarg, maxarg, fsspec)      \
# int32_t lux_ ## func ## _ ## fs(int32_t narg, int32_t ps[]) { \
#  int32_t result = lux_ ## type ## _ ## fs ## _(narg, ps, func); \
#  if (result < 0) luxerror("Error in " #name, 0); \
#  return result; \
# } \
# REGISTER(func ## _ ## fs, fs, name, minarg, maxarg, fsspec)

