#!/usr/bin/perl
#
# RRD script to display hardware temperature
# 2003,2007,2011 (c) by Christian Garbs <mitch@cgarbs.de>
# Licensed under GNU GPL.
#
# This script should be run every 5 minutes.
#
use strict;
use warnings;
use Device::SMBus;
use Time::HiRes qw( usleep ualarm gettimeofday tv_interval nanosleep
		    clock_gettime clock_getres clock_nanosleep clock
		    stat );

use Data::Dumper;

package Rrdpi::BarometricPressure;

# Define the sensor registers. Many of these store calibration data
# which is used to calculate temperature compensated pressure readings.
use constant BMP180_CAL_AC1		=> 0xAA;	# Calibration data (16 bit)
use constant BMP180_CAL_AC2		=> 0xAC;	# Calibration data (16 bit) 
use constant BMP180_CAL_AC3		=> 0xAE;	# Calibration data (16 bit)
use constant BMP180_CAL_AC4		=> 0xB0;	# Calibration data (16 bit)
use constant BMP180_CAL_AC5		=> 0xB2;	# Calibration data (16 bit)
use constant BMP180_CAL_AC6		=> 0xB4;	# Calibration data (16 bit)
use constant BMP180_CAL_B1		=> 0xB6;	# Calibration data (16 bit)
use constant BMP180_CAL_B2		=> 0xB8;	# Calibration data (16 bit)
use constant BMP180_CAL_MB		=> 0xBA;	# Calibration data (16 bit)
use constant BMP180_CAL_MC		=> 0xBC;	# Calibration data (16 bit)
use constant BMP180_CAL_MD		=> 0xBE;	# Calibration data (16 bit)
use constant BMP180_CONTROL		=> 0xF4;
use constant BMP180_TEMPDATA		=> 0xF6;
use constant BMP180_PRESSUREDATA	=> 0xF6;
use constant BMP180_READTEMPCMD		=> 0x2E;
use constant BMP180_READPRESSURECMD	=> 0x34;

# Define a standard list of operating modes for the sensor.
# These control the number of samples per second that the 
# sensor takes internally.
use constant BMP180_ULTRALOWPOWER	=> 0;
use constant BMP180_STANDARD		=> 1;
use constant BMP180_HIRES		=> 2;
use constant BMP180_ULTRAHIRES		=> 3;

sub new
{
	my ($class, $conf) = @_;
	my $self = {conf => $conf};
	bless( $self, $class );
	$self->{rrdParams} = $self->getRrdParams();
	
	# Instantiate an SMBus object referring to the correct I2C bus
	# and the device address of the sensor. The Adafruit BMP180
	# sensor always has an address of 0x77. The rev2 RPi puts the
	# primary I2C bus on i2c-1. The rev1 uses i2c-0.

	$self->{bmp180} = Device::SMBus->new(
	  I2CBusDevicePath => '/dev/i2c-1',
	  I2CDeviceAddress => 0x77,
	);
		
	$self->{cal_AC1} = $self->readS16(BMP180_CAL_AC1);
	$self->{cal_AC2} = $self->readS16(BMP180_CAL_AC2);
	$self->{cal_AC3} = $self->readS16(BMP180_CAL_AC3);
	$self->{cal_AC4} = $self->readU16(BMP180_CAL_AC4);
	$self->{cal_AC5} = $self->readU16(BMP180_CAL_AC5);
	$self->{cal_AC6} = $self->readU16(BMP180_CAL_AC6);
	$self->{cal_B1}  = $self->readS16(BMP180_CAL_B1);
	$self->{cal_B2}  = $self->readS16(BMP180_CAL_B2);
	$self->{cal_MB}  = $self->readS16(BMP180_CAL_MB);
	$self->{cal_MC}  = $self->readS16(BMP180_CAL_MC);
	$self->{cal_MD}  = $self->readS16(BMP180_CAL_MD);

	return $self;
}

sub getRrdParams
{
	my ($self) = @_;
	 
	return {
		name => 'pressure',
		datafiles => [$self->{conf}->{DBPATH}."/pressure.rrd"],
		picBase => [$self->{conf}->{OUTPATH}."/pressure-"],
		DS => ['pressure'],
		DSChecks => [],
		DSDescr => ['Barometric pressure'],
		rrdCreate => [
			 'DS:pressure:GAUGE:300:500:1000',
			 ],
		graphTitles => [''],
		rrdGraph => [
			'--imgformat=PNG',
			'--title=Barometric pressure (mmHg)',
			"--width=".$self->{conf}->{GRAPH_WIDTH},
			"--height=".$self->{conf}->{GRAPH_HEIGHT},
			'--alt-autoscale',
#			'--slope-mode',
			'DEF:pressure=DATAFILE:pressure:AVERAGE',
			'AREA:pressure#3FCC50:pressure',
			'COMMENT:\n',
			'COMMENT:\n',
			]
		};
}

sub gather 
{	
	my ($self) = @_;
	# Call the compensated pressure function to print barometric pressure
#	my $Temperature = $self->readTemp();
	my $pressureHPa = $self->readPressure(BMP180_STANDARD) / 100.0;
	my $pressuremmHg = $pressureHPa*0.75006375541921;

	return ["N:$pressuremmHg"];
}


sub readS8 {
	my ($self, $register) = @_;

	my $readVal = $self->{bmp180}->readByteData($register);
	if($readVal > 127) {
		$readVal -= 256;
	}
	return $readVal;
}

sub readS16 {
	my ($self, $register) = @_;
	my $readValHi = $self->readS8($register);
	my $readValLo = $self->{bmp180}->readByteData($register+1);
	my $bufferHi = $readValHi << 8;
	my $retVal = $bufferHi + $readValLo;
	return $retVal;
}

sub readU16 {
	my ($self,$register) = @_;
        my $readValHi = $self->{bmp180}->readByteData($register);
        my $readValLo = $self->{bmp180}->readByteData($register+1);
	my $bufferHi = $readValHi << 8;
	my $retVal = $bufferHi + $readValLo;
	return $retVal;
}

sub readRawTemp {
	my ($self) = @_;
	$self->{bmp180}->writeByteData(BMP180_CONTROL,BMP180_READTEMPCMD);
	# usleep takes microseconds, so this is 5 milliseconds
	Time::HiRes::usleep(5000);
	my $rawTemp = $self->readU16(BMP180_TEMPDATA);
	return $rawTemp;
}

# Read the raw (uncompensated) barometric pressure from the sensor

sub readRawPressure {
	my ($self,$mode) = @_;
	my $writeVal = BMP180_READPRESSURECMD + ($mode << 6);
	$self->{bmp180}->writeByteData(BMP180_CONTROL,$writeVal);
	if ($mode == BMP180_ULTRALOWPOWER) {
		Time::HiRes::usleep(5000);
	}
	elsif ($mode == BMP180_HIRES) {
		Time::HiRes::usleep(14000);
	}
	elsif ($mode == BMP180_ULTRAHIRES) {
		Time::HiRes::usleep(26000);
	}
	else {
		Time::HiRes::usleep(8000);
	}
	my $msb = $self->{bmp180}->readByteData(BMP180_PRESSUREDATA);
	my $lsb = $self->{bmp180}->readByteData(BMP180_PRESSUREDATA+1);
	my $xlsb = $self->{bmp180}->readByteData(BMP180_PRESSUREDATA+2);
	my $rawPressure = (($msb << 16) + ($lsb << 8) + $xlsb) >> (8 - $mode);
	
	return $rawPressure;
}

# Read the compensated temperature

sub readTemp {
	my ($self) = @_;
	my $UT = 0;
	my $X1 = 0;
	my $X2 = 0;
	my $B5 = 0;
	my $temp = 0.0;

	$UT = $self->readRawTemp();
	use integer;
	$X1 = (($UT - $self->{cal_AC6}) * $self->{cal_AC5}) >> 15;
	$X2 = ($self->{cal_MC} << 11) / ($X1 + $self->{cal_MD});
	$B5 = $X1 + $X2;
	no integer;
	$temp = (($B5 + 8) >> 4) / 10.0;
	return $temp;
}

# Read the compensated barometric pressure

sub readPressure {
	my ($self,$mode) = @_;
	my $UT = $self->readRawTemp();
	my $UP = $self->readRawPressure($mode);

	# Calculate true temperature, but don't convert to simple output format yet
	use integer;	
	my $X1 = (($UT - $self->{cal_AC6}) * $self->{cal_AC5}) >> 15;
	my $X2 = ($self->{cal_MC} << 11) / ($X1 + $self->{cal_MD});
	my $B5 = $X1 + $X2;
	no integer;
	my $temp = (($B5 + 8) >> 4) / 10.0;

	# Calculate compensated pressure
	use integer;	
	my $B6 = $B5 - 4000;
	#printf "B6 = $B6\n";
	$X1 = ($self->{cal_B2} * ($B6 * $B6) >> 12) >> 11;
	#printf "X1 = $X1\n";	
	$X2 = ($self->{cal_AC2} * $B6) >> 11;
	my $X3 = $X1 + $X2;
	my $B3 = ((($self->{cal_AC1} * 4 + $X3) << $mode) + 2) /4;
	$X1 = ($self->{cal_AC3} * $B6) >> 13;
	$X2 = ($self->{cal_B1} * (($B6 * $B6)) >> 12 ) >> 16;
	$X3 = (($X1 + $X2) + 2) >> 2;
	my $B4 = ($self->{cal_AC4} * ($X3 + 32768)) >> 15;
	my $B7 = ($UP - $B3) * (50000 >> $mode);
	my $p = 0;
	if ($B7 < 0x80000000) {
		$p = ($B7 * 2) / $B4;
	} else {
		$p = ($B7 / $B4) * 2;
	}
	$X1 = ($p >> 8) * ($p >> 8);
	$X1 = ($X1 * 3038) >> 16;
	$X2 = (-7357 * $p) >> 16;
	$p = $p + (($X1 + $X2 + 3791) >> 4);
	#printf "Calibration pressure is %d Pa\n", $p;
	return $p;
}

1;
