-- @Author: Gillett Hernandez
-- @Date:   2016-03-21 22:33:46
-- @Last Modified by:   Gillett Hernandez
-- @Last Modified time: 2016-08-02 12:54:28
"""
5 by 4
X is 1 down, 2 across
X neighbors are (X.x, X.y-1), (X.x+1, X.y-1), (X.x-1, X.y), (X.x+1, X.y), (X.x, X.y+1), (X.x+1, X.y+1)

C C C C C
 C C X C C
C C C C C
 C C C C C
"""

indexer = {0:3, 1:4, 2:5, 3:0, 4:1, 5:2}

function transform_to_string(L):
    return L.join('')
end

function shift(L, i)
    L = L[:]
    for k in range(i) do
        L.append(L.shift())
    end
    return L
end

function shiftstring(S, i)
    return "".join(shift(S.split(""), i))
end

temprules = {"100100":"001001",
                 "101100":"010011",
                 "011010":"100101",
                 "101010":"101010",
                 "110110":"101101"}

rules = {}


for rule in temprules do
    for j in range(6) do
        rulei = shiftstring(rule, j)
        ruleresult = temprules[rule]
        ruleresulti = shiftstring(ruleresult, j)
        print(rulei + " " + ruleresulti)
        if rulei not in rules then
            rules[rulei] = ruleresulti
            print(rulei + " - " + rules[rulei])
        end
    end
end

print(transform_to_string([0,0,0,1,0,0]))

cells = {}

function class(name)
    o = {}
    o.type = name
    return o
end

function list(o):
    o = o or {}
    o["0"]

cell = class("cell")

function cell:__init__(x, y, ins):
    self.x = x
    self.y = y
    self.outs = [0, 1, 0, 0, 0, 0]  # something like [0,0,0,1,0,1] which would translate to pushing (down right) and (to the left)
    self.ins = ins  # something like [0,1,0,0,1,0] would translate to in at top right and at bottom left
    self.nextouts = list{0, 0, 0, 0, 0, 0}

function cell:initialize():
    self.neighborhood = []
    self.neighborhood.push(cells[self.x][self.y-1])
    self.neighborhood.push(cells[self.x+1][self.y-1])
    self.neighborhood.push(cells[self.x][self.y])
    self.neighborhood.push(cells[self.x+1][self.y])
    self.neighborhood.push(cells[self.x][self.y+1])
    self.neighborhood.push(cells[self.x+1][self.y+1])

function cell:update():
    thisIns = transform_to_string(self.ins)
    if (thisIns in rules) then
        self.nextouts = rules[thisIns]
    end

    for i in range(6) do
        if (self.outs[i]) then
            self.neighborhood[i].ins[indexer[i]] = 1
        end
    end

    self.outs = self.nextouts


for i in range(10) do
    cells[i] = []
    for k in range(10) do
        cells[i].push(new cell(i, k, [0,1,0,1,1,0]))
    end
end

print(rules[transform_to_string([0,1,0,1,0,1])])


for i in range(9) do
    for k in range(9) do
        cells[i][k].initialize()
    end
end

factor = 3

function draw()

    background(255, 255, 255)
    for i in range(9) do
        for k in range(9) do
            scell = cells[i][k]
            scell.update()
            for j in range(6) do
                if (scell.ins[j] == 1) then
                    pass()
                end
            end
        end
    end
end
