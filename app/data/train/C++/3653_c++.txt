/*
 * distance.cpp
 *
 *  Created on: 18 May 2016
 *      Author: junior
 */

#include "distance.hpp"

using namespace std;
using namespace cv;

namespace clustering {
namespace distance {

DistanceCalculator::DistanceCalculator(calculator cal){
	this->cal = cal;
	distance = 0;

	this->attributesOne = NULL;
	this->attributesTwo = NULL;
}

double DistanceCalculator::computeDistance(UMat attributesOne,
		UMat attributesTwo) {

	distance = 0;

	this->attributesOne = attributesOne.getMat(ACCESS_RW);
	this->attributesTwo = attributesTwo.getMat(ACCESS_RW);

	if (cal == EUCLIDEAN) {
		do_euclidean();
	} else if (cal == COSINE) {
		do_cosine();
	} else if (cal == MANHATTAN) {
		do_manhattan();
	} else if (cal == PEARSON) {
		do_pearson();
	} else if (cal == SUPREMUM) {
		do_supremum();
	}

	return distance.at<double>(Point(0,0));//distance.ptr<double>(0)[0];
}

void DistanceCalculator::do_euclidean() {
	distance = 0;

	absdiff(attributesOne, attributesTwo, distance);
	distance = distance.mul(distance);
	reduce(distance, distance, 1, REDUCE_SUM);


	/*for (unsigned int i = 0; i < attributesOne->size() && i < attributesTwo->size(); i++) {
		distance += (((*attributesOne)[i] - (*attributesTwo)[i])
				* ((*attributesOne)[i] - (*attributesTwo)[i]));
	}*/

	//distance = sqrt(distance);
}

void DistanceCalculator::do_cosine() {
	UMat dotProduct;
	UMat magnitudeOne;
	UMat magnitudeTwo;

	dotProduct = attributesOne.dot(attributesTwo);

	/*for (unsigned int i = 0; i < attributesOne->size() && i < attributesTwo->size(); i++) {
		dotProduct += ((*attributesOne)[i] * (*attributesTwo)[i]);
		magnitudeOne += ((*attributesOne)[i] * (*attributesOne)[i]);
		magnitudeTwo += ((*attributesTwo)[i] * (*attributesTwo)[i]);
	}*/

	distance = 1 - (dotProduct / (magnitudeOne * magnitudeTwo));
	reduce(distance, distance, 1, REDUCE_SUM);

}

void DistanceCalculator::do_manhattan() {

	absdiff(attributesOne, attributesTwo, distance);
	reduce(distance, distance, 1, REDUCE_SUM);

	/*for (unsigned int i = 0; i < attributesOne->size() && i < attributesTwo->size(); i++) {
		distance += abs((*attributesOne)[i] - (*attributesTwo)[i]);
	}*/
}

void DistanceCalculator::do_pearson() {
	UMat meanOne = 0;
	UMat meanTwo = 0;
/*

	for (unsigned int i = 0; i < attributesOne.size() && i < attributesTwo->size(); i++) {
		meanOne += (*attributesOne)[i];
		meanTwo += (*attributesTwo)[i];
	}
*/

	reduce(attributesOne, meanOne, 1, REDUCE_SUM);
	reduce(attributesTwo, meanTwo, 1, REDUCE_SUM);

	meanOne = meanOne / attributesOne.cols;
	meanTwo = meanTwo / attributesTwo.cols;

	UMat covariance;
	UMat standardDeviationOne;
	UMat standardDeviationTwo;



	/*for (unsigned int i = 0; i < attributesOne->size() && i < attributesTwo->size(); i++) {
		covariance += (((*attributesOne)[i] - meanOne)
				* ((*attributesTwo)[i] - meanTwo));
		standardDeviationOne += (((*attributesOne)[i] - meanOne)
				* ((*attributesOne)[i] - meanOne));
		standardDeviationTwo += (((*attributesTwo)[i] - meanTwo)
				* ((*attributesTwo)[i] - meanTwo));
	}*/

	distance = (1
			- (covariance / (standardDeviationOne * standardDeviationTwo)));
}

void DistanceCalculator::do_supremum() {

	/*for (unsigned int i = 0; i < attributesOne->size() && i < attributesTwo->size(); i++) {
		double difference = abs((*attributesOne)[i] - (*attributesTwo)[i]);
		if (difference > distance)
			distance = difference;
	}*/

}

}
}
