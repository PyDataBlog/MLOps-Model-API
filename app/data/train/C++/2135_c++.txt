/*
 * @Date     : Shandagames2018/09/02
 * @Author   : IceCory (icecory520@gmail.com)
 * @Copyright(C): GPL 3.0
 */

#include <iostream>
#include <algorithm>
#include <vector>
#include <map>
#include <tuple>

// 输入三元组(x,y,z)数量n
// 一个值a
// logn 的复杂度内找到所有的三元组(满足 y <= a <= z)并升序输出x
int main(int argc, char *argv[]) {
    using LogType = std::tuple<int, int, int>;

    size_t t = 0;
    std::cin >> t;
    int a;
    std::cin >> a;
    std::vector<LogType> log;
    log.reserve(10000);
    for (size_t i = 0; i < t; ++i) {
        int x, y, z;
        std::cin >> x >> y >> z;
        log.emplace_back(x, y, z);
    }
    auto cmp = [](const LogType &l1, const LogType &l2) -> bool {
        if (std::get<1>(l1) != std::get<1>(l2))
            return std::get<1>(l1) < std::get<1>(l2);
        if (std::get<2>(l1) != std::get<2>(l2))
            return std::get<2>(l1) < std::get<2>(l2);
    };
    std::sort(log.begin(), log.end(), cmp);
    auto A = std::make_tuple(0, a, -1);
    auto iter = std::upper_bound(log.begin(), log.end(), A, cmp);
    std::vector<int> ans;
    auto iter1 = iter;
    ans.reserve(10000);
    while (iter1 != log.end()) {
        if (a > std::get<2>(*iter))break;
        if (a < std::get<1>(*iter))break;
        ans.push_back(std::get<0>(*iter));
        iter1++;
    }
    iter--;
    while (iter != log.begin()) {
        if (a > std::get<2>(*iter))break;
        if (a < std::get<1>(*iter))break;
        ans.push_back(std::get<0>(*iter));
        iter--;
        if (iter == log.begin()) {
            if (std::get<1>(*iter) <= a <= std::get<2>(*iter))ans.push_back(std::get<0>(*iter));
        }
    }

    std::sort(ans.begin(), ans.end(), std::less<int>());
    for (auto &i:ans) {
        std::cout << i << std::endl;
    }
    // std::cout << ans << std::endl;
    return 0;
}