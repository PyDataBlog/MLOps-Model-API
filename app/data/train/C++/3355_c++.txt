// vim: bs=2:ts=4:sw=4:tw=80:noexpandtab

#ifndef FST_XISTREAM_HPP
#define FST_XISTREAM_HPP

#include "ex.hpp"

#include <string>
#include <istream>

namespace fst
{

// class that extend/modify istream methods/behaviors
// catch ios_base::failure exceptions and throws io_ex

class xistream
{
public:
	// ctor
	// del - if true, delete is on dtor
	xistream(std::istream *is, bool del = true);

	// dtor
	virtual ~xistream();

	// read up to n bytes
	xistream &read(char *buf, std::streamsize n);

	// return a reference to istream
	std::istream &get_istream() const;

	// set another istream
	void set_is(std::istream *is, bool del = true);

	// extration operator
	template <typename T>
	xistream &operator>>(T &val);

	// use >> to extract
	// check if it was extracted up to EOF
	template <typename T>
	xistream &full_extract(T &val);

	// use std::getline()
	void getline(std::string &s);

	std::istream *operator->() const;

protected:
	std::istream *_is;
	bool _del;

private:
	// release current istream
	void release_is();

	xistream(const xistream &);
	xistream operator=(const xistream &);
};


/// templates and inline functions ///

template <typename T>
xistream &xistream::operator>>(T &val)
{
	try
	{
		*_is >> val;
		return *this;
	}
	catch (const std::ios_base::failure &e)
	{
		throw EX(io_ex, e.what());
	}
}


template <typename T>
xistream &xistream::full_extract(T &val)
{
	*this >> val;

	if (!_is->eof())
		throw EX(ex, "full_extract() failed");
	return *this;
}


inline std::istream &xistream::get_istream() const
{
	return *_is;
}


inline std::istream *xistream::operator->() const
{
	return _is;
}

}	// fst

#endif
