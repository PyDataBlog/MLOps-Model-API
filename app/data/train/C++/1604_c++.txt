/*
        GWEN
        Copyright (c) 2012 Facepunch Studios
        See license in Gwen.h
 */


#include <rose/Rose.hpp>
#include <rose/Utility.hpp>
#include <rose/Skin.hpp>
#include <rose/ctl/PageControl.hpp>
#include <rose/ctl/Controls.hpp>

using namespace rose;
using namespace rose::ctl;

GWEN_CONTROL_CONSTRUCTOR(PageControl)
{
    m_iPages = 0;
    m_iCurrentPage = 0;
    SetUseFinishButton(true);

    for(int i = 0; i < MaxPages; i++)
    {
        m_pPages[i] = NULL;
    }

    Widget* pControls = new Widget(this);
    pControls->Dock(EWP_BOTTOM);
    pControls->SetSize(24, 24);
    pControls->SetMargin(Margin(10, 10, 10, 10));
    m_Finish = new ctl::Button(pControls);
    m_Finish->SetText("Finish");
    m_Finish->Dock(EWP_RIGHT);
    m_Finish->onPress.Add(this, &ThisClass::Finish);
    m_Finish->SetSize(70);
    m_Finish->SetMargin(Margin(4, 0, 0, 0));
    m_Finish->Hide();
    m_Next = new ctl::Button(pControls);
    m_Next->SetText("Next >");
    m_Next->Dock(EWP_RIGHT);
    m_Next->onPress.Add(this, &ThisClass::NextPage);
    m_Next->SetSize(70);
    m_Next->SetMargin(Margin(4, 0, 0, 0));
    m_Back = new ctl::Button(pControls);
    m_Back->SetText("< Back");
    m_Back->Dock(EWP_RIGHT);
    m_Back->onPress.Add(this, &ThisClass::PreviousPage);
    m_Back->SetSize(70);
    m_Label = new ctl::Label(pControls);
    m_Label->Dock(EWP_FILL);
    m_Label->SetAlignment(EWP_LEFT | EWP_CENTERV);
    m_Label->SetText("Page 1 or 2");
}

void PageControl::SetPageCount(unsigned int iNum)
{
    if(iNum >= MaxPages)
    {
        iNum = MaxPages;
    }

    for(unsigned int i = 0; i < iNum; i++)
    {
        if(!m_pPages[i])
        {
            m_pPages[i] = new ctl::Widget(this);
            m_pPages[i]->Dock(EWP_FILL);
        }
    }

    m_iPages = iNum;
    // Setting to -1 to force the page to change
    m_iCurrentPage = -1;
    HideAll();
    ShowPage(0);
}

void PageControl::HideAll()
{
    for(int i = 0; i < MaxPages; i++)
    {
        if(!m_pPages[i])
        {
            continue;
        }

        m_pPages[i]->Hide();
    }
}

void PageControl::ShowPage(unsigned int i)
{
    if(m_iCurrentPage == i)
    {
        return;
    }

    if(m_pPages[i])
    {
        m_pPages[i]->Show();
        m_pPages[i]->Dock(EWP_FILL);
    }

    m_iCurrentPage = i;
    m_Back->SetDisabled(m_iCurrentPage == 0);
    m_Next->SetDisabled(m_iCurrentPage >= m_iPages);
    m_Label->SetText(Utility::Format("Page %i of %i", m_iCurrentPage + 1, m_iPages));

    if(GetUseFinishButton())
    {
        bool bFinished = m_iCurrentPage >= m_iPages - 1;
        m_Next->SetHidden(bFinished);
        m_Finish->SetHidden(!bFinished);
    }

    {
        EventInfo info;
        info.Integer = i;
        info.Control = m_pPages[i];
        onPageChanged.Call(this, info);
    }
}

ctl::Widget* PageControl::GetPage(unsigned int i)
{
    return m_pPages[i];
}

ctl::Widget * PageControl::GetCurrentPage()
{
    return GetPage(GetPageNumber());
}

void PageControl::NextPage()
{
    if(m_iCurrentPage >= m_iPages - 1)
    {
        return;
    }

    if(m_pPages[m_iCurrentPage])
    {
        m_pPages[m_iCurrentPage]->Dock(EWP_NONE);
        //Anim::Add(m_pPages[m_iCurrentPage], new Anim::Pos::X(m_pPages[m_iCurrentPage]->X(), Width() * -1, 0.2f, true, 0.0f, -1));
    }

    ShowPage(m_iCurrentPage + 1);

    if(m_pPages[m_iCurrentPage])
    {
        m_pPages[m_iCurrentPage]->Dock(EWP_NONE);
        //Anim::Add(m_pPages[m_iCurrentPage], new Anim::Pos::X(Width(), 0, 0.2f, false, 0.0f, -1));
    }
}

void PageControl::PreviousPage()
{
    if(m_iCurrentPage == 0)
    {
        return;
    }

    if(m_pPages[m_iCurrentPage])
    {
        m_pPages[m_iCurrentPage]->Dock(EWP_NONE);
        //Anim::Add(m_pPages[m_iCurrentPage], new Anim::Pos::X(m_pPages[m_iCurrentPage]->X(), Width(), 0.3f, true, 0.0f, -1));
    }

    ShowPage(m_iCurrentPage - 1);

    if(m_pPages[m_iCurrentPage])
    {
        m_pPages[m_iCurrentPage]->Dock(EWP_NONE);
        //Anim::Add(m_pPages[m_iCurrentPage], new Anim::Pos::X(Width() * -1, 0, 0.3f, false, 0.0f, -1));
    }
}

void PageControl::Finish()
{
    onFinish.Call(this);
}
