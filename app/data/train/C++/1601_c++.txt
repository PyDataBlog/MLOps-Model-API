#include "Object.h"
//	#include <SFML/Audio.hpp>	// for playing sounds

namespace {
	using namespace ogl;

	// taken from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html#The C Code
	// Argument	Meaning
	//	nvert	Number of vertices in the polygon.Whether to repeat the first vertex at the end is discussed below.
	//	vertx, verty	Arrays containing the x - and y - coordinates of the polygon's vertices.
	//	testx, testy	X - and y - coordinate of the test point.
	int pnpoly(int nvert, float *vertx, float *verty, float testx, float testy) {
		int i, j, c = 0;
		for (i = 0, j = nvert - 1; i < nvert; j = i++) {
			if (((verty[i] > testy) != (verty[j] > testy)) &&
			    (testx < (vertx[j] - vertx[i]) * (testy - verty[i]) / (verty[j] - verty[i]) + vertx[i]))
				c = !c;
		}
		return c;
	}

}    // ns

// Macro to help convert to proper type for buffer offsets
#define BUFFER_OFFSET(i) ((void*)(intptr_t)(i))

void Object::handle_event() {
	if (!this->context().event)
		return;

	auto &event = *this->context().event;

	Object *target = nullptr;
	switch (event.type) {
		// mouse events we care about
		case event_type::MouseButtonPressed:
		case event_type::MouseButtonReleased:
		case event_type::MouseEntered:
		case event_type::MouseLeft:
		case event_type::MouseMoved: {
			// x, y is either in mouseButton or mouseMove event data
			int x = event.mouseMove.x
			,   y = event.mouseMove.y;

			if (event.type == event_type::MouseButtonPressed
			    || event.type == event_type::MouseButtonReleased)    // overwrite
			{
				x = event.mouseButton.x;
				y = event.mouseButton.y;
			}
			/*
			if (target = this->find(ogl::position_type( x, y )))	// find ogl object for this mouse event
			{
				switch (event.type)	// raise appropriate event
				{
				case event_type::MouseButtonPressed:
					target->mouse_button_pressed(event);
					break;
				case event_type::MouseButtonReleased:
					target->mouse_button_released(event);
					break;
				case event_type::MouseMoved:
					target->mouse_moved(event);
					break;
				};	// switch
			}
			*/
		}
			break;
		default:
			break;
	};    // switch

	// notify children
	for (auto &obj : this->children)
		obj->handle_event();

}    // handle_event

void Object::render()
{
	// Render children
	for ( auto& c : this->children )
		c->render();
}	// render

/*
Object* Object::find(const position_type& location )
{
	auto objs = this->find_all(location);
	return objs.empty()
		? nullptr
		: objs.front()
		;
}	// find

std::vector<Object*> Object::find_all(const position_type& where )
{
	std::vector<Object*> result;

	// check this
	if (this->is_at(where))
		result.emplace_back(this);

	// check children
	for (auto& c : this->children)
	{
		auto c_results = c->find_all(where);	// todo:  z sort not needed until last iteration
		std::copy(c_results.begin(), c_results.end(), std::back_inserter(result));	// copy child results to result vector
	};	// for children

	// z sort; highest z first
	std::sort(result.begin(), result.end(), [](const Object* o1, const Object* o2) { return o1->vertices.front().z > o2->vertices.front().z; });

	// todo?  deconflict multiple objects with same z-index

	return result;
}	// find_all

bool Object::is_at(const position_type& where) const
{
	// execute point in polygon test for an object, return flag if match
	auto pts = this->vertices_absolute();
	std::vector<float> Xs, Ys;
	for (auto& pt : pts)	// populate float vectors
	{
		Xs.emplace_back(pt.x);
		Ys.emplace_back(pt.y);
	};
	return pnpoly(Xs.size(), Xs.data(), Ys.data(), where.x, where.y);	// call point in polygon fn
}	// is_at

void Object::mouse_moved(const event_type& event)
{
	if (this->drag_drop_enabled && sf::Mouse::isButtonPressed(sf::Mouse::Left))
	{
		// center piece on mouse pointer
		this->vertices().front().x = event.mouseMove.x - this->center_offset().x;
		this->vertices().front().y = event.mouseMove.y - this->center_offset().y;
	}
}	// move_moved

void Object::mouse_button_released(const event_type& event )
{
	position_type where(event.mouseButton.x, event.mouseButton.y);
	// check for object dropped
	//	limitation:  could just be a click on a draggable object, not necessarily a drag and drop
	auto objs = this->root().find_all(where);

	// top obj must be drag drop enabled, and second obj must exist
	if (objs.size() >= 2 && objs[0]->drag_drop_enabled)
		objs[1]->object_dropped(*objs[0],where);

}	// mouse_button_released
*/

// static.  play provided sound asyncronously
/*
void Object::play_sound(const std::string& path)
{
	// This is based on the 'sound' example in the SFML lib
	auto play = []( const std::string& path)
	{
		sf::Music music;
		if (!music.openFromFile(path))
			return;
		music.play();
		while (music.getStatus() == sf::Sound::Playing)
			sf::sleep(sf::milliseconds(100));	// Leave some CPU time for other processes
	};

	auto h = std::async(std::launch::async, play, path );

}	// play_sound
*/