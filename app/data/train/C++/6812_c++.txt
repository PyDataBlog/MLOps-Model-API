#include "Backend.h"
#include "DebugMacros.h"
#include <stdint.h>
#include <string.h>



// PRIVATE FUNCTIONS
void Backend::WriteChannelUpdate(unsigned int in_channel, double & in_val)
{
    debug4("Write channel update to Backend.\n");
    unsigned int loc = 0;
    char buffer[1024];

    std::string buffer_write;
    buffer_write.assign(buffer, loc);
}

void Backend::WriteChannelUpdate(unsigned int in_channel, std::string & in_val)
{
    debug4("Write channel update to Backend.\n");
    unsigned int loc = 0;
    char buffer[1024];

    std::string buffer_write;
    buffer_write.assign(buffer, loc);

}

void Backend::CreateChannelUpdate(std::string & out_buffer, unsigned int in_channel, double & in_val)
{
    debug4("Create channel update to buffer.\n");
    unsigned int loc = 0;
    char channel_buffer[1024];
    
    channel_buffer[loc++] = 'b';
    
    channel_buffer[loc++] = 'c';
    
    memmove(&channel_buffer[loc], &in_channel, sizeof(unsigned int));
    loc += sizeof(unsigned int);

    channel_buffer[loc++] = 'v';
    channel_buffer[loc++] = 'd';
    memmove(&channel_buffer[loc], &in_val, sizeof(double));
    loc += sizeof(double);

    out_buffer.assign(channel_buffer, loc);
    #if DEBUG_SYSTEM >= 7
        debug7("Buffer contents:\n");
        for (unsigned int i = 0; i < out_buffer.size(); ++i)
        {
            printf("[%u]",out_buffer[i] & 0xFF);
        }
        printf("\n");
    #endif

}

void Backend::CreateChannelUpdate(std::string & out_buffer, unsigned int in_channel, std::string & in_val)
{
    debug4("Create channel update to buffer.\n");
    out_buffer.clear();
    unsigned int loc = 0;
    if (in_val.size() > 1020)
    {
        debug2("Input string is too large.\n");
        return;
    }
    char channel_buffer[1024];
    
    channel_buffer[loc++] = 'b';
    
    channel_buffer[loc++] = 'c';
    
    memmove(&channel_buffer[loc], &in_channel, sizeof(unsigned int));
    loc += sizeof(unsigned int);

    channel_buffer[loc++] = 'v';
    channel_buffer[loc++] = 's';
    
    memmove(&channel_buffer[loc], in_val.c_str(), in_val.size());
    loc += in_val.size();

    out_buffer.assign(channel_buffer, loc);
    #if DEBUG_SYSTEM >= 7
        debug7("Buffer contents:\n");
        for (unsigned int i = 0; i < out_buffer.size(); ++i)
        {
            printf("[%i]",out_buffer[i]);
        }
        printf("\n");
    #endif
}

void Backend::ReadChannelUpdate(std::string & in_buffer)
{
    debug7("Read channel update from buffer.\n");
    unsigned int loc = 0, loc2 = 0;

    unsigned int  channel_number = 0;
    double        channel_double = 0.0f;
    char          channel_buffer[1024];
    unsigned char channel_type = 0;
    std::string   channel_string;
    debug7x2("Parsing buffer contents(sizeof dbl[%lu] chr[%lu]).\n", sizeof(double), sizeof(char));
    if (loc >= in_buffer.size())
    {
        debug5("Buffer is invalid.\n");
        return;
    }
    while(loc < in_buffer.size())
    {
        debug7x1("Reading Character at position %u.\n",loc);
        switch(in_buffer[loc])
        {
            case 'c':
            case 'C':
                if (in_buffer.size() < loc + sizeof(unsigned int))
                {
                    debug5("Invalid channel buffer. Channel entry is corrupted.\n");
                    return;
                }
                memmove(&channel_number, &in_buffer.c_str()[++loc], sizeof(unsigned int));
                debug7x1("Channel number is %u.\n",channel_number);
                loc += sizeof(unsigned int) - 1;
                break;
            case 'v':
            case 'V':
                debug7("Reading channel value.\n");
                loc++;
                if (loc >= in_buffer.size())
                {
                    debug5("Invalid channel buffer. Value entry is broken.\n");
                    return;
                }
                switch(in_buffer[loc])
                {
                    case 'd':
                    case 'D':
                        // Double/Float entry value
                        memmove(&channel_double, &in_buffer.c_str()[++loc],sizeof(double));
                        loc += sizeof(double) - 1;
                        debug7x2("Update to channel %u with value (%f).\n",channel_number, channel_double);
                        break;
                    case 's':
                    case 'S':
                        loc2 = loc + 1;
                        while(loc2 <= in_buffer.size())
                        {
                            switch(in_buffer[loc2])
                            {
                                case '\0':
                                case '\n':
                                case '\r':
                                    // End of string, take the full section from [loc,loc2].
                                    memmove(channel_buffer, &in_buffer.c_str()[loc+1], (loc2 - loc) * sizeof (char));
                                    channel_string.assign(channel_buffer, loc2);
                                    loc = loc2 + 1;
                                    loc2 = in_buffer.size();
                                    debug7x3("Update to channel %u with string (%s)[%u].\n",channel_number, channel_string.c_str(),loc-1);
                                    break;
                                default:
                                    break;
                            }
                            loc2++;
                        }
                        break;
                    default:
                        break;
                }
                
                break;
            default:
                break;
        }
        loc++;
    }
}


// PUBLIC FUNCTIONS
Backend::Backend()
{
    data = new DataStorage(255);
}


Backend::~Backend()
{
    delete(data);
}

void Backend::AddChannelUpdate(unsigned int in_channel, double & in_val)
{
    
}

void Backend::AddChannelUpdate(unsigned int in_channel, std::string & in_val)
{
    
}

