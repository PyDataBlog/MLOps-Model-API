#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <map>
#include <climits>
using namespace std;
#define all(t) begin(t), end(t)
#define sp << " " <<

using ul = unsigned long;

vector<bool> X;
vector<int> sieve;

template <typename I>
void make_sieve(I MAX) {
//create table of primes
  I M = MAX>>1;
  if (!(MAX & 1)) M--;
  X.resize(M+1,true);
  I k;
  for (I j=1,p=3,q=4;j<=M;j++, p+=2, q+=2*p-2) {
    if (X[j]==0) continue;
    else k=q;
    while (k <= M) {
      X[k] = 0;
      k += p;
    }
  }
  for  (I i=5;i<(I)X.size();i++) if (X[i]) sieve.push_back(2*i+1);
}

template <typename R>
R gcd(R a, R b) {
  while (true) {
    if (b==0) return a;
    a %= b;
    if (a==0) return b;
    b %= a;
  }
}

struct ratio {
  ul p, q;
  ratio(): p(0), q(1) {}
  ratio(ul a, ul b) : p(a), q(b) {}
  ratio simplify() {
    ul c = gcd(p, q);
    p /= c; q /= c;
    return *this;
  }
  ratio operator+(const ratio& b) {
    ratio a;
    a.p = p * b.q + q * b.p;
    a.q = q * b.q;
    a.simplify();
    return a;
  }
  ratio operator-(const ratio& b) {
    ratio a;
    a.p = p * b.q - q * b.p;
    a.q = q * b.q;
    a.simplify();
    return a;
  }
  void operator=(const ratio& b) {
    p = b.p;
    q = b.q;
  }
  bool operator<(const ratio& b) const {
    return p*b.q < q*b.p;
  }
  bool operator==(const ratio& b) const {
    return !(*this < b) && !(b < *this);
  }
  bool operator<=(const ratio& b) const {
    return (*this < b) || (*this == b);
  }
  bool operator!=(const ratio& b) const {
    return !(*this == b);
  }
};

vector<pair<int, vector<ratio>>> Dom;

ostream& operator<<(ostream& os, const ratio& r) {
  os << r.p << '/' << r.q;
  return os;
}

template <typename I>
void print(const vector<I>& a) {
  for (auto e: a) cout << e << ' ';
  cout << endl;
}

void visit(vector<size_t>& x) {
  auto il = Dom.begin();
  for (size_t i=0;i < Dom.size();i++, il++) if ((il->second)[x[i]] != ratio()) cout << il->first << ' ';
  cout << endl;
}

int main() {
  int N, D;
  cin >> D >> N;
  make_sieve(N);
  //B1 Initialize
  for (int i=2;i<=N;i++) {
    if (i<11) {Dom.push_back(make_pair(i,vector<ratio>{ratio(), ratio(1,i*i)})); continue;}
    if (i == 52) {
      Dom.push_back(make_pair(i,vector<ratio>{ratio(), ratio(1,169)+ratio(1,169*9)+ratio(1,169*16)}));
      continue;
    }
    if (i == 91) {
      Dom.push_back(make_pair(i,vector<ratio>{ratio(), ratio(1,169*4)+ratio(1,169*25)+ratio(1,169*49)}));
      continue;
    }
    if (i == 95) {
      Dom.push_back(make_pair(i,vector<ratio>{ratio(), ratio(1,361*4)+ratio(1,361*9)+ratio(1,361*25)}));
      continue;
    }
    if (i == 99) {
      Dom.push_back(make_pair(i,vector<ratio>{ratio(), ratio(1,121*4)+ratio(1,121*9)+ratio(1,121*81),
	      ratio(1,121)+ratio(1,121*9)+ratio(1,121*16)+ratio(1,121*36)+ratio(1,121*81), 
	      ratio(1,121)+ratio(1,121*25)+ratio(1,121*49)+ratio(1,121*64)+ratio(1,121*81)}));
      continue;
    }
    bool use = true;
    for (size_t j=0;j < sieve.size() && sieve[j]<=i;j++) {
      if (i%sieve[j]==0) {use = false; break;}
    }
    if (use) {
      Dom.push_back(make_pair(i,vector<ratio> {ratio(), ratio(1,i*i)}));
    }
  }
  //for (auto e: Dom) {cout << e.first << ": "; print(e.second);cout << endl;}
  vector<ratio> S(Dom.size()+1);
  int n = Dom.size();
  int l{0};
  int i = n-1;
  ratio d(1, D);
  for (auto it = Dom.rbegin(); it != Dom.rend(); it++, i--) {
    S[i] = S[i+1] + it->second.back();
  }
  vector<size_t> x(n,0);
  int cnt{0};
  ratio sigma;
 B2:
  if (l == n) {
    visit(x);
    cnt++;
    l--;
    goto B5;
  }
  x[l] = 0;
 B3:
  sigma = sigma + Dom[l].second[x[l]];
  if ((sigma < d && d == sigma + S[l+1])|| sigma == d) { l++;  goto B2;}//found solution
  if (l<n-1 && sigma < d && d < sigma + S[l+1]) { l++; goto B2;}
 B4://set x[l] to the next larger element
  if (x[l] < Dom[l].second.size()-1) { x[l]++; goto B3;}
 B5:
  l--;
  if (l>=0) {
    /*downdata by undoing changes made in B3 and return to B4*/
    sigma = sigma - Dom[l+1].second[x[l+1]];
    goto B4;
  }
  cout << cnt << endl;
}

