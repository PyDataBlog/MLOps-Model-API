#include <iostream>
#include <iomanip>
#include <random>

using namespace std;

// ºìºÚÊ÷µÄÐÔÖÊ
// 1 Ã¿¸ö½ÚµãÒªÃ´ÊÇºìµÄ£¬ÒªÃ´ÊÇºÚµÄ
// 2 ¸ù½ÚµãÊÇºÚµÄ
// 3 Èç¹ûÒ»¸ö½ÚµãÊÇºìµÄ£¬ÔòËüµÄÁ½¸ö¶ù×Ó¶¼ÊÇºÚµÄ
// 4 ¶ÔÃ¿¸ö½Úµã£¬´Ó¸Ã½Úµãµ½Æä×ÓËï½ÚµãµÄËùÓÐÂ·¾¶ÉÏ°üº¬ÏàÍ¬ÊýÄ¿µÄºÚ½Úµã
class RedBlackTree {
public:
	RedBlackTree() { 
		nil = new TreeNode(-1); 
		nil->parent = nil; 
		nil->left = nil;
		nil->right = nil;
		nil->color = BLACK;
		root = nil; 
	}
	~RedBlackTree() { clear(root); delete nil; }
	void insert(int elem) {
		rb_insert(new TreeNode(elem, nil, nil, nil));
	}
	void remove(int elem) {
		TreeNode *node = find(elem, root);
		if (node != nil)
			rb_remove(node);
	}
	void print() {
		InOrderTraversal(root);
		cout << endl;
	}
	bool empty() {
		return (root == nil) ? true : false;
	}
private:
	enum Color { RED, BLACK };
	struct TreeNode {
		int elem;
		Color color;
		TreeNode *parent;
		TreeNode *left;
		TreeNode *right;
		TreeNode(int e, TreeNode *p = NULL, TreeNode *l = NULL, TreeNode *r = NULL, Color c = RED) : elem(e), color(c), parent(p), left(l), right(r) {}
	};
	TreeNode *nil;
	TreeNode *root;
	TreeNode* find(int elem, TreeNode* node) {
		if (node == nil)
			return nil;
		if (elem == node->elem)
			return node;
		else if (elem < node->elem)
			return find(elem, node->left);
		else if (elem > node->elem)
			return find(elem, node->right);
		else;

	}
	void leftRotate(TreeNode* k1) {
		// set k2
		TreeNode *k2 = k1->right;
		// turn k2's left subtree into k1's right subtree
		k1->right = k2->left;
		k2->left->parent = k1;
		// link k1's parent to k2
		k2->parent = k1->parent;
		if (k2->parent == nil) 
			root = k2;
		else if (k1 = k2->parent->left)
			k2->parent->left = k2;
		else
			k2->parent->right = k2;
		// put k1 on k2's left
		k2->left = k1;
		k1->parent = k2;
	}
	void rightRotate(TreeNode* k2) {
		// set k1
		TreeNode *k1 = k2->left;
		// turn k1's right subtree into k2's left subtree
		k2->left = k1->right;
		k1->right->parent = k2;
		// link k2's parent to k1
		k1->parent = k2->parent;
		if (k1->parent == nil)
			root = k1;
		else if (k2 = k1->parent->left)
			k1->parent->left = k1;
		else
			k1->parent->right = k1;
		// put k2 on k1's right
		k1->right = k2;
		k2->parent = k1;
	}
	void rb_insert(TreeNode *z) {
		TreeNode *y = nil;
		TreeNode *x = root;
		// find the last leaf node
		while (x != nil) {
			y = x;
			if (z->elem < x->elem)
				x = x->left;
			else
				x = x->right;
		}
		// link z to y as its parent
		z->parent = y;
		if (y == nil)
			root = z;
		else if (z->elem < y->elem)
			y->left = z;
		else
			y->right = z;
		// initialize z with RED color
		z->left = nil;
		z->right = nil;
		z->color = RED; // ¿ÉÄÜ»áÆÆ»µÐÔÖÊ2»òÐÔÖÊ3£¬µ«²»»áÆÆ»µÐÔÖÊ4
		rb_insert_fixup(z);
		print();
	}
	void rb_insert_fixup(TreeNode *z) {
		TreeNode *y;
		while (z->parent->parent != nil && z->parent->color == RED) { // ÒÔÏÂ´úÂëÐÞÕýÐÔÖÊ3
			// Çé¿ö1£ºzµÄ¸¸½ÚµãÊÇ×ó×Ó½Úµã£¬zµÄÊå¸¸½ÚµãÔòÎªz¸¸½ÚµãµÄ¸¸½ÚµãµÄÓÒ×Ó½Úµã
			if (z->parent == z->parent->parent->left) {
				// yÊÇzµÄÊå¸¸½Úµã
				y = z->parent->parent->right;
				// Case 1: zµÄÊå¸¸½ÚµãÊÇºìµÄ
				if (y->color == RED) {
					z->parent->color = BLACK;
					y->color = BLACK;
					z->parent->parent->color = RED;
					z = z->parent->parent;
				}
				// Case 2: zµÄÊå¸¸½ÚµãÊÇºÚµÄ£¬¶øÇÒzÊÇÓÒ×Ó½Úµã
				else if (z == z->parent->right) {
					z = z->parent;
					leftRotate(z);
				}
				// Case 3:zµÄÊå¸¸½ÚµãÊÇºÚÉ«£¬¶øÇÒzÊÇ×ó×Ó½Úµã
				else {
					z->parent->color = BLACK;
					z->parent->parent->color = RED;
					rightRotate(z->parent->parent);
				}
			}
			// Çé¿ö2£ºzµÄ¸¸½ÚµãÊÇÓÒ×Ó½Úµã£¬zµÄÊå¸¸½ÚµãÔòÎªz¸¸½ÚµãµÄ¸¸½ÚµãµÄ×ó×Ó½Úµã
			else {
				// yÊÇzµÄÊå¸¸½Úµã
				y = z->parent->parent->left;
				// Case 1: zµÄÊå¸¸½ÚµãÊÇºìµÄ
				if (y->color == RED) {
					z->parent->color = BLACK;
					y->color = BLACK;
					z->parent->parent->color = RED;
					z = z->parent->parent;
				}
				// Case 2: zµÄÊå¸¸½ÚµãÊÇºÚµÄ£¬¶øÇÒzÊÇ×ó×Ó½Úµã
				else if (z == z->parent->left) {
					z = z->parent;
					rightRotate(z);
				}
				// Case 3: zµÄÊå¸¸½ÚµãÊÇºÚµÄ£¬¶øÇÒzÊÇÓÒ×Ó½Úµã
				else {
					z->parent->color = BLACK;
					z->parent->parent->color = RED;
					leftRotate(z->parent->parent);
				}
			}
		}
		root->color = BLACK; // ÐÞÕýÐÔÖÊ2
	}
	TreeNode* findSuccessor(TreeNode *z) {
		if (z->right != nil) {
			z = z->right;
			while (z->left != nil)
				z = z->left;
			return z;
		}
		TreeNode *p = z->parent;
		while (p != nil && z == p->right) {
			z = p;
			p = p->parent;
		}
		return p;
	}
	void rb_remove(TreeNode *z) {
		TreeNode *x, *y;
		// yÊÇÕæÕýµÄ¼´½«±»removeµÄ½Úµã
		if (z->left == nil || z->right == nil)
			y = z;
		else
			y = findSuccessor(z); // y¿Ï¶¨Ã»ÓÐ×ó×Ó½Úµã
		// xÊÇyµÄ×Ó½Úµã
		if (y->left != nil)
			x = y->left;
		else
			x = y->right;
		// xµÄ¸¸½ÚµãÖ¸ÏòyµÄ¸¸½Úµã£¬²»¹ÜxÊÇ²»ÊÇnil
		x->parent = y->parent;
		if (y->parent == nil)
			root = x;
		else if (y == y->parent->left)
			y->parent->left = x;
		else
			y->parent->right = x;
		if (y != z)
			z->elem = y->elem;
		// Èç¹û±»É¾µÄ½ÚµãÊÇºÚÉ«µÄ£¬Ôò»á²úÉúÈý¸öÎÊÌâ
		// 1 Èç¹ûyÔ­À´ÊÇ¸ù½Úµã£¬¶øyµÄÒ»¸öºìÉ«µÄ×Ó½Úµã³ÆÎªÁËÐÂµÄ¸ù£¬ÔòÎ¥·´ÁËÐÔÖÊ2
		// 2 Èç¹ûxºÍy->parent¶¼ÊÇºìÉ«µÄ£¬ÔòÎ¥·´ÁËÐÔÖÊ3
		// 3 É¾³ýy½«µ¼ÖÂÏÈÇ°°üº¬yµÄÈÎºÎÂ·¾¶ÉÏºÚ½Úµã¸öÊýÉÙ1£¬Î¥·´ÁËÐÔÖÊ4
		if (y->color == BLACK)
			rb_remove_fixup(x); 
		delete y;
		y = NULL;
	}
	void rb_remove_fixup(TreeNode *x) {
		TreeNode *w;
		if (x == nil)
			return;
		// ÒòÎªÎ¥·´ÁËÐÔÖÊ4£¬¹Ê¼Ù¶¨xÉÏÌí¼ÓÁËÒ»ÖØºÚÉ«ÓÃÒÔÐÞÕýÐÔÖÊ4
		while (x != root && x->color == BLACK) {
			if (x == x->parent->left) {
				// xÊÇ×ó×Ó½Úµã£¬wÊÇxµÄÐÖµÜ½Úµã
				w = x->parent->right;
				// Case 1: xµÄÐÖµÜ½ÚµãwÊÇºìÉ«µÄ£¬´ËÊ±wµÄ×Ó½Úµã¶¼ÊÇºÚÉ«µÄ£¬Í¨¹ýÐý×ª²Ù×÷×ª»¯ÎªCase234
				if (w->color == RED) {
					w->color = BLACK;
					x->parent->color = RED;
					leftRotate(x->parent);
					w = x->parent->right;
				}
				// Case 2: xµÄÐÖµÜ½ÚµãwÊÇºÚÉ«µÄ£¬¶øÇÒwµÄÁ½¸öº¢×Ó¶¼ÊÇºÚÉ«µÄ
				if (w->left->color == BLACK && w->right->color == BLACK) {
					w->color = RED; // ½«xºÍxµÄÐÖµÜ½ÚµãwÈ¥µôÒ»ÖØºÚÉ«
					x = x->parent; // ÐÞÕýÁË±¾²ãÐÔÖÊ4£¬¼ÌÐøÏòÉÏ²ãÐÞÕý
				}
				// Case 3: xµÄÐÖµÜ½ÚµãwÊÇºÚÉ«µÄ£¬wµÄ×ó×Ó½ÚµãÊÇºìÉ«µÄ£¬ÓÒ×Ó½ÚµãÊÇºÚÉ«µÄ£¬Í¨¹ýÐý×ª²Ù×÷×ª»¯ÎªCase4
				else if (w->right->color == BLACK) {
					w->left->color = BLACK;
					w->color = RED;
					rightRotate(w);
					w = x->parent->right;
				}
				// Case 4: xµÄÐÖµÜ½ÚµãwÊÇºÚÉ«µÄ£¬wµÄÓÒ×Ó½ÚµãÊÇºìÉ«µÄ
				else {// ×îÖØÒªµÄÒ»ÖÖÇé¿ö£¬
					w->color = x->parent->color;
					x->parent->color = BLACK; // ×óÐýºóÎªxÌí¼ÓÁËÒ»ÖØºÚÉ«£¬ÐÞÕýÁËÐÔÖÊ4ºÍÐÔÖÊ3
					w->right->color = BLACK;
					leftRotate(x->parent);
					x = root;
				}
			}
			else {
				// xÊÇÓÒ×Ó½Úµã£¬wÊÇxµÄÐÖµÜ½Úµã
				w = x->parent->left;
				// Case 1: xµÄÐÖµÜ½ÚµãwÊÇºìÉ«µÄ£¬´ËÊ±wµÄ×Ó½Úµã¶¼ÊÇºÚÉ«µÄ£¬Í¨¹ýÐý×ª²Ù×÷×ª»¯ÎªCase234
				if (w->color == RED) {
					w->color = BLACK;
					x->parent->color = RED;
					rightRotate(x->parent);
					w = x->parent->left;
				}
				// Case 2: xµÄÐÖµÜ½ÚµãwÊÇºÚÉ«µÄ£¬¶øÇÒwµÄÁ½¸öº¢×Ó¶¼ÊÇºÚÉ«µÄ
				if (w->left->color == BLACK && w->right->color == BLACK) {
					w->color = RED;
					x = x->parent;
				}
				// Case 3: xµÄÐÖµÜ½ÚµãwÊÇºÚÉ«µÄ£¬wµÄÓÒ×Ó½ÚµãÊÇºìÉ«µÄ£¬×ó×Ó½ÚµãÊÇºÚÉ«µÄ£¬Í¨¹ýÐý×ª²Ù×÷×ª»¯ÎªCase4
				else if (w->left->color == BLACK) {
					w->right->color = BLACK;
					w->color = RED;
					leftRotate(w);
					w = x->parent->left;
				}
				// Case 4: xµÄÐÖµÜ½ÚµãwÊÇºÚÉ«µÄ£¬wµÄ×ó×Ó½ÚµãÊÇºìÉ«µÄ
				else {
					w->color = x->parent->color;
					x->parent->color = BLACK;
					w->left->color = BLACK;
					rightRotate(x->parent);
					x = root;
				}
			}
		}
		x->color = BLACK; // ÐÞÕýÁËÐÔÖÊ2
	}
	void InOrderTraversal(TreeNode *node) {
		if (node == nil)
			return;
		InOrderTraversal(node->left);
		cout << setw(3) << node->elem << '(' << node->color << ')';
		InOrderTraversal(node->right);
	}
	void clear(TreeNode *node) {
		if (node == nil)
			return;
		if (node->left != nil)
			clear(node->left);
		if (node->right != nil)
			clear(node->right);
		delete node;
		node = NULL;
	}
};

int main() {
	static default_random_engine generator;
	uniform_int_distribution<int> distribution(1, 99);
	
	RedBlackTree *tree = new RedBlackTree();
	for (int i = 0; i < 10; ++i) {
		int elem = distribution(generator);
		cout << setw(3) << elem << endl;
		tree->insert(elem);
	}
	while (!tree->empty()) {
		int elem;
		cout << "ÇëÊäÈëÒªÉ¾³ýµÄÊý: " << endl;
		cin >> elem;
		tree->remove(elem);
		tree->print();
	}

	delete tree;
	tree = NULL;
	system("pause");
}
