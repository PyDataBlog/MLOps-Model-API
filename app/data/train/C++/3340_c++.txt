#include "Body.h"

vec_f CalculateCenterOfMass(nz::BodyPart* polygon)
{
	switch (polygon->Type)
	{
	case nz::ShapeType::Polygon:
	{
		vec_f com;
		auto poly = polygon->Polygon;
		int count = poly->Count();
		for (int i = 0; i < count; ++i)
		{
			vec_f vertex = poly->At(i);
			com.X += vertex.X;
			com.Y += vertex.Y;
		}
		return com / count;
	}
	case nz::ShapeType::Rectangle:
	{
		return vec_f(polygon->Rectangle.X / 2, polygon->Rectangle.Y);
	}
	default: break;
	}
	return vec_f::Zero();
}

nz::Body::Body() :
	Rotation(0),
	Velocity(vec_f::Zero()),
	CollisionHandler(nullptr),
	_position(vec_f::Zero()) {}

nz::Body::Body(vec_f position, number_f rotation) :
	Rotation(rotation),
	Velocity(vec_f::Zero()),
	CollisionHandler(nullptr),
	_position(position) {}

nz::Body::Body(vec_f position, number_f rotation, Thunk1<Body*>* const collisionHandler) :
	Rotation(rotation),
	Velocity(vec_f::Zero()),
	CollisionHandler(collisionHandler),
	_position(position) {}

nz::Aabb nz::Body::GetBoundingBox() const
{
	return _boundingBox;
}

nz::Aabb nz::Body::CalculateBoundingBox() const
{
	auto returnable = _boundingBox;

	returnable.Min += CalculateWorldTranslation();
	returnable.Max += CalculateWorldTranslation();

	return returnable;
}

vec_f nz::Body::GetCenterOfMass() const
{
	return _centerOfMass;
}

vec_f nz::Body::CalculateWorldTranslation() const
{
	return _position + _centerOfMass;
}

void nz::Body::SetWorldTranslation(vec_f translation)
{
	_position = translation - _centerOfMass;
}

void nz::Body::AttachBodyPart(std::shared_ptr<BodyPart> part)
{
	Part = part;

	_centerOfMass = CalculateCenterOfMass(part.get());

	// Realign the position.
	_position -= _centerOfMass;

	Aabb aabb;

	switch (Part->Type)
	{
	case ShapeType::Polygon:
	{
		auto poly = Part->Polygon;
		int count = poly->Count();
		for (int i = 0; i < count; ++i)
		{
			auto calcPos = poly->At(i) + _centerOfMass;

			if (calcPos.X < aabb.Min.X)
			{
				aabb.Min.X = calcPos.X;
			}
			if (calcPos.Y < aabb.Min.Y)
			{
				aabb.Min.Y = calcPos.Y;
			}
			if (calcPos.X > aabb.Max.X)
			{
				aabb.Max.X = calcPos.X;
			}
			if (calcPos.Y > aabb.Max.Y)
			{
				aabb.Max.Y = calcPos.Y;
			}
		}
		break;
	}
	case ShapeType::Rectangle:
	{
		auto rect = Part->Rectangle;
		aabb.Min = _centerOfMass;
		aabb.Max = rect + _centerOfMass;
		break;
	}
	default:
		break;
	}

	_boundingBox = aabb;
}
