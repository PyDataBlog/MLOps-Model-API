#pragma once
#include "acl_cpp/acl_cpp_define.hpp"
#include <vector>
#include <map>
#include "acl_cpp/redis/redis_command.hpp"

namespace acl
{

class redis_client;
class redis_result;
class string;

class ACL_CPP_API redis_pubsub : virtual public redis_command
{
public:
	/**
	 * see redis_command::redis_command()
	 */
	redis_pubsub(void);

	/**
	 * see redis_command::redis_command(redis_client*)
	 */
	redis_pubsub(redis_client* conn);

	/**
	 * see redis_command::redis_command(redis_client_cluster*, size_t)
	 */
	redis_pubsub(redis_client_cluster* cluster, size_t max_conns = 0);

	virtual ~redis_pubsub(void);

	/////////////////////////////////////////////////////////////////////

	/**
	 * ½«ÐÅÏ¢·¢ËÍµ½Ö¸¶¨µÄÆµµÀ channel
	 * post a message to a channel
	 * @param channel {const char*} Ëù·¢ËÍÏûÏ¢µÄÄ¿±êÆµµÀ
	 *  the specified channel
	 * @param msg {const char*} ÏûÏ¢ÄÚÈÝ
	 *  the message to be sent
	 * @param len {size_t} ÏûÏ¢³¤¶È
	 *  the message's length
	 * @return {int} ³É¹¦·¢ËÍÖÁ¶©ÔÄ¸ÃÆµµÀµÄ¶©ÔÄÕßÊýÁ¿
	 *  the number of clients that received the message
	 *  -1£º±íÊ¾³ö´í
	 *      error happened
	 *   0£ºÃ»ÓÐ¶©ÔÄÕß
	 *      no client subscribe the channel
	 *  >0£º¶©ÔÄ¸ÃÆµµÀµÄ¶©ÔÄÕßÊýÁ¿
	 *      the number of clients that received the message
	 */
	int publish(const char* channel, const char* msg, size_t len);

	/**
	 * ¶©ÔÄ¸ø¶¨µÄÒ»¸ö»ò¶à¸öÆµµÀµÄÐÅÏ¢£»ÔÚµ÷ÓÃ±¾º¯ÊýºóµÄ²Ù×÷Ö»ÄÜ·¢ËÍµÄÃüÁîÓÐ£º
	 * subscribe¡¢unsubscribe¡¢psubscribe¡¢punsubscribe¡¢get_message£¬Ö»ÓÐ
	 * È¡Ïû¶©ÔÄÁËËùÓÐÆµµÀ£¨»òÁ¬½ÓÖØ½¨£©ºó²Å°ÚÍÑ¸ÃÏÞÖÆ
	 * subscribe one or more channel(s). Once the client enters the
	 * subscribed state it is not supposed to issue any other commands,
	 * except for additional SUBSCRIBE, PSUBSCRIBE, UNSUBSCRIBE
	 * and PUNSUBSCRIBE commands
	 * @param first_channel {const char*} Ëù¶©ÔÄµÄÆµµÀÁÐ±íµÄµÚÒ»¸ö·Ç¿Õ×Ö·û´®
	 *  µÄÆµµÀ£¬¶ÔÓÚ±ä²ÎÁÐ±íÖÐµÄ×îºóÒ»¸ö±ØÐëÊÇ NULL
	 *  the first non-NULL channel in the channel list, and the last
	 *  parameter must be NULL indicating the end of the channel list
	 * @return {int} ·µ»Øµ±Ç°ÒÑ¾­³É¹¦¶©ÔÄµÄÆµµÀ¸öÊý£¨¼´Ëù¶©ÔÄµÄËùÓÐÆµµÀÊýÁ¿£©
	 *  the number of channels subscribed by the current client
	 */
	int subscribe(const char* first_channel, ...);
	int subscribe(const std::vector<const char*>& channels);
	int subscribe(const std::vector<string>& channels);

	/**
	 * È¡Ïû¶©ÔÄ¸ø¶¨µÄÒ»¸ö»ò¶à¸öÆµµÀµÄÐÅÏ¢
	 * stop listening for messages posted to the given channels
	 * @param first_channel {const char*} ËùÈ¡ÏûµÄËù¶©ÔÄÆµµÀÁÐ±íµÄµÚÒ»¸öÆµµÀ
	 *  the fist channel in channel list, and the last parameter must be
	 *  NULL indicating the end of the channel list
	 * @return {int} ·µ»ØÊ£ÓàµÄËù¶©ÔÄµÄÆµµÀµÄ¸öÊý
	 *  the rest channels listened by the current client
	 */
	int unsubscribe(const char* first_channel, ...);
	int unsubscribe(const std::vector<const char*>& channels);
	int unsubscribe(const std::vector<string>& channels);

	/**
	* ¶©ÔÄÒ»¸ö»ò¶à¸ö·ûºÏ¸ø¶¨Ä£Ê½µÄÆµµÀ£»Ã¿¸öÄ£Ê½ÒÔ * ×÷ÎªÆ¥Åä·û£»ÔÚµ÷ÓÃ±¾º¯ÊýºóµÄ²Ù×÷
	* Ö»ÄÜ·¢ËÍµÄÃüÁîÓÐ£ºsubscribe¡¢unsubscribe¡¢psubscribe¡¢punsubscribe¡¢
	* get_message£¬Ö»ÓÐÈ¡Ïû¶©ÔÄÁËËùÓÐÆµµÀ£¨»òÁ¬½ÓÖØ½¨£©ºó²Å°ÚÍÑ¸ÃÏÞÖÆ
	* listen for messages published to channels matching the give patterns
	 * @param first_pattern {const char*} µÚÒ»¸öÆ¥ÅäÄ£Ê½´®
	 *  the first pattern in pattern list, the last parameter must be NULL
	 *  int the variable args
	 * @return {int} ·µ»Øµ±Ç°ÒÑ¾­³É¹¦¶©ÔÄµÄÆµµÀ¸öÊý£¨¼´Ëù¶©ÔÄµÄËùÓÐÆµµÀÊýÁ¿£©
	 *  the number of channels listened by the current client
	 */
	int psubscribe(const char* first_pattern, ...);
	int psubscribe(const std::vector<const char*>& patterns);
	int psubscribe(const std::vector<string>& patterns);

	/**
	 * ¸ù¾ÝÄ£Ê½Æ¥Åä´®È¡Ïû¶©ÔÄ¸ø¶¨µÄÒ»¸ö»ò¶à¸öÆµµÀµÄÐÅÏ¢
	 * stop listening for messaged posted to channels matching
	 * the given patterns
	 * @param first_pattern {const char*} µÚÒ»¸öÆ¥ÅäÄ£Ê½´®
	 *  the first parttern in a variable args ending with NULL
	 * @return {int} ·µ»ØÊ£ÓàµÄËù¶©ÔÄµÄÆµµÀµÄ¸öÊý
	 *  the rest number of channels be listened by the client
	 */
	int punsubscribe(const char* first_pattern, ...);
	int punsubscribe(const std::vector<const char*>& patterns);
	int punsubscribe(const std::vector<string>& patterns);

	/**
	 * ÔÚ¶©ÔÄÆµµÀºó¿ÉÒÔÑ­»·µ÷ÓÃ±¾º¯Êý´ÓËù¶©ÔÄµÄÆµµÀÖÐ»ñÈ¡¶©ÔÄÏûÏ¢£»
	 * ÔÚµ÷ÓÃ subscribe »ò psubscribe ºó²Å¿Éµ÷ÓÃ±¾º¯ÊýÀ´»ñÈ¡Ëù¶©ÔÄµÄÆµµÀµÄÏûÏ¢
	 * get messages posted to channels after SUBSCRIBE or PSUBSCRIBE
	 * @param channel {string&} ´æ·Åµ±Ç°ÓÐÏûÏ¢µÄÆµµÀÃû
	 *  buffer for storing the channel associate with the msg
	 * @param msg {string&} ´æ·Åµ±Ç°»ñµÃµÄÏûÏ¢ÄÚÈÝ
	 *  store the message posted to the channel
	 * @return {bool} ÊÇ·ñ³É¹¦£¬Èç¹û·µ»Ø false Ôò±íÊ¾³ö´í
	 *  true on success, false on error
	 */
	bool get_message(string& channel, string& msg);

	/**
	 * ÁÐ³öµ±Ç°µÄ»îÔ¾ÆµµÀ£º»îÔ¾ÆµµÀÖ¸µÄÊÇÄÇÐ©ÖÁÉÙÓÐÒ»¸ö¶©ÔÄÕßµÄÆµµÀ£¬ ¶©ÔÄÄ£Ê½µÄ
	 * ¿Í»§¶Ë²»¼ÆËãÔÚÄÚ
	 * Lists the currently active channels.
	 * @param channels {std::vector<string>*} ·Ç¿ÕÊ±´æ·ÅÆµµÀ½á¹û¼¯
	 *  store the active channels
	 * @param first_pattern {const char*} ×÷Îª¸½¼ÓµÄÆ¥ÅäÄ£Ê½µÚÒ»¸öÆ¥Åä×Ö·û´®£¬
	 *  ¸ÃÖ¸Õë¿ÉÒÔÎª NULL£¬´ËÊ±»ñÈ¡Ö¸ËùÓÐµÄ»îÔ¾ÆµµÀ£»¶ÔÓÚ±ä²Î¶øÑÔ×îºóÒ»¸ö²ÎÊýÐèÎª NULL
	 *  the first pattern in a variable args ending with NULL arg, and
	 *  the first arg can be NULL.
	 * @return {int} ·µ»Ø»îÔ¾ÆµµÀÊý£» -1 ±íÊ¾³ö´í
	 *  the number of active channels. -1 if error
	 *
	 *  ²Ù×÷³É¹¦ºó¿ÉÒÔÍ¨¹ýÒÔÏÂÈÎÒ»·½Ê½»ñµÃÊý¾Ý
	 *  1¡¢»ùÀà·½·¨ get_value »ñµÃÖ¸¶¨ÏÂ±êµÄÔªËØÊý¾Ý
	 *  2¡¢»ùÀà·½·¨ get_child »ñµÃÖ¸¶¨ÏÂ±êµÄÔªËØ¶ÔÏó(redis_result£©£¬È»ºóÔÙÍ¨¹ý
	 *     redis_result::argv_to_string ·½·¨»ñµÃÔªËØÊý¾Ý
	 *  3¡¢»ùÀà·½·¨ get_result ·½·¨È¡µÃ×Ü½á¹û¼¯¶ÔÏó redis_result£¬È»ºóÔÙÍ¨¹ý
	 *     redis_result::get_child »ñµÃÒ»¸öÔªËØ¶ÔÏó£¬È»ºóÔÙÍ¨¹ý·½Ê½ 2 ÖÐÖ¸¶¨
	 *     µÄ·½·¨»ñµÃ¸ÃÔªËØµÄÊý¾Ý
	 *  4¡¢»ùÀà·½·¨ get_children »ñµÃ½á¹ûÔªËØÊý×é¶ÔÏó£¬ÔÙÍ¨¹ý redis_result ÖÐ
	 *     µÄ·½·¨ argv_to_string ´ÓÃ¿Ò»¸öÔªËØ¶ÔÏóÖÐ»ñµÃÔªËØÊý¾Ý
	 *  5¡¢ÔÚµ÷ÓÃ·½·¨ÖÐ´«Èë·Ç¿ÕµÄ´æ´¢½á¹û¶ÔÏóµÄµØÖ·
	 *
	 */
	int pubsub_channels(std::vector<string>* channels,
		const char* first_pattern, ...);
	int pubsub_channels(const std::vector<const char*>& patterns,
		std::vector<string>* channels);
	int pubsub_channels(const std::vector<string>& patterns,
		std::vector<string>* channels);

	/**
	 * ·µ»Ø¸ø¶¨ÆµµÀµÄ¶©ÔÄÕßÊýÁ¿£¬ ¶©ÔÄÄ£Ê½µÄ¿Í»§¶Ë²»¼ÆËãÔÚÄÚ
	 * Returns the number of subscribers (not counting clients
	 * subscribed to patterns) for the specified channels.
	 * @param out {std::map<string, int>&} ´æ´¢²éÑ¯½á¹û£¬ÆäÖÐ out->first ´æ·Å
	 *  ÆµµÀÃû£¬out->second ÔÚ×ù¸ÃÆµµÀµÄ¶©ÔÄÕßÊýÁ¿
	 *  store the results
	 * @param first_pattern {const char*} ×÷Îª¸½¼ÓµÄÆ¥ÅäÄ£Ê½µÚÒ»¸öÆ¥Åä×Ö·û´®£¬
	 *  ¸ÃÖ¸Õë¿ÉÒÔÎª NULL£¬´ËÊ±»ñÈ¡Ö¸ËùÓÐµÄ»îÔ¾ÆµµÀ£»¶ÔÓÚ±ä²Î¶øÑÔ×îºóÒ»¸ö²ÎÊýÐèÎª NULL
	 *  the first pattern in a variable args ending with NULL arg, and
	 *  the first arg can be NULL.
	 * @return {int} ÆµµÀµÄÊýÁ¿£¬-1 ±íÊ¾³ö´í
	 */
	int pubsub_numsub(std::map<string, int>& out,
		const char* first_channel, ...);
	int pubsub_numsub(const std::vector<const char*>& channels,
		std::map<string, int>& out);
	int pubsub_numsub(const std::vector<string>& channels,
		std::map<string, int>& out);

	/**
	 * ·µ»Ø¶©ÔÄÄ£Ê½µÄÊýÁ¿£¬Õâ¸öÃüÁî·µ»ØµÄ²»ÊÇ¶©ÔÄÄ£Ê½µÄ¿Í»§¶ËµÄÊýÁ¿£¬ ¶øÊÇ¿Í»§¶Ë¶©ÔÄµÄ
	 * ËùÓÐÄ£Ê½µÄÊýÁ¿×ÜºÍ
	 * Returns the number of subscriptions to patterns.
	 * @return {int} ¿Í»§¶ËËùÓÐ¶©ÔÄÄ£Ê½µÄ×ÜºÍ£¬-1 ±íÊ¾³ö´í
	 *  the number of patterns all the clients are subscribed to,
	 *  -1 if error.
	 */
	int pubsub_numpat();

private:
	int subop(const char* cmd, const std::vector<const char*>& channels);
	int subop(const char* cmd, const std::vector<string>& channels);
	int check_channel(const redis_result* obj, const char* cmd,
		const string& channel);
	int pubsub_numsub(std::map<string, int>& out);
};

} // namespace acl
