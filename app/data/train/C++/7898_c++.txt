#include "GameEngine.h"

GameEngine::GameEngine(
	IGameWindow* const gameWindow,
	OglEngine* const graphicsEngine,
	IMessagePump* const messagePump,
	nz::Config* const config) :
	GameLoop(STEP_RATE),
	_gameWindow(gameWindow),
	_graphicsEngine(graphicsEngine),
	_messagePump(messagePump),
	_config(config),
	_messageActionMap(MessageActionMap()),
	_game(Game(&_messageActionMap, graphicsEngine)) {}

void GameEngine::Update(micro_seconds step)
{
	// Pump messages.
	_messagePump->Pump();
	while (_messagePump->GetCount() != 0)
	{
		GameMessage message;
		if (_messagePump->TryGetMessage(&message))
		{
			switch (message.type)
			{
			case GameMessageType::Quit:
			{
				StopLoop();
				break;
			}
			case GameMessageType::Keyboard:
			{
				_messageActionMap.InvokeKeyActions(message.key.key, message.key.keyIsDown, message.key.isRepeat);
				break;
			}
			case GameMessageType::MouseButton:
			{
				_messageActionMap.InvokeMouseButtonActions(
					message.mouse.button, message.mouse.isDown, Point2(message.mouse.clientX, message.mouse.clientY));
				break;
			}
			case GameMessageType::ClientWindowResize:
			{
				_graphicsEngine->SetViewport(message.windowResize.NewWidth, message.windowResize.NewHeight);
				break;
			}
			default: break;
			}
		}
	}

	// Update the game.
	_game.Update(step);
}

void GameEngine::Draw(double interpolation)
{
	_game.Draw(interpolation);

	// This should usually be done last because we want to render queued objects.
	_graphicsEngine->Draw();
}
