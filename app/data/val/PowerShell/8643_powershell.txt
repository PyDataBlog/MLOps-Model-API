
function Test-SharegateModule {

	# Check if Sharegate is installed
	if ((Get-Module | where { $_.Name -eq "Sharegate" }).Count -ne 1) {
		return $false
	}
	else
	{
		return $true
	}
}

<#
    .SYNOPSIS
		Import data into a site and subsites hierarchy using Excel files
	
    .DESCRIPTION
		Recursively import data with Sharegate from a folder hierarchy into a mirror site and subsites hierarchy. 
		The folder structure can be generated by using the feature "Export from SharePoint" from Sharegate

    --------------------------------------------------------------------------------------
    Module 'Dynamite.PowerShell.Toolkit'
    by: GSoft, Team Dynamite.
    > GSoft & Dynamite : http://www.gsoft.com
    > Dynamite Github : https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit
    > Documentation : https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit/wiki
    --------------------------------------------------------------------------------------
		
    .PARAMETER FromFolder
	    [REQUIRED] The root folder path that contains data

    .PARAMETER ToUrl
	    [REQUIRED] The root site URL to import to. Must be a mirror strucutre as the folder one

	.PARAMETER MappingSettings
	    [OPTIONAL] Specifies custom Sharegate property mappings like columns act as composite key and associations between source and destination.
		Note: applies on all lists and libraries found in the source folder.
		(See. http://help.share-gate.com/article/508-set-property-mapping-property-mapping-powershell for more information).

	.PARAMETER PropertyTemplate
	    [OPTIONAL] Specifies custom Sharegate property template like items status after copy (Published, Approved, etc.)
		Note: applies on all lists and libraries found in the source folder.
		(See. http://help.share-gate.com/article/501-new-property-template-copying-content-powershell for more information).

	.PARAMETER PropertyTemplateFile
	    [OPTIONAL] Specifies custom Sharegate property template file (*.sgt)
		Note: applies on all lists and libraries found in the source folder.

	.PARAMETER $TemplateName
	    [OPTIONAL] Specifies the name of the custom Sharegate property template file (*.sgt). This name corresponds to the title set when it was exported with Sharegate UI.
		Note: applies on all lists and libraries found in the source folder.

	.PARAMETER CopySettings
	    [OPTIONAL] Specifies custom Sharegate copy settings like items exist behavior, etc.)
		Note: applies on all lists and libraries found in the source folder.
	    (See. http://help.share-gate.com/article/479-new-copy-settings-general-powershell for more information).

	.PARAMETER LogFolder
		[REQUIRED] The log folder where save reports exported by Sharegate (*.xslx reports)

	.PARAMETER ThreadNumberPerWeb
		[OPTIONAL] Represents the number of webs that can be processed at the same time by the cmdlet. Default is 20.

	.PARAMETER ThreadNumberPerList
		[OPTIONAL] Represents the number of lists that can be processed at the same time in a web by the cmdlet. Default is 20.

    .EXAMPLE
		    PS C:\> Import-DSPData -FromFolder "C:\Sharegate" -ToUrl "http://webapp/sites/test"
		 
			PS C:\>	# Custom property mapping settings
					$MappingSettings = New-MappingSettings 

					# Remove default keys
					Set-PropertyMapping -MappingSettings $MappingSettings -Source Title -Destination Title
					Set-PropertyMapping -MappingSettings $MappingSettings -Source Created -Destination Created

					# Add custom keys
					Set-PropertyMapping -MappingSettings $MappingSettings -Source ID -Destination ID -Key
					Set-PropertyMapping -MappingSettings $MappingSettings -Source ContentType -Destination ContentType -Key

					Import-DSPData -FromFolder "C:\Sharegate" -ToUrl "http://webapp/sites/test" -MappingSettings $MappingSettings

			PS C:\> Import-DSPData -FromFolder "C:\Sharegate" -ToUrl "http://webapp/sites/test" -PropertyTemplate (New-PropertyTemplate -CheckInAs Publish) -CopySettings (New-CopySettings -OnContentItemExists Overwrite)

			PS C:\> Import-DSPData -FromFolder "C:\Sharegate" -ToUrl "http://webapp/sites/test" -ThreadNumberPerWeb 10 -ThreadNumberPerList 10

			PS C:\> Import-DSPData -FromFolder "C:\Sharegate" -ToUrl "http://webapp/sites/test" -ThreadNumberPerWeb 10 -ThreadNumberPerList 10 -PropertyTemplateFile D:\DynamitePropertyTemplate.sgt -TemplateName "CrossSitePublishingCMSTemplate"

    .LINK
    GSoft, Team Dynamite on Github
    > https://github.com/GSoft-SharePoint
    
    Dynamite PowerShell Toolkit on Github
    > https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit
    
    Documentation
    > https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit/wiki
    
#>
function Import-DSPData {

	[CmdletBinding(DefaultParameterSetName="PropertyTemplateObject")]
	Param
	(
		[ValidateScript({Test-Path $_ -PathType 'Container'})] 
		[Parameter(Mandatory=$true)]
		[string]$FromFolder,

		[Parameter(Mandatory=$true)]
		[string]$ToUrl,  

		[Parameter(Mandatory=$false)]
		$MappingSettings = (New-MappingSettings),

		[Parameter(Mandatory=$false, ParameterSetName = "PropertyTemplateObject")]
		$PropertyTemplate = (New-PropertyTemplate -CheckInAs Publish -ContentApproval Approved -VersionHistory -VersionLimit 5 -WebParts -NoLinkCorrection -AuthorsAndTimestamps),

		[Parameter(Mandatory=$false)]
		$CopySettings = (New-CopySettings -OnContentItemExists Overwrite),

		[Parameter(Mandatory=$false, ParameterSetName = "PropertyTemplateFile")]
		[ValidateScript({Test-Path $_ -PathType 'Leaf'})]
		$PropertyTemplateFile,

		[Parameter(Mandatory=$false, ParameterSetName = "PropertyTemplateFile")]
		[string]$TemplateName,

		[Parameter(Mandatory=$false)]
		[int]$ThreadNumberPerWeb = 5,

		[Parameter(Mandatory=$false)]
		[int]$ThreadNumberPerList = 5,

        [Parameter(Mandatory=$true)]
		[string]$LogFolder
	)

    function Process-WebFolder {

        Param
	    (
            [Parameter(Mandatory=$true)]
		    [string]$WebUrl,

		    [Parameter(Mandatory=$true)]
		    [string]$WebFolder
	    )

        $Lists = New-Object System.Collections.ArrayList

        # Add a new entry for the web
        $Webs.Add($WebUrl, $null)

        $SubFolders = Get-ChildItem $WebFolder -Directory  

		$SubFolders | ForEach-Object {

            $CurrentFolder = $_
            $Title = $CurrentFolder.Name
		
            # Getting only subsites under the current web (first without name trimming)
            $AssociatedSubSites = Get-Subsite -Site (Connect-Site $WebUrl) -Name $Title

			if ($AssociatedSubSites -eq $null -and ($CurrentFolder.Name -match "[\s]*[\d]$"))
			{
				# If the current folder appears to be a duplicate incremented automatically by Sharegate
				$Title = $CurrentFolder.Name -replace "[\s]*[\d]$"
				
				# Getting only subsites under the current web (with name trimming)
				$AssociatedSubSites = Get-Subsite -Site (Connect-Site $WebUrl) -Name $Title
			}
           
            if ($AssociatedSubSites)
            {
                # Get the first web which is not already in the web collection. Theoretically, it should be the same order as Sharegate export
                $AssociatedWeb = $AssociatedSubSites | Where-Object { $Webs.Get_Item($_.Address.AbsoluteUri) -eq $null } | Select-Object -First 1

                $FolderUrl = $CurrentFolder.FullName
                $WebFullUrl = $AssociatedWeb.Address

				Write-Host "Match " -NoNewline 
                Write-Host "'$Title' " -NoNewline -ForegroundColor Green
				Write-Host "with web " -NoNewline
				Write-Host "'$WebFullUrl'" -ForegroundColor Yellow
  
                Process-WebFolder -WebUrl $WebFullUrl -WebFolder $CurrentFolder.FullName 
            }
            else
            {
                $Lists.Add($_) | Out-Null
            }  
        }

        # Add lists for this web
        $Webs.Set_Item($WebUrl, $Lists) 
    }

	Try
	{	
		# Define a mutex to read the Sharegate SGT file
		$Mutex = New-Object System.Threading.Mutex($false, "SgtFileMutex")

		# Default log file for thread activities
		$ThreadLogFile = Join-Path $LogFolder -ChildPath ("Import-DSPData_" + (Get-Date).ToString("yyyyMMddThhmmssZ") +".log")

	    # Create log folder if doesn't exist
        if((Test-Path $LogFolder -PathType 'Container') -eq $false)
        {
            Write-Warning "Log folder $LogFolder doesn't exist. Creating..."            
            New-Item -Path $LogFolder -ItemType Directory -Force
        }  

        $Webs = @{} 

        Process-WebFolder -WebUrl $ToUrl -WebFolder $FromFolder

		# Process all webs 
        $Webs.Keys | Invoke-Parallel -ImportVariables -ImportModules -Throttle $ThreadNumberPerWeb -LogFile $ThreadLogFile -ScriptBlock {
        
            $CurrentWeb = $_

            Write-Host "Processing " -NoNewline 
			Write-Host "'$CurrentWeb'" -ForegroundColor Green -NoNewline
			Write-Host "..." 

			# Process all lists
            $Webs.Item($_) | Invoke-Parallel -ImportVariables -ImportModules -Throttle $ThreadNumberPerList -LogFile $ThreadLogFile -ScriptBlock {
            
                $ListName = $_.Name
                $SourceFolder = $_.FullName  
                      
				$ExcelFile = Get-ChildItem $SourceFolder -Include *.xlsx,*.xls -Recurse | Where-Object { $_.Name -match $_.Directory.Name } | Select -First 1

                $Site = Connect-Site -Url $CurrentWeb
                $DestList = Get-List -Site $Site -Name $ListName
				
				Write-Host "`tProcessing list folder " -NoNewline 
				Write-Host "'$ListName'" -ForegroundColor Yellow -NoNewline
				Write-Host "..." 
				
                if ($DestList)
                {
					# Log file
                    $FileName = (($CurrentWeb.ToLower().Replace($ToUrl.ToLower(),[string]::Empty) -Replace "^.","") -Replace ".$","").Replace("/","_") + "_"+ $ListName
					if ($FileName.StartsWith("_"))
					{
						$FileName = $FileName.TrimStart("_")
					}

                    $ExportFilePath = Join-Path -Path $LogFolder -ChildPath  $FileName

                    $SessionId = ((Get-Date -Format "yyMMdd") + "-1")
      
                    if ($DestList.BaseType -eq "Document Library")
                    {
                        Write-Host "`t`tList '$ListName' found in web '$CurrentWeb'! Importing documents..."

						if (([string]::IsNullOrEmpty($PropertyTemplateFile)) -and ([string]::IsNullOrEmpty($TemplateName)))
						{
							Import-Document -ExcelFilePath $ExcelFile.FullName -DestinationList $DestList -MappingSettings $MappingSettings -Template $PropertyTemplate -CopySettings $CopySettings | Export-Report -Path $ExportFilePath -Overwrite 						
						}
						else
						{
							Write-Warning "Using custom property template file '$PropertyTemplateFile'"
							[void]$Mutex.WaitOne()
							Import-PropertyTemplate -Path $PropertyTemplateFile -List $DestList
							[void]$Mutex.ReleaseMutex()
							Import-Document -ExcelFilePath $ExcelFile.FullName -DestinationList $DestList -MappingSettings $MappingSettings -CopySettings $CopySettings -TemplateName $TemplateName | Export-Report -Path $ExportFilePath -Overwrite 
						}
					}
                    else
                    {                       
                        # Get a fake list (not needed in the Copy-Content cmdlet because we use an Excel file but necessary for the cmdlet)
                        # To ensure Sharegate will not connect to this list, we have to get one where attachments are disabled (Sharegate hack)
                        # We get a list in the central admin root web to avoid the case where the current web does not contain any list.
                        $webApp = Get-SPWebApplication -IncludeCentralAdministration | Where-Object { $_.IsAdministrationWebApplication -eq $true }
			            $SrcList = Connect-Site -Url $webApp.Url  | Get-List | Where-Object {$_.BaseType -eq "List" -and $_.EnableAttachments -eq $false} | Select -First 1

                        Write-Host "`t`tList '$ListName' found! Importing list items..."

						if (([string]::IsNullOrEmpty($PropertyTemplateFile)) -and ([string]::IsNullOrEmpty($TemplateName)))
						{
							Copy-Content -SourceList $SrcList -DestinationList $DestList -ExcelFilePath $ExcelFile.FullName -MappingSettings $MappingSettings -Template $PropertyTemplate -CopySettings $CopySettings | Export-Report -Path $ExportFilePath -Overwrite 
						}

						else
						{						
							Write-Warning "Using custom property template file '$PropertyTemplateFile'"
							[void]$Mutex.WaitOne()
							Import-PropertyTemplate -Path $PropertyTemplateFile -List $DestList
							[void]$Mutex.ReleaseMutex()
							Copy-Content -SourceList $SrcList -DestinationList $DestList -ExcelFilePath $ExcelFile.FullName -MappingSettings $MappingSettings -TemplateName $TemplateName -CopySettings $CopySettings | Export-Report -Path $ExportFilePath -Overwrite 
						}
					}
                }
				else
				{					
					    Write-Warning "`t`tList '$ListName' not found in web '$CurrentWeb'! Skipping..."
				}         
            }  
        }
	}
	Catch
	{
		$ErrorMessage = $_.Exception.Message
        Throw $ErrorMessage
	}
}

<#
    .SYNOPSIS
		Copy lists data from a site hierarchy to an other using Sharegate
	
    .DESCRIPTION
		Import content of lists bewtween a single source site or a site hierarchy, to a mirror one using Sharegate.

    --------------------------------------------------------------------------------------
    Module 'Dynamite.PowerShell.Toolkit'
    by: GSoft, Team Dynamite.
    > GSoft & Dynamite : http://www.gsoft.com
    > Dynamite Github : https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit
    > Documentation : https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit/wiki
    --------------------------------------------------------------------------------------
		
    .PARAMETER FormUrl
	    [REQUIRED] The source site URL to start copy from

    .PARAMETER ToUrl
	    [REQUIRED] The destination site URL to import to. Must be a mirror strucutre as the source one

    .PARAMETER ListNames
	    [REQUIRED] The lists names to copy from source to destination site.

    .PARAMETER IncludeChildren
	    [REQUIRED] If specified, try to match children sites between source and destination based on path and url depth for content copying.
                   By default, only a single site is considered according to 'FromUrl' and 'ToUrl' parameters. For root site, URL can be different (explicit match)

	.PARAMETER MappingSettings
	    [OPTIONAL] Specifies custom Sharegate property mappings like columns act as composite key and associations between source and destination.
		Note: applies on all lists and libraries found in the source folder.
		(See. http://help.share-gate.com/article/508-set-property-mapping-property-mapping-powershell for more information).

	.PARAMETER PropertyTemplate
	    [OPTIONAL] Specifies custom Sharegate property template like items status after copy (Published, Approved, etc.)
		Note: applies on all lists and libraries found in the source folder.
		(See. http://help.share-gate.com/article/501-new-property-template-copying-content-powershell for more information).

	.PARAMETER PropertyTemplateFile
	    [OPTIONAL] Specifies custom Sharegate property template file (*.sgt)
		Note: applies on all lists and libraries found in the source folder.

	.PARAMETER $TemplateName
	    [OPTIONAL] Specifies the name of the custom Sharegate property template file (*.sgt). This name corresponds to the title set when it was exported with Sharegate UI.
		Note: applies on all lists and libraries found in the source folder.

	.PARAMETER CopySettings
	    [OPTIONAL] Specifies custom Sharegate copy settings like items exist behavior, etc.)
		Note: applies on all lists and libraries found in the source folder.
	    (See. http://help.share-gate.com/article/479-new-copy-settings-general-powershell for more information).

	.PARAMETER LogFolder
		[REQUIRED] The log folder where save reports exported by Sharegate (*.xslx reports)

	.PARAMETER ThreadNumberPerWeb
		[OPTIONAL] Represents the number of webs that can be processed at the same time by the cmdlet. Default is 20.

	.PARAMETER ThreadNumberPerList
		[OPTIONAL] Represents the number of lists that can be processed at the same time in a web by the cmdlet. Default is 20.

    .EXAMPLE
		    PS C:\> Copy-DSPData -FromUrl "http://webapp/sites/source_site" -ToUrl "http://webapp/sites/destination_site"

		    PS C:\> Copy-DSPData -FromUrl "http://webapp/sites/source_site" -ToUrl "http://webapp/sites/destination_site" -ListNames "Pages","MyCustomList" -IncludeChildren
		 
			PS C:\>	# Custom property mapping settings
					$MappingSettings = New-MappingSettings 

					# Remove default keys
					Set-PropertyMapping -MappingSettings $MappingSettings -Source Title -Destination Title
					Set-PropertyMapping -MappingSettings $MappingSettings -Source Created -Destination Created

					# Add custom keys
					Set-PropertyMapping -MappingSettings $MappingSettings -Source ID -Destination ID -Key
					Set-PropertyMapping -MappingSettings $MappingSettings -Source ContentType -Destination ContentType -Key

					Copy-DSPData -FromUrl "http://webapp/sites/source_site" -ToUrl "http://webapp/sites/test" -MappingSettings $MappingSettings

			PS C:\> Copy-DSPData -FromUrl "http://webapp/sites/source_site" -ToUrl "http://webapp/sites/test" -PropertyTemplate (New-PropertyTemplate -CheckInAs Publish) -CopySettings (New-CopySettings -OnContentItemExists Overwrite)

			PS C:\> Copy-DSPData -FromUrl "http://webapp/sites/source_site" -ToUrl "http://webapp/sites/test" -ThreadNumberPerWeb 10 -ThreadNumberPerList 10

			PS C:\> Copy-DSPData -FromUrl "http://webapp/sites/source_site" -ToUrl "http://webapp/sites/test" -ThreadNumberPerWeb 10 -ThreadNumberPerList 10 -PropertyTemplateFile D:\DynamitePropertyTemplate.sgt -TemplateName "CrossSitePublishingCMSTemplate"

    .LINK
    GSoft, Team Dynamite on Github
    > https://github.com/GSoft-SharePoint
    
    Dynamite PowerShell Toolkit on Github
    > https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit
    
    Documentation
    > https://github.com/GSoft-SharePoint/Dynamite-PowerShell-Toolkit/wiki
    
#>
function Copy-DSPData {

    [CmdletBinding(DefaultParameterSetName="PropertyTemplateObject")]
	Param
	(
		[ValidateScript({
            Try {
                $Web = New-Object System.Net.WebClient
                $Web.UseDefaultCredentials = $true
                $Web.OpenRead($_)
                return $true
            } 
            Catch
            {
                return $false
            }
        })]
		[Parameter(Mandatory=$true)]
		[string]$FromUrl,

		[ValidateScript({
            Try {
                $Web = New-Object System.Net.WebClient
                $Web.UseDefaultCredentials = $true
                $Web.OpenRead($_)
                return $true
            } 
            Catch
            {
                return $false
            }
        })]
		[Parameter(Mandatory=$true)]
		[string]$ToUrl,

		[Parameter(Mandatory=$false)]
		[array]$ListNames=@("Pages","Documents","Images"),

		[Parameter(Mandatory=$false)]
		[switch]$IncludeChildren=$false,

		[Parameter(Mandatory=$false)]
		$MappingSettings = (New-MappingSettings),

		[Parameter(Mandatory=$false, ParameterSetName = "PropertyTemplateObject")]
		$PropertyTemplate = (New-PropertyTemplate -CheckInAs Publish -ContentApproval Approved -VersionHistory -VersionLimit 5 -WebParts -AuthorsAndTimestamps),

		[Parameter(Mandatory=$false)]
		$CopySettings = (New-CopySettings -OnContentItemExists Overwrite),

		[Parameter(Mandatory=$false, ParameterSetName = "PropertyTemplateFile")]
		[ValidateScript({Test-Path $_ -PathType 'Leaf'})]
		$PropertyTemplateFile,

		[Parameter(Mandatory=$false, ParameterSetName = "PropertyTemplateFile")]
		[string]$TemplateName,

		[Parameter(Mandatory=$false)]
		[int]$ThreadNumberPerWeb = 5,

		[Parameter(Mandatory=$false)]
		[int]$ThreadNumberPerList = 5,

        [Parameter(Mandatory=$true)]
		[string]$LogFolder
	)

    function Get-Subsites {

        Param
	    (
            [Parameter(Mandatory=$true)]
		    [string]$RootUrl      
	    )

        $SiteList = @()
        $CurrentSite = (Connect-Site $RootUrl)
        
        # Get only the direct sub sites (no recursion)
        $SubSites = Get-Subsite $CurrentSite

        $SubSites | ForEach-Object {

            # Get all children
            $ChildSites = Get-Subsites -RootUrl $_.Address

            # Add the current web to the list
            $SiteList += $_

            # Add current web and all its subsites
            $SiteList = $SiteList + $ChildSites    
        }

        return $SiteList
    }

    Try
	{	
		# Default log file for thread activities
		$ThreadLogFile = Join-Path $LogFolder -ChildPath ("Copy-DSPData_" + (Get-Date).ToString("yyyyMMddThhmmssZ") +".log")

	    # Create log folder if doesn't exist
        if((Test-Path $LogFolder -PathType 'Container') -eq $false)
        {
            Write-Warning "Log folder $LogFolder doesn't exist. Creating..."            
            New-Item -Path $LogFolder -ItemType Directory -Force
        } 

        $SourceSites = @()
        $DestSites = @()

        $SourceSite = Connect-Site $FromUrl
        $DestinationSite = Connect-Site $ToUrl

        # Add source and destinaation sites
        $SourceSites += $SourceSite
        $DestSites += $DestinationSite

        if ($IncludeChildren)
        {
            $SourceSites += (Get-Subsites -RootUrl $FromUrl)
            $DestSites += (Get-Subsites -RootUrl $ToUrl)
        }
      
        # Get matches between the two according to the "path" property and URL depth (primary key for a SPWeb)
        $SiteMappings = @{}

        $SourceSites | Foreach-Object { 

            $CurrentSourceItem = $_
            $CurrentSourceItemUrl = $CurrentSourceItem.Address

            if ($CurrentSourceItemUrl -ne $SourceSite.Address)
            {
                $CurrentSourceItemSegmentsCount = ([System.Uri]($CurrentSourceItem.Address)).Segments.Count
                $CurrentSourceItemSitePath = Split-Path -Path $CurrentSourceItem.Address -Leaf
    
                $AssociatedDestItem = $DestSites | Where-Object { (Split-Path -Path $_.Address -Leaf) -eq $CurrentSourceItemSitePath -and ([System.Uri]($_.Address)).Segments.Count -eq $CurrentSourceItemSegmentsCount } | Select-Object -First 1
                if ($AssociatedDestItem -ne $null)
                {
                    $AssociatedDestItemUrl = $AssociatedDestItem.Address
                    Write-Debug "Matching '$CurrentSourceItemUrl' with '$AssociatedDestItemUrl'."

                    $SiteMappings.Add($CurrentSourceItem, $AssociatedDestItem)
                }
            }
            else
            {
                $AssociatedDestItemUrl = $DestinationSite.Address
                Write-Debug "Matching '$CurrentSourceItemUrl' with '$AssociatedDestItemUrl'."

                # Explicit match according to cmdlet parameters
                $SiteMappings.Add($SourceSite, $DestinationSite)
            }
        }

        # For each web association, get source and destination list according to parameters
        $SiteMappings.Keys | Invoke-Parallel -ImportVariables -Throttle $ThreadNumberPerWeb -LogFile $ThreadLogFile -ScriptBlock {
            
            $SourceWeb = $_
            $SourceWebUrl = $SourceWeb.Address
            $DestinationWeb = $SiteMappings.Get_item($_)
            $DestinationWebUrl = $DestinationWeb.Address
             
            $ListMappings = @{}
            
            # Get Source Lists
            $SourceLists = Get-List -Site $SourceWeb -Name $ListNames

            # Get Destination Lists
            $DestLists = Get-List -Site $DestinationWeb -Name $ListNames

            # Get matches between the two according to the "Title" property
            $SourceLists | Foreach-Object { 

                $CurrentSourceItem = $_
                $CurrentSourceItemTitle = $CurrentSourceItem.Title
    
                $AssociatedDestItem = $DestLists | Where-Object { $_.Title -eq $CurrentSourceItemTitle } | Select-Object -First 1
                if ($AssociatedDestItem -ne $null)
                {
                    $ListMappings.Add($CurrentSourceItem, $AssociatedDestItem)
                }
            }

            # For each list association do the copy
            $ListMappings.Keys | Invoke-Parallel -ImportVariables -Throttle $ThreadNumberPerList -LogFile $ThreadLogFile -ScriptBlock {
                
                $SrcList = $_
                $SrcListTitle = $SrcList.Title

                $DestList = $ListMappings.Get_Item($_)
                $DestListTitle = $DestList.Title

				# Log file
                $FileName = $SourceWeb.Title.ToLower() + "_" + $SrcList.Title.ToLower()

				if ($FileName.EndsWith("_"))
				{
					$FileName = $FileName.TrimEnd("_")
				}

                [void]$Mutex.WaitOne()
                Write-Host "---------------------------------------------------------------------------------"
                Write-Host "Copy from web " -NoNewLine
                Write-Host "'$SourceWebUrl'" -ForegroundColor Green -NoNewline
                Write-Host " to " -NoNewline
                Write-Host "'$DestinationWebUrl'" -ForegroundColor Green

                Write-Host "`tCopying content from list " -NoNewLine

				Write-Host "'$SrcListTitle'" -ForegroundColor Yellow -NoNewline
				Write-Host " to list "-NoNewline
                Write-Host "'$DestListTitle'" -ForegroundColor Yellow   
                [void]$Mutex.ReleaseMutex()

                $ExportFilePath = Join-Path -Path $LogFolder -ChildPath $FileName

                if (([string]::IsNullOrEmpty($PropertyTemplateFile)) -and ([string]::IsNullOrEmpty($TemplateName)))
				{
					Copy-Content -SourceList $SrcList -DestinationList $DestList -MappingSettings $MappingSettings -Template $PropertyTemplate -CopySettings $CopySettings | Export-Report -Path $ExportFilePath -Overwrite 
				}
				else
				{						
					Write-Warning "Using custom property template file '$PropertyTemplateFile'"
					[void]$Mutex.WaitOne()
					Import-PropertyTemplate -Path $PropertyTemplateFile -List $DestList
					[void]$Mutex.ReleaseMutex()
					Copy-Content -SourceList $SrcList -DestinationList $DestList -MappingSettings $MappingSettings -TemplateName $TemplateName -CopySettings $CopySettings | Export-Report -Path $ExportFilePath -Overwrite 
				}  
            }
        }
	}
	Catch
	{
		$ErrorMessage = $_.Exception.Message
        Throw $ErrorMessage
	}
}