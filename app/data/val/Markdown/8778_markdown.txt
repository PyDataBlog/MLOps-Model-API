# Chapter 2. Type less, Do more 

## Semicolons 
  * **continued after** = { , . operator   

## Variable Declarations 
  * val (value object)
  * var (change value, don't change object type)
  * initialized immediately
    - except: using at constructor
  * no primitive type 
  * use **val**

 ## Ranges 
  * literal 
  * Int, Long, Float, Double, Char, BigInt, BigDecimal 

  ```scala 
  1 to 10
  1 until 10
  1 to 10 by 3 
  10 to 1 by -3 
  1.1f to 10.3f by 3.1f       // Float
  1.1 to 10.3 by 3.1          // Double
  'a' to 'g' by 3             // Char
  BigInt(1) to BigInt(10) by 3  
  ``` 

## Partial Function 
  * Functions are partial in the sense that they aren't defined for all possible inputs, only those inputs that match at least one of the specified case clause 
  * case clauses, enclosed in curly braces {} 
  * isDefinedAt for check 
  * chain PartialFunctions 
  ```scala
  val pf1: PartialFunction[Any,String] = { case s: String => "Yes" }
  val pf2: PartialFunction[Any,Double] = { case d: Double => "Yes" }

  val pf = pf1 orElse pf2 
  ```

## Method Declarations 

### Method Default and Named Arguments 
  * case class copy method
  * used with parameter name 
  ```scala
  val p1 = new Point(x=3.3, y=4.4)
  val p2 = p1.copy(y=6.6)
  ``` 

### Methods with Multiple Argument Lists 
  * function( , ) == function ( )( )
  ```scala
  def draw(offset: Point = Point(0.0,0.0))(f: String => Unit): Unit = { ... }
  ```

  ```scala
  s.draw(Point(1.0,2.0))(str => println(s"Shapes..."))
  ```
  * **change argument list ( ) => { }**
  ```scala
  s.draw(Point(1.0,2.0)){
    str => println(s"Shapes...")
  }
  ```
  * **3 case with last argument**
    - ( ) -> { }
    - type inference 
    - implicit argument 

### Future 
  * implicit argument
  ```scala
  apply[T](body: => T)(implicit executor: ExecutionContext): = { ... }
  ```
  * implicit val
  ```scala
  object Implicits {
    implicit val global: ExecutionContext ...
  }
  ```

### Nesting Method Definitions and Recursion 
  * Method definition can also be nested 
    - using recursively, divided to small functions
  * Parameter shadow 
    - The use of i as parameter of nested function shadow outer use of i 
  * tail-call optimization 
    - convert a tail-call optimization into a loop 
    - use @tailrec 
    - except: trampoline calls i.e. "a calls b calls a calls b"

### Inferring Type Information 
  ```scala
  val intToStringMap2 = new HashMap[Integer,String]
  ```
  * Subtype polymorphism (inheritance): Limited Inferring Type 
  * Explicit Type Annotations
    - val, var declaration don't assign value i.e. abstract class 
    - All method parameter 
    - method return type 
      + explicit use ```return``` 
      + recursive 
      + overloading method & one call another 
      + infered by Any 
  * variadic method 
  ```scala
  def joiner(strings: String*): String = Strings.mkString("-")
  def joiner(strings: List[String]): String = joiner(strings: _*)
  ```
    - ```_*``` : inferred type + variadic 

## Reserved Words 
  * def : start method declaration 
  * forSome : used in existential type declaration 
  * implicit 
  * lazy
  * match 
  * object 
  * override 
  * sealed : applied to a parent type  
  * super 
  * trait : mixin module
  * val 
  * var 
  * with 
  * yield 
  * none
    - *break, continue*
  * escape reserved word : use `match`

## Literal Values 

### Integer Literals 
  * Decimal 
  * Hexadecimal 
  * Type
    - Long, Int, Short, Char, Byte, Range 

### Floating-Point Literals 
  * Float : postfix ```'f' or 'F'```
  * Double 

### Boolean Literals 

### Character Literals 
  ```
  'A', '\u0041', '\n', '\012'
  ```
  * escape character: \b, \t, \n, \f, \r, \", \', \\

### String Literals 
  * """ : multiline string literal  
    - white space indentation : | 

### Symbol Literals 
  * interned strings 
  * refer to the same object in memory 
  ``` 
  Symbol("Programming Scala")
  ```

### Function Literals 
  ```
  val f1: (Int,String) => String        = (i, s) => s+i
  val f2: Function2[Int,String,String]  = (i, s) => s+i 
  ```

### Tuple Literals 
  * First class value
  * immutable 
  * ( , , )
  * Pair 
    - ( 1, "one")
    - 1 -> "one"
    - Tuple2(1, "one")

### Option, Some, None : Avoiding nulls 
  * Option : abstract 
    - Some 
    - None 

  * ```None.get```: NoSuchElementException 
    - use getOrElse 
  * **don't use null**

## Sealed Class Hierachies 
  * prevent users from creating their own 
  * ```sealed class ... ```
    - must be declared in the same source file 

## Organizing Code in Files and Namespaces 
  * Doesn't have to match
    - filename and typename 
    - package structure and directory structure 

  ```
  package a.b.c {
    ...
  }
  ```

  or

  ```
  package a {
    package b {
      package c {
        ...
      }
    }
  }
  ```

  * successive package statement idiom 
  * bring into scope all packages level 
  * package can not be defined within classes and method 

## Importing Types and Their Members 
  * use import 
  * _ : as a wildcard 
  * import static => import 
  * { } : selective importing 
  * You can put import state almost any where 
    - scope 
  * undefined => _
  * alias 

  ```scala
  def stuffWithBigInteger() = {
    import java.math.BigInteger.{
      ONE => _,         // undefined
      TEN,
      ZERO => JAVAZERO  // alias
    }
  }
  ``` 

### Import Are Relative 

  ```
  import scala.collection.mutable._
  import collection.immutable._
  import _root_.scala.collection.parallel._ 
  ```

### Package Objects 
  * Appropriate members to expose to client 

### Abstract type Versus Parameterized Type 
  * Parameterized Type
    - Similar to generic 
    - use [ ]
    - Each Types are independent
    - Parametric Polymorphism 
    - +A : covariant typing 
    - -A : contravaiant typing 

  ```scala
  sealed abstract class List[+A]
  ```

  ```scala 
  abstract class BulkReader[In] {
    val source: In
    def read: String
  }

  class StringBulkReader(val source: String) extends BulkReader[String] {
    def read: String = source 
  }

  class FileBulkReader(val source: File) extends BulkReader[File] {
    def read: String = {
      val in = new BufferedInputStream(new FileInputStream(source))
      val numBytes = in.available() 
      val bytes = new Array[Byte](numBytes)
      in.read(bytes, 0, numBytes)
      new String(bytes)
    }
  }
  ```

  * Abstract Type 
    - type abstract mechanism 
    - can be a member of type 
    - match the *behaviours* 
    - evolve in parallel 
    - family polymorphism 
    - covariant specialization 

  ```scala
  import java.io._

  abstract class BulkReader {
    type In
    val source: In
    def read: String  // Read source and return a String 
  }

  class StringBulkReader(val source: String) extends BulkReader {
    type In = String 
    def read: String = source
  }

  class FileBulkReader(val source: File) extends BulkReader { 
    type In = File 
    def read: String = {
      val in = new BufferedInputStream(new FileInputStream(source))
      val numBytes = in.available()
      var bytes = new Array[Byte](numBytes)
      in.read(bytes, 0, numBytes)
      new String(bytes)
    }
  }

  println(new StringBulkReader("Hello Scala!").read)
  println(new FileBulkReader(new File("TypeLessDoMore/abstract-types.sc")).read)
  ```


