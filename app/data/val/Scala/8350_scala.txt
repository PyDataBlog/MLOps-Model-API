package cwe.scala.library.math.bignumbers
import cwe.scala.library.list.ListService
import cwe.scala.library.math.Rational

/**
 * A real number which wraps an existing real number
 */
abstract class RealWrapper protected (_r: Real) extends Real {
	// Accessors

	def r = _r
	def isNegative: Boolean = r.isNegative
	def getIntegerPart(): List[Byte] = r.getIntegerPart
	def getDecimalPart(): List[Byte] = r.getDecimalPart
	def hasDecimalPart: Boolean = r.hasDecimalPart
	override def isZero: Boolean = r.isZero
	override def isOne: Boolean = r.isOne

	// Dependency injection

	def setRealOperationsService(s: RealOperationsService) = r.setRealOperationsService(s)
	protected[math] def getRealOperationsService(): RealOperationsService = r.getRealOperationsService()

	protected[math] def setNaturalArithmeticService(s: NaturalArithmeticService) = r.setNaturalArithmeticService(s)
	protected[math] def getNaturalArithmeticService(): NaturalArithmeticService = r.getNaturalArithmeticService()

	def setListService(s: ListService) = r.setListService(s)
	protected[math] def getListService(): ListService = r.getListService()

	// Implementation

	protected[math] def divideByPositiveNotZero(that: Real, decimalPrecision: Int): Real = r.divideByPositiveNotZero(that, decimalPrecision)
	protected[math] def multiplyByPositiveNotZero(that: Real): Real = r.multiplyByPositiveNotZero(that)
	protected[math] def addPositiveNotZero(that: Real): Real = r.addPositiveNotZero(that)
	protected[math] def subtractSmallerPositiveNotZero(that: Real): Real = r.subtractSmallerPositiveNotZero(that)
	protected[math] def smallerAbs(that: Real): Boolean = r.smallerAbs(that)
	protected[math] def moduloPositiveNotZero(that: Real): Real = r.moduloPositiveNotZero(that)
	def toRational: Rational[Integer] = r.toRational
	
	/**
	 * Returns true if this == that
	 */
	override def equals(that: Any): Boolean = {
		that match {
			case w: RealWrapper => this.r.equals(w.r)			
			case _ => super.equals(that)
		}
	}

	override def hashCode(): Int = this.r.##	
}