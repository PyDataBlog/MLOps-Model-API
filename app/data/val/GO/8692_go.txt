// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Aggregate aggregate
//
// swagger:model aggregate
type Aggregate struct {

	// links
	Links *AggregateLinks `json:"_links,omitempty"`

	// block storage
	BlockStorage *AggregateBlockStorage `json:"block_storage,omitempty"`

	// cloud storage
	CloudStorage *AggregateCloudStorage `json:"cloud_storage,omitempty"`

	// Timestamp of aggregate creation.
	// Example: 2018-01-01T12:00:00-04:00
	// Read Only: true
	CreateTime string `json:"create_time,omitempty"`

	// data encryption
	DataEncryption *AggregateDataEncryption `json:"data_encryption,omitempty"`

	// dr home node
	DrHomeNode *AggregateDrHomeNode `json:"dr_home_node,omitempty"`

	// home node
	HomeNode *AggregateHomeNode `json:"home_node,omitempty"`

	// inactive data reporting
	InactiveDataReporting *AggregateInactiveDataReporting `json:"inactive_data_reporting,omitempty"`

	// metric
	Metric *AggregateMetric `json:"metric,omitempty"`

	// Aggregate name.
	// Example: node1_aggr_1
	Name string `json:"name,omitempty"`

	// node
	Node *AggregateNode `json:"node,omitempty"`

	// Information on the aggregate's remaining hot spare disks.
	RecommendationSpares []*AggregateSpare `json:"recommendation_spares,omitempty"`

	// SnapLock type.
	// Enum: [non_snaplock compliance enterprise]
	SnaplockType string `json:"snaplock_type,omitempty"`

	// snapshot
	Snapshot *AggregateSnapshot `json:"snapshot,omitempty"`

	// space
	Space *AggregateSpace `json:"space,omitempty"`

	// Operational state of the aggregate.
	// Read Only: true
	// Enum: [online onlining offline offlining relocating unmounted restricted inconsistent failed unknown]
	State string `json:"state,omitempty"`

	// statistics
	Statistics *AggregateStatistics `json:"statistics,omitempty"`

	// Aggregate UUID.
	// Read Only: true
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this aggregate
func (m *Aggregate) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBlockStorage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCloudStorage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDataEncryption(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDrHomeNode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHomeNode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInactiveDataReporting(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetric(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecommendationSpares(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnaplockType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnapshot(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSpace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatistics(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Aggregate) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *Aggregate) validateBlockStorage(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockStorage) { // not required
		return nil
	}

	if m.BlockStorage != nil {
		if err := m.BlockStorage.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block_storage")
			}
			return err
		}
	}

	return nil
}

func (m *Aggregate) validateCloudStorage(formats strfmt.Registry) error {
	if swag.IsZero(m.CloudStorage) { // not required
		return nil
	}

	if m.CloudStorage != nil {
		if err := m.CloudStorage.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cloud_storage")
			}
			return err
		}
	}

	return nil
}

func (m *Aggregate) validateDataEncryption(formats strfmt.Registry) error {
	if swag.IsZero(m.DataEncryption) { // not required
		return nil
	}

	if m.DataEncryption != nil {
		if err := m.DataEncryption.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("data_encryption")
			}
			return err
		}
	}

	return nil
}

func (m *Aggregate) validateDrHomeNode(formats strfmt.Registry) error {
	if swag.IsZero(m.DrHomeNode) { // not required
		return nil
	}

	if m.DrHomeNode != nil {
		if err := m.DrHomeNode.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dr_home_node")
			}
			return err
		}
	}

	return nil
}

func (m *Aggregate) validateHomeNode(formats strfmt.Registry) error {
	if swag.IsZero(m.HomeNode) { // not required
		return nil
	}

	if m.HomeNode != nil {
		if err := m.HomeNode.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("home_node")
			}
			return err
		}
	}

	return nil
}

func (m *Aggregate) validateInactiveDataReporting(formats strfmt.Registry) error {
	if swag.IsZero(m.InactiveDataReporting) { // not required
		return nil
	}

	if m.InactiveDataReporting != nil {
		if err := m.InactiveDataReporting.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("inactive_data_reporting")
			}
			return err
		}
	}

	return nil
}

func (m *Aggregate) validateMetric(formats strfmt.Registry) error {
	if swag.IsZero(m.Metric) { // not required
		return nil
	}

	if m.Metric != nil {
		if err := m.Metric.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric")
			}
			return err
		}
	}

	return nil
}

func (m *Aggregate) validateNode(formats strfmt.Registry) error {
	if swag.IsZero(m.Node) { // not required
		return nil
	}

	if m.Node != nil {
		if err := m.Node.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node")
			}
			return err
		}
	}

	return nil
}

func (m *Aggregate) validateRecommendationSpares(formats strfmt.Registry) error {
	if swag.IsZero(m.RecommendationSpares) { // not required
		return nil
	}

	for i := 0; i < len(m.RecommendationSpares); i++ {
		if swag.IsZero(m.RecommendationSpares[i]) { // not required
			continue
		}

		if m.RecommendationSpares[i] != nil {
			if err := m.RecommendationSpares[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("recommendation_spares" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var aggregateTypeSnaplockTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["non_snaplock","compliance","enterprise"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		aggregateTypeSnaplockTypePropEnum = append(aggregateTypeSnaplockTypePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// aggregate
	// Aggregate
	// snaplock_type
	// SnaplockType
	// non_snaplock
	// END DEBUGGING
	// AggregateSnaplockTypeNonSnaplock captures enum value "non_snaplock"
	AggregateSnaplockTypeNonSnaplock string = "non_snaplock"

	// BEGIN DEBUGGING
	// aggregate
	// Aggregate
	// snaplock_type
	// SnaplockType
	// compliance
	// END DEBUGGING
	// AggregateSnaplockTypeCompliance captures enum value "compliance"
	AggregateSnaplockTypeCompliance string = "compliance"

	// BEGIN DEBUGGING
	// aggregate
	// Aggregate
	// snaplock_type
	// SnaplockType
	// enterprise
	// END DEBUGGING
	// AggregateSnaplockTypeEnterprise captures enum value "enterprise"
	AggregateSnaplockTypeEnterprise string = "enterprise"
)

// prop value enum
func (m *Aggregate) validateSnaplockTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, aggregateTypeSnaplockTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Aggregate) validateSnaplockType(formats strfmt.Registry) error {
	if swag.IsZero(m.SnaplockType) { // not required
		return nil
	}

	// value enum
	if err := m.validateSnaplockTypeEnum("snaplock_type", "body", m.SnaplockType); err != nil {
		return err
	}

	return nil
}

func (m *Aggregate) validateSnapshot(formats strfmt.Registry) error {
	if swag.IsZero(m.Snapshot) { // not required
		return nil
	}

	if m.Snapshot != nil {
		if err := m.Snapshot.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshot")
			}
			return err
		}
	}

	return nil
}

func (m *Aggregate) validateSpace(formats strfmt.Registry) error {
	if swag.IsZero(m.Space) { // not required
		return nil
	}

	if m.Space != nil {
		if err := m.Space.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space")
			}
			return err
		}
	}

	return nil
}

var aggregateTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["online","onlining","offline","offlining","relocating","unmounted","restricted","inconsistent","failed","unknown"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		aggregateTypeStatePropEnum = append(aggregateTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// aggregate
	// Aggregate
	// state
	// State
	// online
	// END DEBUGGING
	// AggregateStateOnline captures enum value "online"
	AggregateStateOnline string = "online"

	// BEGIN DEBUGGING
	// aggregate
	// Aggregate
	// state
	// State
	// onlining
	// END DEBUGGING
	// AggregateStateOnlining captures enum value "onlining"
	AggregateStateOnlining string = "onlining"

	// BEGIN DEBUGGING
	// aggregate
	// Aggregate
	// state
	// State
	// offline
	// END DEBUGGING
	// AggregateStateOffline captures enum value "offline"
	AggregateStateOffline string = "offline"

	// BEGIN DEBUGGING
	// aggregate
	// Aggregate
	// state
	// State
	// offlining
	// END DEBUGGING
	// AggregateStateOfflining captures enum value "offlining"
	AggregateStateOfflining string = "offlining"

	// BEGIN DEBUGGING
	// aggregate
	// Aggregate
	// state
	// State
	// relocating
	// END DEBUGGING
	// AggregateStateRelocating captures enum value "relocating"
	AggregateStateRelocating string = "relocating"

	// BEGIN DEBUGGING
	// aggregate
	// Aggregate
	// state
	// State
	// unmounted
	// END DEBUGGING
	// AggregateStateUnmounted captures enum value "unmounted"
	AggregateStateUnmounted string = "unmounted"

	// BEGIN DEBUGGING
	// aggregate
	// Aggregate
	// state
	// State
	// restricted
	// END DEBUGGING
	// AggregateStateRestricted captures enum value "restricted"
	AggregateStateRestricted string = "restricted"

	// BEGIN DEBUGGING
	// aggregate
	// Aggregate
	// state
	// State
	// inconsistent
	// END DEBUGGING
	// AggregateStateInconsistent captures enum value "inconsistent"
	AggregateStateInconsistent string = "inconsistent"

	// BEGIN DEBUGGING
	// aggregate
	// Aggregate
	// state
	// State
	// failed
	// END DEBUGGING
	// AggregateStateFailed captures enum value "failed"
	AggregateStateFailed string = "failed"

	// BEGIN DEBUGGING
	// aggregate
	// Aggregate
	// state
	// State
	// unknown
	// END DEBUGGING
	// AggregateStateUnknown captures enum value "unknown"
	AggregateStateUnknown string = "unknown"
)

// prop value enum
func (m *Aggregate) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, aggregateTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Aggregate) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *Aggregate) validateStatistics(formats strfmt.Registry) error {
	if swag.IsZero(m.Statistics) { // not required
		return nil
	}

	if m.Statistics != nil {
		if err := m.Statistics.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this aggregate based on the context it is used
func (m *Aggregate) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBlockStorage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCloudStorage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreateTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDataEncryption(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDrHomeNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHomeNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInactiveDataReporting(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMetric(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRecommendationSpares(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSnapshot(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSpace(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatistics(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Aggregate) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *Aggregate) contextValidateBlockStorage(ctx context.Context, formats strfmt.Registry) error {

	if m.BlockStorage != nil {
		if err := m.BlockStorage.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block_storage")
			}
			return err
		}
	}

	return nil
}

func (m *Aggregate) contextValidateCloudStorage(ctx context.Context, formats strfmt.Registry) error {

	if m.CloudStorage != nil {
		if err := m.CloudStorage.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cloud_storage")
			}
			return err
		}
	}

	return nil
}

func (m *Aggregate) contextValidateCreateTime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "create_time", "body", string(m.CreateTime)); err != nil {
		return err
	}

	return nil
}

func (m *Aggregate) contextValidateDataEncryption(ctx context.Context, formats strfmt.Registry) error {

	if m.DataEncryption != nil {
		if err := m.DataEncryption.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("data_encryption")
			}
			return err
		}
	}

	return nil
}

func (m *Aggregate) contextValidateDrHomeNode(ctx context.Context, formats strfmt.Registry) error {

	if m.DrHomeNode != nil {
		if err := m.DrHomeNode.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dr_home_node")
			}
			return err
		}
	}

	return nil
}

func (m *Aggregate) contextValidateHomeNode(ctx context.Context, formats strfmt.Registry) error {

	if m.HomeNode != nil {
		if err := m.HomeNode.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("home_node")
			}
			return err
		}
	}

	return nil
}

func (m *Aggregate) contextValidateInactiveDataReporting(ctx context.Context, formats strfmt.Registry) error {

	if m.InactiveDataReporting != nil {
		if err := m.InactiveDataReporting.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("inactive_data_reporting")
			}
			return err
		}
	}

	return nil
}

func (m *Aggregate) contextValidateMetric(ctx context.Context, formats strfmt.Registry) error {

	if m.Metric != nil {
		if err := m.Metric.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric")
			}
			return err
		}
	}

	return nil
}

func (m *Aggregate) contextValidateNode(ctx context.Context, formats strfmt.Registry) error {

	if m.Node != nil {
		if err := m.Node.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node")
			}
			return err
		}
	}

	return nil
}

func (m *Aggregate) contextValidateRecommendationSpares(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.RecommendationSpares); i++ {

		if m.RecommendationSpares[i] != nil {
			if err := m.RecommendationSpares[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("recommendation_spares" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Aggregate) contextValidateSnapshot(ctx context.Context, formats strfmt.Registry) error {

	if m.Snapshot != nil {
		if err := m.Snapshot.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshot")
			}
			return err
		}
	}

	return nil
}

func (m *Aggregate) contextValidateSpace(ctx context.Context, formats strfmt.Registry) error {

	if m.Space != nil {
		if err := m.Space.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space")
			}
			return err
		}
	}

	return nil
}

func (m *Aggregate) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

func (m *Aggregate) contextValidateStatistics(ctx context.Context, formats strfmt.Registry) error {

	if m.Statistics != nil {
		if err := m.Statistics.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics")
			}
			return err
		}
	}

	return nil
}

func (m *Aggregate) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Aggregate) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Aggregate) UnmarshalBinary(b []byte) error {
	var res Aggregate
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AggregateBlockStorage Configuration information for the locally attached portion of the aggregate. When a cloud store is also used by this aggregate, this is referred to as the performance tier.
//
// swagger:model AggregateBlockStorage
type AggregateBlockStorage struct {

	// hybrid cache
	HybridCache *AggregateBlockStorageHybridCache `json:"hybrid_cache,omitempty"`

	// mirror
	Mirror *AggregateBlockStorageMirror `json:"mirror,omitempty"`

	// Plex reference for each plex in the aggregate.
	// Read Only: true
	Plexes []*PlexReference `json:"plexes,omitempty"`

	// primary
	Primary *AggregateBlockStoragePrimary `json:"primary,omitempty"`
}

// Validate validates this aggregate block storage
func (m *AggregateBlockStorage) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateHybridCache(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMirror(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlexes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrimary(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AggregateBlockStorage) validateHybridCache(formats strfmt.Registry) error {
	if swag.IsZero(m.HybridCache) { // not required
		return nil
	}

	if m.HybridCache != nil {
		if err := m.HybridCache.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block_storage" + "." + "hybrid_cache")
			}
			return err
		}
	}

	return nil
}

func (m *AggregateBlockStorage) validateMirror(formats strfmt.Registry) error {
	if swag.IsZero(m.Mirror) { // not required
		return nil
	}

	if m.Mirror != nil {
		if err := m.Mirror.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block_storage" + "." + "mirror")
			}
			return err
		}
	}

	return nil
}

func (m *AggregateBlockStorage) validatePlexes(formats strfmt.Registry) error {
	if swag.IsZero(m.Plexes) { // not required
		return nil
	}

	for i := 0; i < len(m.Plexes); i++ {
		if swag.IsZero(m.Plexes[i]) { // not required
			continue
		}

		if m.Plexes[i] != nil {
			if err := m.Plexes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("block_storage" + "." + "plexes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *AggregateBlockStorage) validatePrimary(formats strfmt.Registry) error {
	if swag.IsZero(m.Primary) { // not required
		return nil
	}

	if m.Primary != nil {
		if err := m.Primary.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block_storage" + "." + "primary")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this aggregate block storage based on the context it is used
func (m *AggregateBlockStorage) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateHybridCache(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMirror(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePlexes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePrimary(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AggregateBlockStorage) contextValidateHybridCache(ctx context.Context, formats strfmt.Registry) error {

	if m.HybridCache != nil {
		if err := m.HybridCache.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block_storage" + "." + "hybrid_cache")
			}
			return err
		}
	}

	return nil
}

func (m *AggregateBlockStorage) contextValidateMirror(ctx context.Context, formats strfmt.Registry) error {

	if m.Mirror != nil {
		if err := m.Mirror.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block_storage" + "." + "mirror")
			}
			return err
		}
	}

	return nil
}

func (m *AggregateBlockStorage) contextValidatePlexes(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "block_storage"+"."+"plexes", "body", []*PlexReference(m.Plexes)); err != nil {
		return err
	}

	for i := 0; i < len(m.Plexes); i++ {

		if m.Plexes[i] != nil {
			if err := m.Plexes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("block_storage" + "." + "plexes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *AggregateBlockStorage) contextValidatePrimary(ctx context.Context, formats strfmt.Registry) error {

	if m.Primary != nil {
		if err := m.Primary.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block_storage" + "." + "primary")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AggregateBlockStorage) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AggregateBlockStorage) UnmarshalBinary(b []byte) error {
	var res AggregateBlockStorage
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AggregateBlockStorageHybridCache Contains the configuration for the hybrid cache. The hybrid cache is made up of either whole SSDs or storage pool SSDs.
//
// swagger:model AggregateBlockStorageHybridCache
type AggregateBlockStorageHybridCache struct {

	// Number of disks used in the cache tier of the aggregate. Only provided when hybrid_cache.enabled is 'true'.
	// Example: 6
	// Read Only: true
	DiskCount int64 `json:"disk_count,omitempty"`

	// Specifies whether the aggregate uses HDDs with SSDs as a cache.
	// Read Only: true
	Enabled *bool `json:"enabled,omitempty"`

	// RAID type for SSD cache of the aggregate. Only provided when hybrid_cache.enabled is 'true'.
	// Read Only: true
	// Enum: [raid_dp raid_tec raid4]
	RaidType string `json:"raid_type,omitempty"`

	// Total usable space in bytes of SSD cache. Only provided when hybrid_cache.enabled is 'true'.
	// Example: 1612709888
	// Read Only: true
	Size int64 `json:"size,omitempty"`

	// Space used in bytes of SSD cache. Only provided when hybrid_cache.enabled is 'true'.
	// Example: 26501122
	// Read Only: true
	Used int64 `json:"used,omitempty"`
}

// Validate validates this aggregate block storage hybrid cache
func (m *AggregateBlockStorageHybridCache) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateRaidType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var aggregateBlockStorageHybridCacheTypeRaidTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["raid_dp","raid_tec","raid4"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		aggregateBlockStorageHybridCacheTypeRaidTypePropEnum = append(aggregateBlockStorageHybridCacheTypeRaidTypePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// AggregateBlockStorageHybridCache
	// AggregateBlockStorageHybridCache
	// raid_type
	// RaidType
	// raid_dp
	// END DEBUGGING
	// AggregateBlockStorageHybridCacheRaidTypeRaidDp captures enum value "raid_dp"
	AggregateBlockStorageHybridCacheRaidTypeRaidDp string = "raid_dp"

	// BEGIN DEBUGGING
	// AggregateBlockStorageHybridCache
	// AggregateBlockStorageHybridCache
	// raid_type
	// RaidType
	// raid_tec
	// END DEBUGGING
	// AggregateBlockStorageHybridCacheRaidTypeRaidTec captures enum value "raid_tec"
	AggregateBlockStorageHybridCacheRaidTypeRaidTec string = "raid_tec"

	// BEGIN DEBUGGING
	// AggregateBlockStorageHybridCache
	// AggregateBlockStorageHybridCache
	// raid_type
	// RaidType
	// raid4
	// END DEBUGGING
	// AggregateBlockStorageHybridCacheRaidTypeRaid4 captures enum value "raid4"
	AggregateBlockStorageHybridCacheRaidTypeRaid4 string = "raid4"
)

// prop value enum
func (m *AggregateBlockStorageHybridCache) validateRaidTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, aggregateBlockStorageHybridCacheTypeRaidTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AggregateBlockStorageHybridCache) validateRaidType(formats strfmt.Registry) error {
	if swag.IsZero(m.RaidType) { // not required
		return nil
	}

	// value enum
	if err := m.validateRaidTypeEnum("block_storage"+"."+"hybrid_cache"+"."+"raid_type", "body", m.RaidType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this aggregate block storage hybrid cache based on the context it is used
func (m *AggregateBlockStorageHybridCache) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDiskCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEnabled(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRaidType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSize(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AggregateBlockStorageHybridCache) contextValidateDiskCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "block_storage"+"."+"hybrid_cache"+"."+"disk_count", "body", int64(m.DiskCount)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateBlockStorageHybridCache) contextValidateEnabled(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "block_storage"+"."+"hybrid_cache"+"."+"enabled", "body", m.Enabled); err != nil {
		return err
	}

	return nil
}

func (m *AggregateBlockStorageHybridCache) contextValidateRaidType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "block_storage"+"."+"hybrid_cache"+"."+"raid_type", "body", string(m.RaidType)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateBlockStorageHybridCache) contextValidateSize(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "block_storage"+"."+"hybrid_cache"+"."+"size", "body", int64(m.Size)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateBlockStorageHybridCache) contextValidateUsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "block_storage"+"."+"hybrid_cache"+"."+"used", "body", int64(m.Used)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AggregateBlockStorageHybridCache) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AggregateBlockStorageHybridCache) UnmarshalBinary(b []byte) error {
	var res AggregateBlockStorageHybridCache
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AggregateBlockStorageMirror aggregate block storage mirror
//
// swagger:model AggregateBlockStorageMirror
type AggregateBlockStorageMirror struct {

	// Aggregate is SyncMirror protected
	// Example: false
	Enabled bool `json:"enabled,omitempty"`

	// state
	// Read Only: true
	// Enum: [unmirrored normal degraded resynchronizing failed]
	State string `json:"state,omitempty"`
}

// Validate validates this aggregate block storage mirror
func (m *AggregateBlockStorageMirror) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var aggregateBlockStorageMirrorTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["unmirrored","normal","degraded","resynchronizing","failed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		aggregateBlockStorageMirrorTypeStatePropEnum = append(aggregateBlockStorageMirrorTypeStatePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// AggregateBlockStorageMirror
	// AggregateBlockStorageMirror
	// state
	// State
	// unmirrored
	// END DEBUGGING
	// AggregateBlockStorageMirrorStateUnmirrored captures enum value "unmirrored"
	AggregateBlockStorageMirrorStateUnmirrored string = "unmirrored"

	// BEGIN DEBUGGING
	// AggregateBlockStorageMirror
	// AggregateBlockStorageMirror
	// state
	// State
	// normal
	// END DEBUGGING
	// AggregateBlockStorageMirrorStateNormal captures enum value "normal"
	AggregateBlockStorageMirrorStateNormal string = "normal"

	// BEGIN DEBUGGING
	// AggregateBlockStorageMirror
	// AggregateBlockStorageMirror
	// state
	// State
	// degraded
	// END DEBUGGING
	// AggregateBlockStorageMirrorStateDegraded captures enum value "degraded"
	AggregateBlockStorageMirrorStateDegraded string = "degraded"

	// BEGIN DEBUGGING
	// AggregateBlockStorageMirror
	// AggregateBlockStorageMirror
	// state
	// State
	// resynchronizing
	// END DEBUGGING
	// AggregateBlockStorageMirrorStateResynchronizing captures enum value "resynchronizing"
	AggregateBlockStorageMirrorStateResynchronizing string = "resynchronizing"

	// BEGIN DEBUGGING
	// AggregateBlockStorageMirror
	// AggregateBlockStorageMirror
	// state
	// State
	// failed
	// END DEBUGGING
	// AggregateBlockStorageMirrorStateFailed captures enum value "failed"
	AggregateBlockStorageMirrorStateFailed string = "failed"
)

// prop value enum
func (m *AggregateBlockStorageMirror) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, aggregateBlockStorageMirrorTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AggregateBlockStorageMirror) validateState(formats strfmt.Registry) error {
	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("block_storage"+"."+"mirror"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this aggregate block storage mirror based on the context it is used
func (m *AggregateBlockStorageMirror) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AggregateBlockStorageMirror) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "block_storage"+"."+"mirror"+"."+"state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AggregateBlockStorageMirror) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AggregateBlockStorageMirror) UnmarshalBinary(b []byte) error {
	var res AggregateBlockStorageMirror
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AggregateBlockStoragePrimary Configuration information for the primary storage portion of the aggregate. This excludes the hybrid cache details.
//
// swagger:model AggregateBlockStoragePrimary
type AggregateBlockStoragePrimary struct {

	// The checksum style used by the aggregate.
	// Enum: [block advanced_zoned mixed]
	ChecksumStyle string `json:"checksum_style,omitempty"`

	// The class of disks being used by the aggregate.
	// Example: performance
	// Enum: [capacity performance archive solid_state array virtual data_center capacity_flash]
	DiskClass string `json:"disk_class,omitempty"`

	// Number of disks used in the aggregate. This includes parity disks, but excludes disks in the hybrid cache.
	// Example: 8
	DiskCount int64 `json:"disk_count,omitempty"`

	// The type of disk being used by the aggregate.
	// Read Only: true
	// Enum: [fc lun nl_sas nvme_ssd sas sata scsi ssd ssd_cap ssd_zns vm_disk]
	DiskType string `json:"disk_type,omitempty"`

	// Option to specify the maximum number of disks that can be included in a RAID group.
	// Example: 16
	RaidSize int64 `json:"raid_size,omitempty"`

	// RAID type of the aggregate.
	// Enum: [raid_dp raid_tec raid0 raid4 raid_ep]
	RaidType string `json:"raid_type,omitempty"`

	// simulated raid groups
	SimulatedRaidGroups []*AggregateBlockStoragePrimarySimulatedRaidGroupsItems0 `json:"simulated_raid_groups,omitempty"`
}

// Validate validates this aggregate block storage primary
func (m *AggregateBlockStoragePrimary) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateChecksumStyle(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDiskClass(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDiskType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRaidType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSimulatedRaidGroups(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var aggregateBlockStoragePrimaryTypeChecksumStylePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["block","advanced_zoned","mixed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		aggregateBlockStoragePrimaryTypeChecksumStylePropEnum = append(aggregateBlockStoragePrimaryTypeChecksumStylePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// AggregateBlockStoragePrimary
	// AggregateBlockStoragePrimary
	// checksum_style
	// ChecksumStyle
	// block
	// END DEBUGGING
	// AggregateBlockStoragePrimaryChecksumStyleBlock captures enum value "block"
	AggregateBlockStoragePrimaryChecksumStyleBlock string = "block"

	// BEGIN DEBUGGING
	// AggregateBlockStoragePrimary
	// AggregateBlockStoragePrimary
	// checksum_style
	// ChecksumStyle
	// advanced_zoned
	// END DEBUGGING
	// AggregateBlockStoragePrimaryChecksumStyleAdvancedZoned captures enum value "advanced_zoned"
	AggregateBlockStoragePrimaryChecksumStyleAdvancedZoned string = "advanced_zoned"

	// BEGIN DEBUGGING
	// AggregateBlockStoragePrimary
	// AggregateBlockStoragePrimary
	// checksum_style
	// ChecksumStyle
	// mixed
	// END DEBUGGING
	// AggregateBlockStoragePrimaryChecksumStyleMixed captures enum value "mixed"
	AggregateBlockStoragePrimaryChecksumStyleMixed string = "mixed"
)

// prop value enum
func (m *AggregateBlockStoragePrimary) validateChecksumStyleEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, aggregateBlockStoragePrimaryTypeChecksumStylePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AggregateBlockStoragePrimary) validateChecksumStyle(formats strfmt.Registry) error {
	if swag.IsZero(m.ChecksumStyle) { // not required
		return nil
	}

	// value enum
	if err := m.validateChecksumStyleEnum("block_storage"+"."+"primary"+"."+"checksum_style", "body", m.ChecksumStyle); err != nil {
		return err
	}

	return nil
}

var aggregateBlockStoragePrimaryTypeDiskClassPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["capacity","performance","archive","solid_state","array","virtual","data_center","capacity_flash"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		aggregateBlockStoragePrimaryTypeDiskClassPropEnum = append(aggregateBlockStoragePrimaryTypeDiskClassPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// AggregateBlockStoragePrimary
	// AggregateBlockStoragePrimary
	// disk_class
	// DiskClass
	// capacity
	// END DEBUGGING
	// AggregateBlockStoragePrimaryDiskClassCapacity captures enum value "capacity"
	AggregateBlockStoragePrimaryDiskClassCapacity string = "capacity"

	// BEGIN DEBUGGING
	// AggregateBlockStoragePrimary
	// AggregateBlockStoragePrimary
	// disk_class
	// DiskClass
	// performance
	// END DEBUGGING
	// AggregateBlockStoragePrimaryDiskClassPerformance captures enum value "performance"
	AggregateBlockStoragePrimaryDiskClassPerformance string = "performance"

	// BEGIN DEBUGGING
	// AggregateBlockStoragePrimary
	// AggregateBlockStoragePrimary
	// disk_class
	// DiskClass
	// archive
	// END DEBUGGING
	// AggregateBlockStoragePrimaryDiskClassArchive captures enum value "archive"
	AggregateBlockStoragePrimaryDiskClassArchive string = "archive"

	// BEGIN DEBUGGING
	// AggregateBlockStoragePrimary
	// AggregateBlockStoragePrimary
	// disk_class
	// DiskClass
	// solid_state
	// END DEBUGGING
	// AggregateBlockStoragePrimaryDiskClassSolidState captures enum value "solid_state"
	AggregateBlockStoragePrimaryDiskClassSolidState string = "solid_state"

	// BEGIN DEBUGGING
	// AggregateBlockStoragePrimary
	// AggregateBlockStoragePrimary
	// disk_class
	// DiskClass
	// array
	// END DEBUGGING
	// AggregateBlockStoragePrimaryDiskClassArray captures enum value "array"
	AggregateBlockStoragePrimaryDiskClassArray string = "array"

	// BEGIN DEBUGGING
	// AggregateBlockStoragePrimary
	// AggregateBlockStoragePrimary
	// disk_class
	// DiskClass
	// virtual
	// END DEBUGGING
	// AggregateBlockStoragePrimaryDiskClassVirtual captures enum value "virtual"
	AggregateBlockStoragePrimaryDiskClassVirtual string = "virtual"

	// BEGIN DEBUGGING
	// AggregateBlockStoragePrimary
	// AggregateBlockStoragePrimary
	// disk_class
	// DiskClass
	// data_center
	// END DEBUGGING
	// AggregateBlockStoragePrimaryDiskClassDataCenter captures enum value "data_center"
	AggregateBlockStoragePrimaryDiskClassDataCenter string = "data_center"

	// BEGIN DEBUGGING
	// AggregateBlockStoragePrimary
	// AggregateBlockStoragePrimary
	// disk_class
	// DiskClass
	// capacity_flash
	// END DEBUGGING
	// AggregateBlockStoragePrimaryDiskClassCapacityFlash captures enum value "capacity_flash"
	AggregateBlockStoragePrimaryDiskClassCapacityFlash string = "capacity_flash"
)

// prop value enum
func (m *AggregateBlockStoragePrimary) validateDiskClassEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, aggregateBlockStoragePrimaryTypeDiskClassPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AggregateBlockStoragePrimary) validateDiskClass(formats strfmt.Registry) error {
	if swag.IsZero(m.DiskClass) { // not required
		return nil
	}

	// value enum
	if err := m.validateDiskClassEnum("block_storage"+"."+"primary"+"."+"disk_class", "body", m.DiskClass); err != nil {
		return err
	}

	return nil
}

var aggregateBlockStoragePrimaryTypeDiskTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["fc","lun","nl_sas","nvme_ssd","sas","sata","scsi","ssd","ssd_cap","ssd_zns","vm_disk"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		aggregateBlockStoragePrimaryTypeDiskTypePropEnum = append(aggregateBlockStoragePrimaryTypeDiskTypePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// AggregateBlockStoragePrimary
	// AggregateBlockStoragePrimary
	// disk_type
	// DiskType
	// fc
	// END DEBUGGING
	// AggregateBlockStoragePrimaryDiskTypeFc captures enum value "fc"
	AggregateBlockStoragePrimaryDiskTypeFc string = "fc"

	// BEGIN DEBUGGING
	// AggregateBlockStoragePrimary
	// AggregateBlockStoragePrimary
	// disk_type
	// DiskType
	// lun
	// END DEBUGGING
	// AggregateBlockStoragePrimaryDiskTypeLun captures enum value "lun"
	AggregateBlockStoragePrimaryDiskTypeLun string = "lun"

	// BEGIN DEBUGGING
	// AggregateBlockStoragePrimary
	// AggregateBlockStoragePrimary
	// disk_type
	// DiskType
	// nl_sas
	// END DEBUGGING
	// AggregateBlockStoragePrimaryDiskTypeNlSas captures enum value "nl_sas"
	AggregateBlockStoragePrimaryDiskTypeNlSas string = "nl_sas"

	// BEGIN DEBUGGING
	// AggregateBlockStoragePrimary
	// AggregateBlockStoragePrimary
	// disk_type
	// DiskType
	// nvme_ssd
	// END DEBUGGING
	// AggregateBlockStoragePrimaryDiskTypeNvmeSsd captures enum value "nvme_ssd"
	AggregateBlockStoragePrimaryDiskTypeNvmeSsd string = "nvme_ssd"

	// BEGIN DEBUGGING
	// AggregateBlockStoragePrimary
	// AggregateBlockStoragePrimary
	// disk_type
	// DiskType
	// sas
	// END DEBUGGING
	// AggregateBlockStoragePrimaryDiskTypeSas captures enum value "sas"
	AggregateBlockStoragePrimaryDiskTypeSas string = "sas"

	// BEGIN DEBUGGING
	// AggregateBlockStoragePrimary
	// AggregateBlockStoragePrimary
	// disk_type
	// DiskType
	// sata
	// END DEBUGGING
	// AggregateBlockStoragePrimaryDiskTypeSata captures enum value "sata"
	AggregateBlockStoragePrimaryDiskTypeSata string = "sata"

	// BEGIN DEBUGGING
	// AggregateBlockStoragePrimary
	// AggregateBlockStoragePrimary
	// disk_type
	// DiskType
	// scsi
	// END DEBUGGING
	// AggregateBlockStoragePrimaryDiskTypeScsi captures enum value "scsi"
	AggregateBlockStoragePrimaryDiskTypeScsi string = "scsi"

	// BEGIN DEBUGGING
	// AggregateBlockStoragePrimary
	// AggregateBlockStoragePrimary
	// disk_type
	// DiskType
	// ssd
	// END DEBUGGING
	// AggregateBlockStoragePrimaryDiskTypeSsd captures enum value "ssd"
	AggregateBlockStoragePrimaryDiskTypeSsd string = "ssd"

	// BEGIN DEBUGGING
	// AggregateBlockStoragePrimary
	// AggregateBlockStoragePrimary
	// disk_type
	// DiskType
	// ssd_cap
	// END DEBUGGING
	// AggregateBlockStoragePrimaryDiskTypeSsdCap captures enum value "ssd_cap"
	AggregateBlockStoragePrimaryDiskTypeSsdCap string = "ssd_cap"

	// BEGIN DEBUGGING
	// AggregateBlockStoragePrimary
	// AggregateBlockStoragePrimary
	// disk_type
	// DiskType
	// ssd_zns
	// END DEBUGGING
	// AggregateBlockStoragePrimaryDiskTypeSsdZns captures enum value "ssd_zns"
	AggregateBlockStoragePrimaryDiskTypeSsdZns string = "ssd_zns"

	// BEGIN DEBUGGING
	// AggregateBlockStoragePrimary
	// AggregateBlockStoragePrimary
	// disk_type
	// DiskType
	// vm_disk
	// END DEBUGGING
	// AggregateBlockStoragePrimaryDiskTypeVMDisk captures enum value "vm_disk"
	AggregateBlockStoragePrimaryDiskTypeVMDisk string = "vm_disk"
)

// prop value enum
func (m *AggregateBlockStoragePrimary) validateDiskTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, aggregateBlockStoragePrimaryTypeDiskTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AggregateBlockStoragePrimary) validateDiskType(formats strfmt.Registry) error {
	if swag.IsZero(m.DiskType) { // not required
		return nil
	}

	// value enum
	if err := m.validateDiskTypeEnum("block_storage"+"."+"primary"+"."+"disk_type", "body", m.DiskType); err != nil {
		return err
	}

	return nil
}

var aggregateBlockStoragePrimaryTypeRaidTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["raid_dp","raid_tec","raid0","raid4","raid_ep"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		aggregateBlockStoragePrimaryTypeRaidTypePropEnum = append(aggregateBlockStoragePrimaryTypeRaidTypePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// AggregateBlockStoragePrimary
	// AggregateBlockStoragePrimary
	// raid_type
	// RaidType
	// raid_dp
	// END DEBUGGING
	// AggregateBlockStoragePrimaryRaidTypeRaidDp captures enum value "raid_dp"
	AggregateBlockStoragePrimaryRaidTypeRaidDp string = "raid_dp"

	// BEGIN DEBUGGING
	// AggregateBlockStoragePrimary
	// AggregateBlockStoragePrimary
	// raid_type
	// RaidType
	// raid_tec
	// END DEBUGGING
	// AggregateBlockStoragePrimaryRaidTypeRaidTec captures enum value "raid_tec"
	AggregateBlockStoragePrimaryRaidTypeRaidTec string = "raid_tec"

	// BEGIN DEBUGGING
	// AggregateBlockStoragePrimary
	// AggregateBlockStoragePrimary
	// raid_type
	// RaidType
	// raid0
	// END DEBUGGING
	// AggregateBlockStoragePrimaryRaidTypeRaid0 captures enum value "raid0"
	AggregateBlockStoragePrimaryRaidTypeRaid0 string = "raid0"

	// BEGIN DEBUGGING
	// AggregateBlockStoragePrimary
	// AggregateBlockStoragePrimary
	// raid_type
	// RaidType
	// raid4
	// END DEBUGGING
	// AggregateBlockStoragePrimaryRaidTypeRaid4 captures enum value "raid4"
	AggregateBlockStoragePrimaryRaidTypeRaid4 string = "raid4"

	// BEGIN DEBUGGING
	// AggregateBlockStoragePrimary
	// AggregateBlockStoragePrimary
	// raid_type
	// RaidType
	// raid_ep
	// END DEBUGGING
	// AggregateBlockStoragePrimaryRaidTypeRaidEp captures enum value "raid_ep"
	AggregateBlockStoragePrimaryRaidTypeRaidEp string = "raid_ep"
)

// prop value enum
func (m *AggregateBlockStoragePrimary) validateRaidTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, aggregateBlockStoragePrimaryTypeRaidTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AggregateBlockStoragePrimary) validateRaidType(formats strfmt.Registry) error {
	if swag.IsZero(m.RaidType) { // not required
		return nil
	}

	// value enum
	if err := m.validateRaidTypeEnum("block_storage"+"."+"primary"+"."+"raid_type", "body", m.RaidType); err != nil {
		return err
	}

	return nil
}

func (m *AggregateBlockStoragePrimary) validateSimulatedRaidGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.SimulatedRaidGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.SimulatedRaidGroups); i++ {
		if swag.IsZero(m.SimulatedRaidGroups[i]) { // not required
			continue
		}

		if m.SimulatedRaidGroups[i] != nil {
			if err := m.SimulatedRaidGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("block_storage" + "." + "primary" + "." + "simulated_raid_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this aggregate block storage primary based on the context it is used
func (m *AggregateBlockStoragePrimary) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDiskType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSimulatedRaidGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AggregateBlockStoragePrimary) contextValidateDiskType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "block_storage"+"."+"primary"+"."+"disk_type", "body", string(m.DiskType)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateBlockStoragePrimary) contextValidateSimulatedRaidGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.SimulatedRaidGroups); i++ {

		if m.SimulatedRaidGroups[i] != nil {
			if err := m.SimulatedRaidGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("block_storage" + "." + "primary" + "." + "simulated_raid_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *AggregateBlockStoragePrimary) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AggregateBlockStoragePrimary) UnmarshalBinary(b []byte) error {
	var res AggregateBlockStoragePrimary
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AggregateBlockStoragePrimarySimulatedRaidGroupsItems0 aggregate block storage primary simulated raid groups items0
//
// swagger:model AggregateBlockStoragePrimarySimulatedRaidGroupsItems0
type AggregateBlockStoragePrimarySimulatedRaidGroupsItems0 struct {

	// Number of data disks in RAID group.
	DataDiskCount int64 `json:"data_disk_count,omitempty"`

	// Indicates whether the disk is partitioned (true) or whole (false).
	IsPartition bool `json:"is_partition,omitempty"`

	// Name of the raid group.
	Name string `json:"name,omitempty"`

	// Number of parity disks in RAID group.
	ParityDiskCount int64 `json:"parity_disk_count,omitempty"`

	// RAID type of the aggregate.
	// Enum: [raid_dp raid_tec raid0 raid4 raid_ep]
	RaidType string `json:"raid_type,omitempty"`

	// Usable size of each disk, in bytes.
	UsableSize int64 `json:"usable_size,omitempty"`
}

// Validate validates this aggregate block storage primary simulated raid groups items0
func (m *AggregateBlockStoragePrimarySimulatedRaidGroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateRaidType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var aggregateBlockStoragePrimarySimulatedRaidGroupsItems0TypeRaidTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["raid_dp","raid_tec","raid0","raid4","raid_ep"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		aggregateBlockStoragePrimarySimulatedRaidGroupsItems0TypeRaidTypePropEnum = append(aggregateBlockStoragePrimarySimulatedRaidGroupsItems0TypeRaidTypePropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// AggregateBlockStoragePrimarySimulatedRaidGroupsItems0
	// AggregateBlockStoragePrimarySimulatedRaidGroupsItems0
	// raid_type
	// RaidType
	// raid_dp
	// END DEBUGGING
	// AggregateBlockStoragePrimarySimulatedRaidGroupsItems0RaidTypeRaidDp captures enum value "raid_dp"
	AggregateBlockStoragePrimarySimulatedRaidGroupsItems0RaidTypeRaidDp string = "raid_dp"

	// BEGIN DEBUGGING
	// AggregateBlockStoragePrimarySimulatedRaidGroupsItems0
	// AggregateBlockStoragePrimarySimulatedRaidGroupsItems0
	// raid_type
	// RaidType
	// raid_tec
	// END DEBUGGING
	// AggregateBlockStoragePrimarySimulatedRaidGroupsItems0RaidTypeRaidTec captures enum value "raid_tec"
	AggregateBlockStoragePrimarySimulatedRaidGroupsItems0RaidTypeRaidTec string = "raid_tec"

	// BEGIN DEBUGGING
	// AggregateBlockStoragePrimarySimulatedRaidGroupsItems0
	// AggregateBlockStoragePrimarySimulatedRaidGroupsItems0
	// raid_type
	// RaidType
	// raid0
	// END DEBUGGING
	// AggregateBlockStoragePrimarySimulatedRaidGroupsItems0RaidTypeRaid0 captures enum value "raid0"
	AggregateBlockStoragePrimarySimulatedRaidGroupsItems0RaidTypeRaid0 string = "raid0"

	// BEGIN DEBUGGING
	// AggregateBlockStoragePrimarySimulatedRaidGroupsItems0
	// AggregateBlockStoragePrimarySimulatedRaidGroupsItems0
	// raid_type
	// RaidType
	// raid4
	// END DEBUGGING
	// AggregateBlockStoragePrimarySimulatedRaidGroupsItems0RaidTypeRaid4 captures enum value "raid4"
	AggregateBlockStoragePrimarySimulatedRaidGroupsItems0RaidTypeRaid4 string = "raid4"

	// BEGIN DEBUGGING
	// AggregateBlockStoragePrimarySimulatedRaidGroupsItems0
	// AggregateBlockStoragePrimarySimulatedRaidGroupsItems0
	// raid_type
	// RaidType
	// raid_ep
	// END DEBUGGING
	// AggregateBlockStoragePrimarySimulatedRaidGroupsItems0RaidTypeRaidEp captures enum value "raid_ep"
	AggregateBlockStoragePrimarySimulatedRaidGroupsItems0RaidTypeRaidEp string = "raid_ep"
)

// prop value enum
func (m *AggregateBlockStoragePrimarySimulatedRaidGroupsItems0) validateRaidTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, aggregateBlockStoragePrimarySimulatedRaidGroupsItems0TypeRaidTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AggregateBlockStoragePrimarySimulatedRaidGroupsItems0) validateRaidType(formats strfmt.Registry) error {
	if swag.IsZero(m.RaidType) { // not required
		return nil
	}

	// value enum
	if err := m.validateRaidTypeEnum("raid_type", "body", m.RaidType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this aggregate block storage primary simulated raid groups items0 based on context it is used
func (m *AggregateBlockStoragePrimarySimulatedRaidGroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *AggregateBlockStoragePrimarySimulatedRaidGroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AggregateBlockStoragePrimarySimulatedRaidGroupsItems0) UnmarshalBinary(b []byte) error {
	var res AggregateBlockStoragePrimarySimulatedRaidGroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AggregateCloudStorage Configuration information for the cloud storage portion of the aggregate. This is referred to as the capacity tier.
//
// swagger:model AggregateCloudStorage
type AggregateCloudStorage struct {

	// Specifies whether the aggregate is eligible for a cloud store to be attached.
	// Read Only: true
	AttachEligible *bool `json:"attach_eligible,omitempty"`

	// Configuration information for each cloud storage portion of the aggregate.
	// Read Only: true
	Stores []*CloudStorageTier `json:"stores,omitempty"`

	// The percentage of space in the performance tier that must be used before data is tiered out to the cloud store. Only valid for PATCH operations.
	TieringFullnessThreshold int64 `json:"tiering_fullness_threshold,omitempty"`
}

// Validate validates this aggregate cloud storage
func (m *AggregateCloudStorage) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateStores(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AggregateCloudStorage) validateStores(formats strfmt.Registry) error {
	if swag.IsZero(m.Stores) { // not required
		return nil
	}

	for i := 0; i < len(m.Stores); i++ {
		if swag.IsZero(m.Stores[i]) { // not required
			continue
		}

		if m.Stores[i] != nil {
			if err := m.Stores[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cloud_storage" + "." + "stores" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this aggregate cloud storage based on the context it is used
func (m *AggregateCloudStorage) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAttachEligible(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStores(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AggregateCloudStorage) contextValidateAttachEligible(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "cloud_storage"+"."+"attach_eligible", "body", m.AttachEligible); err != nil {
		return err
	}

	return nil
}

func (m *AggregateCloudStorage) contextValidateStores(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "cloud_storage"+"."+"stores", "body", []*CloudStorageTier(m.Stores)); err != nil {
		return err
	}

	for i := 0; i < len(m.Stores); i++ {

		if m.Stores[i] != nil {
			if err := m.Stores[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cloud_storage" + "." + "stores" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *AggregateCloudStorage) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AggregateCloudStorage) UnmarshalBinary(b []byte) error {
	var res AggregateCloudStorage
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AggregateDataEncryption aggregate data encryption
//
// swagger:model AggregateDataEncryption
type AggregateDataEncryption struct {

	// Specifies whether the aggregate uses self-encrypting drives with data protection enabled.
	// Read Only: true
	DriveProtectionEnabled *bool `json:"drive_protection_enabled,omitempty"`

	// Specifies whether NetApp aggregate encryption is enabled. All data in the aggregate is encrypted.
	SoftwareEncryptionEnabled bool `json:"software_encryption_enabled,omitempty"`
}

// Validate validates this aggregate data encryption
func (m *AggregateDataEncryption) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this aggregate data encryption based on the context it is used
func (m *AggregateDataEncryption) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDriveProtectionEnabled(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AggregateDataEncryption) contextValidateDriveProtectionEnabled(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "data_encryption"+"."+"drive_protection_enabled", "body", m.DriveProtectionEnabled); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AggregateDataEncryption) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AggregateDataEncryption) UnmarshalBinary(b []byte) error {
	var res AggregateDataEncryption
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AggregateDrHomeNode Node where the aggregate resides after disaster recovery. The value for this field might differ from the 'node' field during switchover.
//
// swagger:model AggregateDrHomeNode
type AggregateDrHomeNode struct {

	// name
	// Example: node1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this aggregate dr home node
func (m *AggregateDrHomeNode) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this aggregate dr home node based on the context it is used
func (m *AggregateDrHomeNode) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *AggregateDrHomeNode) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AggregateDrHomeNode) UnmarshalBinary(b []byte) error {
	var res AggregateDrHomeNode
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AggregateHomeNode Node where the aggregate resides after giveback. The value for this field might differ from the value of the 'node' field during takeover.
//
// swagger:model AggregateHomeNode
type AggregateHomeNode struct {

	// links
	Links *AggregateHomeNodeLinks `json:"_links,omitempty"`

	// name
	// Example: node1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this aggregate home node
func (m *AggregateHomeNode) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AggregateHomeNode) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("home_node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this aggregate home node based on the context it is used
func (m *AggregateHomeNode) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AggregateHomeNode) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("home_node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AggregateHomeNode) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AggregateHomeNode) UnmarshalBinary(b []byte) error {
	var res AggregateHomeNode
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AggregateHomeNodeLinks aggregate home node links
//
// swagger:model AggregateHomeNodeLinks
type AggregateHomeNodeLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this aggregate home node links
func (m *AggregateHomeNodeLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AggregateHomeNodeLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("home_node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this aggregate home node links based on the context it is used
func (m *AggregateHomeNodeLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AggregateHomeNodeLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("home_node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AggregateHomeNodeLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AggregateHomeNodeLinks) UnmarshalBinary(b []byte) error {
	var res AggregateHomeNodeLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AggregateInactiveDataReporting aggregate inactive data reporting
//
// swagger:model AggregateInactiveDataReporting
type AggregateInactiveDataReporting struct {

	// Specifes whether or not inactive data reporting is enabled on the aggregate.
	Enabled bool `json:"enabled,omitempty"`

	// Timestamp at which inactive data reporting was enabled on the aggregate.
	// Example: 2019-12-12T12:00:00-04:00
	// Read Only: true
	// Format: date-time
	StartTime *strfmt.DateTime `json:"start_time,omitempty"`
}

// Validate validates this aggregate inactive data reporting
func (m *AggregateInactiveDataReporting) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateStartTime(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AggregateInactiveDataReporting) validateStartTime(formats strfmt.Registry) error {
	if swag.IsZero(m.StartTime) { // not required
		return nil
	}

	if err := validate.FormatOf("inactive_data_reporting"+"."+"start_time", "body", "date-time", m.StartTime.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this aggregate inactive data reporting based on the context it is used
func (m *AggregateInactiveDataReporting) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateStartTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AggregateInactiveDataReporting) contextValidateStartTime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "inactive_data_reporting"+"."+"start_time", "body", m.StartTime); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AggregateInactiveDataReporting) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AggregateInactiveDataReporting) UnmarshalBinary(b []byte) error {
	var res AggregateInactiveDataReporting
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AggregateLinks aggregate links
//
// swagger:model AggregateLinks
type AggregateLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this aggregate links
func (m *AggregateLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AggregateLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this aggregate links based on the context it is used
func (m *AggregateLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AggregateLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AggregateLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AggregateLinks) UnmarshalBinary(b []byte) error {
	var res AggregateLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AggregateMetric The most recent sample of I/O metrics for the aggregate.
//
// swagger:model AggregateMetric
type AggregateMetric struct {

	// links
	Links *AggregateMetricLinks `json:"_links,omitempty"`

	// The duration over which this sample is calculated. The time durations are represented in the ISO-8601 standard format. Samples can be calculated over the following durations:
	//
	// Example: PT15S
	// Read Only: true
	// Enum: [PT15S PT4M PT30M PT2H P1D PT5M]
	Duration string `json:"duration,omitempty"`

	// iops
	Iops *AggregateMetricIops `json:"iops,omitempty"`

	// latency
	Latency *AggregateMetricLatency `json:"latency,omitempty"`

	// Errors associated with the sample. For example, if the aggregation of data over multiple nodes fails, then any partial errors might return "ok" on success or "error" on an internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_ delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Read Only: true
	// Enum: [ok error partial_no_data partial_no_response partial_other_error negative_delta not_found backfilled_data inconsistent_delta_time inconsistent_old_data partial_no_uuid]
	Status string `json:"status,omitempty"`

	// throughput
	Throughput *AggregateMetricThroughput `json:"throughput,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25T11:20:13Z
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this aggregate metric
func (m *AggregateMetric) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDuration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIops(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThroughput(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AggregateMetric) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

var aggregateMetricTypeDurationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PT15S","PT4M","PT30M","PT2H","P1D","PT5M"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		aggregateMetricTypeDurationPropEnum = append(aggregateMetricTypeDurationPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// AggregateMetric
	// AggregateMetric
	// duration
	// Duration
	// PT15S
	// END DEBUGGING
	// AggregateMetricDurationPT15S captures enum value "PT15S"
	AggregateMetricDurationPT15S string = "PT15S"

	// BEGIN DEBUGGING
	// AggregateMetric
	// AggregateMetric
	// duration
	// Duration
	// PT4M
	// END DEBUGGING
	// AggregateMetricDurationPT4M captures enum value "PT4M"
	AggregateMetricDurationPT4M string = "PT4M"

	// BEGIN DEBUGGING
	// AggregateMetric
	// AggregateMetric
	// duration
	// Duration
	// PT30M
	// END DEBUGGING
	// AggregateMetricDurationPT30M captures enum value "PT30M"
	AggregateMetricDurationPT30M string = "PT30M"

	// BEGIN DEBUGGING
	// AggregateMetric
	// AggregateMetric
	// duration
	// Duration
	// PT2H
	// END DEBUGGING
	// AggregateMetricDurationPT2H captures enum value "PT2H"
	AggregateMetricDurationPT2H string = "PT2H"

	// BEGIN DEBUGGING
	// AggregateMetric
	// AggregateMetric
	// duration
	// Duration
	// P1D
	// END DEBUGGING
	// AggregateMetricDurationP1D captures enum value "P1D"
	AggregateMetricDurationP1D string = "P1D"

	// BEGIN DEBUGGING
	// AggregateMetric
	// AggregateMetric
	// duration
	// Duration
	// PT5M
	// END DEBUGGING
	// AggregateMetricDurationPT5M captures enum value "PT5M"
	AggregateMetricDurationPT5M string = "PT5M"
)

// prop value enum
func (m *AggregateMetric) validateDurationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, aggregateMetricTypeDurationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AggregateMetric) validateDuration(formats strfmt.Registry) error {
	if swag.IsZero(m.Duration) { // not required
		return nil
	}

	// value enum
	if err := m.validateDurationEnum("metric"+"."+"duration", "body", m.Duration); err != nil {
		return err
	}

	return nil
}

func (m *AggregateMetric) validateIops(formats strfmt.Registry) error {
	if swag.IsZero(m.Iops) { // not required
		return nil
	}

	if m.Iops != nil {
		if err := m.Iops.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "iops")
			}
			return err
		}
	}

	return nil
}

func (m *AggregateMetric) validateLatency(formats strfmt.Registry) error {
	if swag.IsZero(m.Latency) { // not required
		return nil
	}

	if m.Latency != nil {
		if err := m.Latency.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "latency")
			}
			return err
		}
	}

	return nil
}

var aggregateMetricTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_response","partial_other_error","negative_delta","not_found","backfilled_data","inconsistent_delta_time","inconsistent_old_data","partial_no_uuid"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		aggregateMetricTypeStatusPropEnum = append(aggregateMetricTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// AggregateMetric
	// AggregateMetric
	// status
	// Status
	// ok
	// END DEBUGGING
	// AggregateMetricStatusOk captures enum value "ok"
	AggregateMetricStatusOk string = "ok"

	// BEGIN DEBUGGING
	// AggregateMetric
	// AggregateMetric
	// status
	// Status
	// error
	// END DEBUGGING
	// AggregateMetricStatusError captures enum value "error"
	AggregateMetricStatusError string = "error"

	// BEGIN DEBUGGING
	// AggregateMetric
	// AggregateMetric
	// status
	// Status
	// partial_no_data
	// END DEBUGGING
	// AggregateMetricStatusPartialNoData captures enum value "partial_no_data"
	AggregateMetricStatusPartialNoData string = "partial_no_data"

	// BEGIN DEBUGGING
	// AggregateMetric
	// AggregateMetric
	// status
	// Status
	// partial_no_response
	// END DEBUGGING
	// AggregateMetricStatusPartialNoResponse captures enum value "partial_no_response"
	AggregateMetricStatusPartialNoResponse string = "partial_no_response"

	// BEGIN DEBUGGING
	// AggregateMetric
	// AggregateMetric
	// status
	// Status
	// partial_other_error
	// END DEBUGGING
	// AggregateMetricStatusPartialOtherError captures enum value "partial_other_error"
	AggregateMetricStatusPartialOtherError string = "partial_other_error"

	// BEGIN DEBUGGING
	// AggregateMetric
	// AggregateMetric
	// status
	// Status
	// negative_delta
	// END DEBUGGING
	// AggregateMetricStatusNegativeDelta captures enum value "negative_delta"
	AggregateMetricStatusNegativeDelta string = "negative_delta"

	// BEGIN DEBUGGING
	// AggregateMetric
	// AggregateMetric
	// status
	// Status
	// not_found
	// END DEBUGGING
	// AggregateMetricStatusNotFound captures enum value "not_found"
	AggregateMetricStatusNotFound string = "not_found"

	// BEGIN DEBUGGING
	// AggregateMetric
	// AggregateMetric
	// status
	// Status
	// backfilled_data
	// END DEBUGGING
	// AggregateMetricStatusBackfilledData captures enum value "backfilled_data"
	AggregateMetricStatusBackfilledData string = "backfilled_data"

	// BEGIN DEBUGGING
	// AggregateMetric
	// AggregateMetric
	// status
	// Status
	// inconsistent_delta_time
	// END DEBUGGING
	// AggregateMetricStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	AggregateMetricStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN DEBUGGING
	// AggregateMetric
	// AggregateMetric
	// status
	// Status
	// inconsistent_old_data
	// END DEBUGGING
	// AggregateMetricStatusInconsistentOldData captures enum value "inconsistent_old_data"
	AggregateMetricStatusInconsistentOldData string = "inconsistent_old_data"

	// BEGIN DEBUGGING
	// AggregateMetric
	// AggregateMetric
	// status
	// Status
	// partial_no_uuid
	// END DEBUGGING
	// AggregateMetricStatusPartialNoUUID captures enum value "partial_no_uuid"
	AggregateMetricStatusPartialNoUUID string = "partial_no_uuid"
)

// prop value enum
func (m *AggregateMetric) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, aggregateMetricTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AggregateMetric) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("metric"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *AggregateMetric) validateThroughput(formats strfmt.Registry) error {
	if swag.IsZero(m.Throughput) { // not required
		return nil
	}

	if m.Throughput != nil {
		if err := m.Throughput.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "throughput")
			}
			return err
		}
	}

	return nil
}

func (m *AggregateMetric) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("metric"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this aggregate metric based on the context it is used
func (m *AggregateMetric) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDuration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIops(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLatency(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThroughput(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AggregateMetric) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *AggregateMetric) contextValidateDuration(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metric"+"."+"duration", "body", string(m.Duration)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateMetric) contextValidateIops(ctx context.Context, formats strfmt.Registry) error {

	if m.Iops != nil {
		if err := m.Iops.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "iops")
			}
			return err
		}
	}

	return nil
}

func (m *AggregateMetric) contextValidateLatency(ctx context.Context, formats strfmt.Registry) error {

	if m.Latency != nil {
		if err := m.Latency.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "latency")
			}
			return err
		}
	}

	return nil
}

func (m *AggregateMetric) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metric"+"."+"status", "body", string(m.Status)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateMetric) contextValidateThroughput(ctx context.Context, formats strfmt.Registry) error {

	if m.Throughput != nil {
		if err := m.Throughput.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "throughput")
			}
			return err
		}
	}

	return nil
}

func (m *AggregateMetric) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metric"+"."+"timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AggregateMetric) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AggregateMetric) UnmarshalBinary(b []byte) error {
	var res AggregateMetric
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AggregateMetricIops The rate of I/O operations observed at the storage object.
//
// swagger:model AggregateMetricIops
type AggregateMetricIops struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this aggregate metric iops
func (m *AggregateMetricIops) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this aggregate metric iops based on the context it is used
func (m *AggregateMetricIops) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *AggregateMetricIops) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AggregateMetricIops) UnmarshalBinary(b []byte) error {
	var res AggregateMetricIops
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AggregateMetricLatency The round trip latency in microseconds observed at the storage object.
//
// swagger:model AggregateMetricLatency
type AggregateMetricLatency struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this aggregate metric latency
func (m *AggregateMetricLatency) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this aggregate metric latency based on the context it is used
func (m *AggregateMetricLatency) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *AggregateMetricLatency) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AggregateMetricLatency) UnmarshalBinary(b []byte) error {
	var res AggregateMetricLatency
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AggregateMetricLinks aggregate metric links
//
// swagger:model AggregateMetricLinks
type AggregateMetricLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this aggregate metric links
func (m *AggregateMetricLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AggregateMetricLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this aggregate metric links based on the context it is used
func (m *AggregateMetricLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AggregateMetricLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metric" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AggregateMetricLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AggregateMetricLinks) UnmarshalBinary(b []byte) error {
	var res AggregateMetricLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AggregateMetricThroughput The rate of throughput bytes per second observed at the storage object.
//
// swagger:model AggregateMetricThroughput
type AggregateMetricThroughput struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this aggregate metric throughput
func (m *AggregateMetricThroughput) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this aggregate metric throughput based on the context it is used
func (m *AggregateMetricThroughput) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *AggregateMetricThroughput) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AggregateMetricThroughput) UnmarshalBinary(b []byte) error {
	var res AggregateMetricThroughput
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AggregateNode Node where the aggregate currently resides.
//
// swagger:model AggregateNode
type AggregateNode struct {

	// links
	Links *AggregateNodeLinks `json:"_links,omitempty"`

	// name
	// Example: node1
	Name string `json:"name,omitempty"`

	// uuid
	// Example: 1cd8a442-86d1-11e0-ae1c-123478563412
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this aggregate node
func (m *AggregateNode) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AggregateNode) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this aggregate node based on the context it is used
func (m *AggregateNode) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AggregateNode) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AggregateNode) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AggregateNode) UnmarshalBinary(b []byte) error {
	var res AggregateNode
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AggregateNodeLinks aggregate node links
//
// swagger:model AggregateNodeLinks
type AggregateNodeLinks struct {

	// self
	Self *Href `json:"self,omitempty"`
}

// Validate validates this aggregate node links
func (m *AggregateNodeLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AggregateNodeLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this aggregate node links based on the context it is used
func (m *AggregateNodeLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AggregateNodeLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {
		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AggregateNodeLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AggregateNodeLinks) UnmarshalBinary(b []byte) error {
	var res AggregateNodeLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AggregateSnapshot aggregate snapshot
//
// swagger:model AggregateSnapshot
type AggregateSnapshot struct {

	// Total files allowed in Snapshot copies
	// Example: 10
	// Read Only: true
	FilesTotal int64 `json:"files_total,omitempty"`

	// Total files created in Snapshot copies
	// Example: 3
	// Read Only: true
	FilesUsed int64 `json:"files_used,omitempty"`

	// Maximum files available for Snapshot copies
	// Example: 5
	// Read Only: true
	MaxFilesAvailable int64 `json:"max_files_available,omitempty"`

	// Files in use by Snapshot copies
	// Example: 50
	// Read Only: true
	MaxFilesUsed int64 `json:"max_files_used,omitempty"`
}

// Validate validates this aggregate snapshot
func (m *AggregateSnapshot) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this aggregate snapshot based on the context it is used
func (m *AggregateSnapshot) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFilesTotal(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFilesUsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMaxFilesAvailable(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMaxFilesUsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AggregateSnapshot) contextValidateFilesTotal(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "snapshot"+"."+"files_total", "body", int64(m.FilesTotal)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateSnapshot) contextValidateFilesUsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "snapshot"+"."+"files_used", "body", int64(m.FilesUsed)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateSnapshot) contextValidateMaxFilesAvailable(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "snapshot"+"."+"max_files_available", "body", int64(m.MaxFilesAvailable)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateSnapshot) contextValidateMaxFilesUsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "snapshot"+"."+"max_files_used", "body", int64(m.MaxFilesUsed)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AggregateSnapshot) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AggregateSnapshot) UnmarshalBinary(b []byte) error {
	var res AggregateSnapshot
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AggregateSpace aggregate space
//
// swagger:model AggregateSpace
type AggregateSpace struct {

	// block storage
	BlockStorage *AggregateSpaceBlockStorage `json:"block_storage,omitempty"`

	// cloud storage
	CloudStorage *AggregateSpaceCloudStorage `json:"cloud_storage,omitempty"`

	// efficiency
	Efficiency *AggregateSpaceEfficiency `json:"efficiency,omitempty"`

	// efficiency without snapshots
	EfficiencyWithoutSnapshots *AggregateSpaceEfficiencyWithoutSnapshots `json:"efficiency_without_snapshots,omitempty"`

	// efficiency without snapshots flexclones
	EfficiencyWithoutSnapshotsFlexclones *AggregateSpaceEfficiencyWithoutSnapshotsFlexclones `json:"efficiency_without_snapshots_flexclones,omitempty"`

	// A summation of volume footprints (including volume guarantees), in bytes. This includes all of the volume footprints in the block_storage tier and the cloud_storage tier.
	// This is an advanced property; there is an added cost to retrieving its value. The field is not populated for either a collection GET or an instance GET unless it is explicitly requested using the <i>fields</i> query parameter containing either footprint or **.
	//
	// Example: 608896
	// Read Only: true
	Footprint int64 `json:"footprint,omitempty"`

	// snapshot
	Snapshot *AggregateSpaceSnapshot `json:"snapshot,omitempty"`
}

// Validate validates this aggregate space
func (m *AggregateSpace) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockStorage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCloudStorage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEfficiency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEfficiencyWithoutSnapshots(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEfficiencyWithoutSnapshotsFlexclones(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnapshot(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AggregateSpace) validateBlockStorage(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockStorage) { // not required
		return nil
	}

	if m.BlockStorage != nil {
		if err := m.BlockStorage.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space" + "." + "block_storage")
			}
			return err
		}
	}

	return nil
}

func (m *AggregateSpace) validateCloudStorage(formats strfmt.Registry) error {
	if swag.IsZero(m.CloudStorage) { // not required
		return nil
	}

	if m.CloudStorage != nil {
		if err := m.CloudStorage.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space" + "." + "cloud_storage")
			}
			return err
		}
	}

	return nil
}

func (m *AggregateSpace) validateEfficiency(formats strfmt.Registry) error {
	if swag.IsZero(m.Efficiency) { // not required
		return nil
	}

	if m.Efficiency != nil {
		if err := m.Efficiency.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space" + "." + "efficiency")
			}
			return err
		}
	}

	return nil
}

func (m *AggregateSpace) validateEfficiencyWithoutSnapshots(formats strfmt.Registry) error {
	if swag.IsZero(m.EfficiencyWithoutSnapshots) { // not required
		return nil
	}

	if m.EfficiencyWithoutSnapshots != nil {
		if err := m.EfficiencyWithoutSnapshots.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space" + "." + "efficiency_without_snapshots")
			}
			return err
		}
	}

	return nil
}

func (m *AggregateSpace) validateEfficiencyWithoutSnapshotsFlexclones(formats strfmt.Registry) error {
	if swag.IsZero(m.EfficiencyWithoutSnapshotsFlexclones) { // not required
		return nil
	}

	if m.EfficiencyWithoutSnapshotsFlexclones != nil {
		if err := m.EfficiencyWithoutSnapshotsFlexclones.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space" + "." + "efficiency_without_snapshots_flexclones")
			}
			return err
		}
	}

	return nil
}

func (m *AggregateSpace) validateSnapshot(formats strfmt.Registry) error {
	if swag.IsZero(m.Snapshot) { // not required
		return nil
	}

	if m.Snapshot != nil {
		if err := m.Snapshot.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space" + "." + "snapshot")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this aggregate space based on the context it is used
func (m *AggregateSpace) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBlockStorage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCloudStorage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEfficiency(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEfficiencyWithoutSnapshots(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEfficiencyWithoutSnapshotsFlexclones(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFootprint(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSnapshot(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AggregateSpace) contextValidateBlockStorage(ctx context.Context, formats strfmt.Registry) error {

	if m.BlockStorage != nil {
		if err := m.BlockStorage.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space" + "." + "block_storage")
			}
			return err
		}
	}

	return nil
}

func (m *AggregateSpace) contextValidateCloudStorage(ctx context.Context, formats strfmt.Registry) error {

	if m.CloudStorage != nil {
		if err := m.CloudStorage.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space" + "." + "cloud_storage")
			}
			return err
		}
	}

	return nil
}

func (m *AggregateSpace) contextValidateEfficiency(ctx context.Context, formats strfmt.Registry) error {

	if m.Efficiency != nil {
		if err := m.Efficiency.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space" + "." + "efficiency")
			}
			return err
		}
	}

	return nil
}

func (m *AggregateSpace) contextValidateEfficiencyWithoutSnapshots(ctx context.Context, formats strfmt.Registry) error {

	if m.EfficiencyWithoutSnapshots != nil {
		if err := m.EfficiencyWithoutSnapshots.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space" + "." + "efficiency_without_snapshots")
			}
			return err
		}
	}

	return nil
}

func (m *AggregateSpace) contextValidateEfficiencyWithoutSnapshotsFlexclones(ctx context.Context, formats strfmt.Registry) error {

	if m.EfficiencyWithoutSnapshotsFlexclones != nil {
		if err := m.EfficiencyWithoutSnapshotsFlexclones.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space" + "." + "efficiency_without_snapshots_flexclones")
			}
			return err
		}
	}

	return nil
}

func (m *AggregateSpace) contextValidateFootprint(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"footprint", "body", int64(m.Footprint)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateSpace) contextValidateSnapshot(ctx context.Context, formats strfmt.Registry) error {

	if m.Snapshot != nil {
		if err := m.Snapshot.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("space" + "." + "snapshot")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AggregateSpace) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AggregateSpace) UnmarshalBinary(b []byte) error {
	var res AggregateSpace
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AggregateSpaceBlockStorage aggregate space block storage
//
// swagger:model AggregateSpaceBlockStorage
type AggregateSpaceBlockStorage struct {

	// Aggregate metadata, in bytes.
	// Example: 2655
	// Read Only: true
	AggregateMetadata int64 `json:"aggregate-metadata,omitempty"`

	// Aggregate metadata as a percentage.
	// Example: 8
	// Read Only: true
	AggregateMetadataPercent int64 `json:"aggregate-metadata-percent,omitempty"`

	// Space available in bytes.
	// Example: 10156560384
	// Read Only: true
	Available int64 `json:"available,omitempty"`

	// Amount of compacted data in bytes.
	// Example: 1990000
	// Read Only: true
	DataCompactedCount int64 `json:"data_compacted_count,omitempty"`

	// Space saved in bytes by compacting the data.
	// Example: 1996000
	// Read Only: true
	DataCompactionSpaceSaved int64 `json:"data_compaction_space_saved,omitempty"`

	// Percentage saved by compacting the data.
	// Example: 27
	// Read Only: true
	DataCompactionSpaceSavedPercent int64 `json:"data_compaction_space_saved_percent,omitempty"`

	// The aggregate used percentage at which 'monitor.volume.full' EMS is generated.
	// Read Only: true
	FullThresholdPercent int64 `json:"full_threshold_percent,omitempty"`

	// The size that is physically used in the block storage and has a cold temperature, in bytes. This property is only supported if the aggregate is either attached to a cloud store or can be attached to a cloud store.
	// This is an advanced property; there is an added cost to retrieving its value. The field is not populated for either a collection GET or an instance GET unless it is explicitly requested using the <i>fields</i> query parameter containing either block_storage.inactive_user_data or **.
	//
	// Example: 304448
	// Read Only: true
	InactiveUserData int64 `json:"inactive_user_data,omitempty"`

	// The percentage of inactive user data in the block storage. This property is only supported if the aggregate is either attached to a cloud store or can be attached to a cloud store.
	// This is an advanced property; there is an added cost to retrieving its value. The field is not populated for either a collection GET or an instance GET unless it is explicitly requested using the <i>fields</i> query parameter containing either block_storage.inactive_user_data_percent or **.
	//
	// Read Only: true
	InactiveUserDataPercent int64 `json:"inactive_user_data_percent,omitempty"`

	// Total physical used size of an aggregate in bytes.
	// Example: 2461696
	// Read Only: true
	PhysicalUsed int64 `json:"physical_used,omitempty"`

	// Physical used percentage.
	// Example: 50
	// Read Only: true
	PhysicalUsedPercent int64 `json:"physical_used_percent,omitempty"`

	// Total usable space in bytes, not including WAFL reserve and aggregate Snapshot copy reserve.
	// Example: 10156769280
	// Read Only: true
	Size int64 `json:"size,omitempty"`

	// Space used or reserved in bytes. Includes volume guarantees and aggregate metadata.
	// Example: 2088960
	// Read Only: true
	Used int64 `json:"used,omitempty"`

	// Total used including the Snapshot copy reserve, in bytes.
	// Example: 674685
	// Read Only: true
	UsedIncludingSnapshotReserve int64 `json:"used-including-snapshot-reserve,omitempty"`

	// Total used including the Snapshot reserve as a percentage.
	// Example: 35
	// Read Only: true
	UsedIncludingSnapshotReservePercent int64 `json:"used-including-snapshot-reserve-percent,omitempty"`

	// Total of volume footprints as a percentage.
	// Example: 14
	// Read Only: true
	VolumeFootprintsPercent int64 `json:"volume-footprints-percent,omitempty"`

	// Amount of shared bytes counted by storage efficiency.
	// Example: 1990000
	// Read Only: true
	VolumeDeduplicationSharedCount int64 `json:"volume_deduplication_shared_count,omitempty"`

	// Amount of space saved in bytes by storage efficiency.
	// Example: 1996000
	// Read Only: true
	VolumeDeduplicationSpaceSaved int64 `json:"volume_deduplication_space_saved,omitempty"`

	// Percentage of space saved by storage efficiency.
	// Example: 27
	// Read Only: true
	VolumeDeduplicationSpaceSavedPercent int64 `json:"volume_deduplication_space_saved_percent,omitempty"`
}

// Validate validates this aggregate space block storage
func (m *AggregateSpaceBlockStorage) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this aggregate space block storage based on the context it is used
func (m *AggregateSpaceBlockStorage) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAggregateMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAggregateMetadataPercent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAvailable(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDataCompactedCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDataCompactionSpaceSaved(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDataCompactionSpaceSavedPercent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFullThresholdPercent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInactiveUserData(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInactiveUserDataPercent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePhysicalUsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePhysicalUsedPercent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSize(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsedIncludingSnapshotReserve(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsedIncludingSnapshotReservePercent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVolumeFootprintsPercent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVolumeDeduplicationSharedCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVolumeDeduplicationSpaceSaved(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVolumeDeduplicationSpaceSavedPercent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AggregateSpaceBlockStorage) contextValidateAggregateMetadata(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"block_storage"+"."+"aggregate-metadata", "body", int64(m.AggregateMetadata)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateSpaceBlockStorage) contextValidateAggregateMetadataPercent(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"block_storage"+"."+"aggregate-metadata-percent", "body", int64(m.AggregateMetadataPercent)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateSpaceBlockStorage) contextValidateAvailable(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"block_storage"+"."+"available", "body", int64(m.Available)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateSpaceBlockStorage) contextValidateDataCompactedCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"block_storage"+"."+"data_compacted_count", "body", int64(m.DataCompactedCount)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateSpaceBlockStorage) contextValidateDataCompactionSpaceSaved(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"block_storage"+"."+"data_compaction_space_saved", "body", int64(m.DataCompactionSpaceSaved)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateSpaceBlockStorage) contextValidateDataCompactionSpaceSavedPercent(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"block_storage"+"."+"data_compaction_space_saved_percent", "body", int64(m.DataCompactionSpaceSavedPercent)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateSpaceBlockStorage) contextValidateFullThresholdPercent(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"block_storage"+"."+"full_threshold_percent", "body", int64(m.FullThresholdPercent)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateSpaceBlockStorage) contextValidateInactiveUserData(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"block_storage"+"."+"inactive_user_data", "body", int64(m.InactiveUserData)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateSpaceBlockStorage) contextValidateInactiveUserDataPercent(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"block_storage"+"."+"inactive_user_data_percent", "body", int64(m.InactiveUserDataPercent)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateSpaceBlockStorage) contextValidatePhysicalUsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"block_storage"+"."+"physical_used", "body", int64(m.PhysicalUsed)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateSpaceBlockStorage) contextValidatePhysicalUsedPercent(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"block_storage"+"."+"physical_used_percent", "body", int64(m.PhysicalUsedPercent)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateSpaceBlockStorage) contextValidateSize(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"block_storage"+"."+"size", "body", int64(m.Size)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateSpaceBlockStorage) contextValidateUsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"block_storage"+"."+"used", "body", int64(m.Used)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateSpaceBlockStorage) contextValidateUsedIncludingSnapshotReserve(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"block_storage"+"."+"used-including-snapshot-reserve", "body", int64(m.UsedIncludingSnapshotReserve)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateSpaceBlockStorage) contextValidateUsedIncludingSnapshotReservePercent(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"block_storage"+"."+"used-including-snapshot-reserve-percent", "body", int64(m.UsedIncludingSnapshotReservePercent)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateSpaceBlockStorage) contextValidateVolumeFootprintsPercent(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"block_storage"+"."+"volume-footprints-percent", "body", int64(m.VolumeFootprintsPercent)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateSpaceBlockStorage) contextValidateVolumeDeduplicationSharedCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"block_storage"+"."+"volume_deduplication_shared_count", "body", int64(m.VolumeDeduplicationSharedCount)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateSpaceBlockStorage) contextValidateVolumeDeduplicationSpaceSaved(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"block_storage"+"."+"volume_deduplication_space_saved", "body", int64(m.VolumeDeduplicationSpaceSaved)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateSpaceBlockStorage) contextValidateVolumeDeduplicationSpaceSavedPercent(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"block_storage"+"."+"volume_deduplication_space_saved_percent", "body", int64(m.VolumeDeduplicationSpaceSavedPercent)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AggregateSpaceBlockStorage) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AggregateSpaceBlockStorage) UnmarshalBinary(b []byte) error {
	var res AggregateSpaceBlockStorage
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AggregateSpaceCloudStorage aggregate space cloud storage
//
// swagger:model AggregateSpaceCloudStorage
type AggregateSpaceCloudStorage struct {

	// Used space in bytes in the cloud store. Only applicable for aggregates with a cloud store tier.
	// Example: 402743264
	// Read Only: true
	Used int64 `json:"used,omitempty"`
}

// Validate validates this aggregate space cloud storage
func (m *AggregateSpaceCloudStorage) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this aggregate space cloud storage based on the context it is used
func (m *AggregateSpaceCloudStorage) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AggregateSpaceCloudStorage) contextValidateUsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"cloud_storage"+"."+"used", "body", int64(m.Used)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AggregateSpaceCloudStorage) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AggregateSpaceCloudStorage) UnmarshalBinary(b []byte) error {
	var res AggregateSpaceCloudStorage
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AggregateSpaceEfficiency Storage efficiency.
//
// swagger:model AggregateSpaceEfficiency
type AggregateSpaceEfficiency struct {

	// Logical used
	// Read Only: true
	LogicalUsed int64 `json:"logical_used,omitempty"`

	// Data reduction ratio (logical_used / used)
	// Read Only: true
	Ratio float64 `json:"ratio,omitempty"`

	// Space saved by storage efficiencies (logical_used - used)
	// Read Only: true
	Savings int64 `json:"savings,omitempty"`
}

// Validate validates this aggregate space efficiency
func (m *AggregateSpaceEfficiency) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this aggregate space efficiency based on the context it is used
func (m *AggregateSpaceEfficiency) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLogicalUsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRatio(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSavings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AggregateSpaceEfficiency) contextValidateLogicalUsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"efficiency"+"."+"logical_used", "body", int64(m.LogicalUsed)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateSpaceEfficiency) contextValidateRatio(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"efficiency"+"."+"ratio", "body", float64(m.Ratio)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateSpaceEfficiency) contextValidateSavings(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"efficiency"+"."+"savings", "body", int64(m.Savings)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AggregateSpaceEfficiency) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AggregateSpaceEfficiency) UnmarshalBinary(b []byte) error {
	var res AggregateSpaceEfficiency
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AggregateSpaceEfficiencyWithoutSnapshots Storage efficiency that does not include the savings provided by Snapshot copies.
//
// swagger:model AggregateSpaceEfficiencyWithoutSnapshots
type AggregateSpaceEfficiencyWithoutSnapshots struct {

	// Logical used
	// Read Only: true
	LogicalUsed int64 `json:"logical_used,omitempty"`

	// Data reduction ratio (logical_used / used)
	// Read Only: true
	Ratio float64 `json:"ratio,omitempty"`

	// Space saved by storage efficiencies (logical_used - used)
	// Read Only: true
	Savings int64 `json:"savings,omitempty"`
}

// Validate validates this aggregate space efficiency without snapshots
func (m *AggregateSpaceEfficiencyWithoutSnapshots) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this aggregate space efficiency without snapshots based on the context it is used
func (m *AggregateSpaceEfficiencyWithoutSnapshots) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLogicalUsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRatio(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSavings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AggregateSpaceEfficiencyWithoutSnapshots) contextValidateLogicalUsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"efficiency_without_snapshots"+"."+"logical_used", "body", int64(m.LogicalUsed)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateSpaceEfficiencyWithoutSnapshots) contextValidateRatio(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"efficiency_without_snapshots"+"."+"ratio", "body", float64(m.Ratio)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateSpaceEfficiencyWithoutSnapshots) contextValidateSavings(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"efficiency_without_snapshots"+"."+"savings", "body", int64(m.Savings)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AggregateSpaceEfficiencyWithoutSnapshots) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AggregateSpaceEfficiencyWithoutSnapshots) UnmarshalBinary(b []byte) error {
	var res AggregateSpaceEfficiencyWithoutSnapshots
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AggregateSpaceEfficiencyWithoutSnapshotsFlexclones Storage efficiency that does not include the savings provided by Snapshot copies and Flexclone volumes.
//
// swagger:model AggregateSpaceEfficiencyWithoutSnapshotsFlexclones
type AggregateSpaceEfficiencyWithoutSnapshotsFlexclones struct {

	// Logical used
	// Read Only: true
	LogicalUsed int64 `json:"logical_used,omitempty"`

	// Data reduction ratio (logical_used / used)
	// Read Only: true
	Ratio float64 `json:"ratio,omitempty"`

	// Space saved by storage efficiencies (logical_used - used)
	// Read Only: true
	Savings int64 `json:"savings,omitempty"`
}

// Validate validates this aggregate space efficiency without snapshots flexclones
func (m *AggregateSpaceEfficiencyWithoutSnapshotsFlexclones) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this aggregate space efficiency without snapshots flexclones based on the context it is used
func (m *AggregateSpaceEfficiencyWithoutSnapshotsFlexclones) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLogicalUsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRatio(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSavings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AggregateSpaceEfficiencyWithoutSnapshotsFlexclones) contextValidateLogicalUsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"efficiency_without_snapshots_flexclones"+"."+"logical_used", "body", int64(m.LogicalUsed)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateSpaceEfficiencyWithoutSnapshotsFlexclones) contextValidateRatio(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"efficiency_without_snapshots_flexclones"+"."+"ratio", "body", float64(m.Ratio)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateSpaceEfficiencyWithoutSnapshotsFlexclones) contextValidateSavings(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"efficiency_without_snapshots_flexclones"+"."+"savings", "body", int64(m.Savings)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AggregateSpaceEfficiencyWithoutSnapshotsFlexclones) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AggregateSpaceEfficiencyWithoutSnapshotsFlexclones) UnmarshalBinary(b []byte) error {
	var res AggregateSpaceEfficiencyWithoutSnapshotsFlexclones
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AggregateSpaceSnapshot aggregate space snapshot
//
// swagger:model AggregateSpaceSnapshot
type AggregateSpaceSnapshot struct {

	// Available space for Snapshot copies in bytes
	// Example: 2000
	// Read Only: true
	Available int64 `json:"available,omitempty"`

	// Percentage of space reserved for Snapshot copies
	// Example: 20
	// Read Only: true
	ReservePercent int64 `json:"reserve_percent,omitempty"`

	// Total space for Snapshot copies in bytes
	// Example: 5000
	// Read Only: true
	Total int64 `json:"total,omitempty"`

	// Space used by Snapshot copies in bytes
	// Example: 3000
	// Read Only: true
	Used int64 `json:"used,omitempty"`

	// Percentage of disk space used by Snapshot copies
	// Example: 45
	// Read Only: true
	UsedPercent int64 `json:"used_percent,omitempty"`
}

// Validate validates this aggregate space snapshot
func (m *AggregateSpaceSnapshot) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this aggregate space snapshot based on the context it is used
func (m *AggregateSpaceSnapshot) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAvailable(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateReservePercent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTotal(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsedPercent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AggregateSpaceSnapshot) contextValidateAvailable(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"snapshot"+"."+"available", "body", int64(m.Available)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateSpaceSnapshot) contextValidateReservePercent(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"snapshot"+"."+"reserve_percent", "body", int64(m.ReservePercent)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateSpaceSnapshot) contextValidateTotal(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"snapshot"+"."+"total", "body", int64(m.Total)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateSpaceSnapshot) contextValidateUsed(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"snapshot"+"."+"used", "body", int64(m.Used)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateSpaceSnapshot) contextValidateUsedPercent(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "space"+"."+"snapshot"+"."+"used_percent", "body", int64(m.UsedPercent)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AggregateSpaceSnapshot) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AggregateSpaceSnapshot) UnmarshalBinary(b []byte) error {
	var res AggregateSpaceSnapshot
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AggregateStatistics The real time I/O statistics for the aggregate.
//
// swagger:model AggregateStatistics
type AggregateStatistics struct {

	// iops raw
	IopsRaw *AggregateStatisticsIopsRaw `json:"iops_raw,omitempty"`

	// latency raw
	LatencyRaw *AggregateStatisticsLatencyRaw `json:"latency_raw,omitempty"`

	// Errors associated with the sample. For example, if the aggregation of data over multiple nodes fails, then any partial errors might return "ok" on success or "error" on an internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". "Inconsistent_ delta_time" is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. "Negative_delta" is returned when an expected monotonically increasing value has decreased in value. "Inconsistent_old_data" is returned when one or more nodes do not have the latest data.
	// Example: ok
	// Read Only: true
	// Enum: [ok error partial_no_data partial_no_response partial_other_error negative_delta not_found backfilled_data inconsistent_delta_time inconsistent_old_data partial_no_uuid]
	Status string `json:"status,omitempty"`

	// throughput raw
	ThroughputRaw *AggregateStatisticsThroughputRaw `json:"throughput_raw,omitempty"`

	// The timestamp of the performance data.
	// Example: 2017-01-25T11:20:13Z
	// Read Only: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp,omitempty"`
}

// Validate validates this aggregate statistics
func (m *AggregateStatistics) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIopsRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatencyRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThroughputRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AggregateStatistics) validateIopsRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.IopsRaw) { // not required
		return nil
	}

	if m.IopsRaw != nil {
		if err := m.IopsRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "iops_raw")
			}
			return err
		}
	}

	return nil
}

func (m *AggregateStatistics) validateLatencyRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.LatencyRaw) { // not required
		return nil
	}

	if m.LatencyRaw != nil {
		if err := m.LatencyRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "latency_raw")
			}
			return err
		}
	}

	return nil
}

var aggregateStatisticsTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ok","error","partial_no_data","partial_no_response","partial_other_error","negative_delta","not_found","backfilled_data","inconsistent_delta_time","inconsistent_old_data","partial_no_uuid"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		aggregateStatisticsTypeStatusPropEnum = append(aggregateStatisticsTypeStatusPropEnum, v)
	}
}

const (

	// BEGIN DEBUGGING
	// AggregateStatistics
	// AggregateStatistics
	// status
	// Status
	// ok
	// END DEBUGGING
	// AggregateStatisticsStatusOk captures enum value "ok"
	AggregateStatisticsStatusOk string = "ok"

	// BEGIN DEBUGGING
	// AggregateStatistics
	// AggregateStatistics
	// status
	// Status
	// error
	// END DEBUGGING
	// AggregateStatisticsStatusError captures enum value "error"
	AggregateStatisticsStatusError string = "error"

	// BEGIN DEBUGGING
	// AggregateStatistics
	// AggregateStatistics
	// status
	// Status
	// partial_no_data
	// END DEBUGGING
	// AggregateStatisticsStatusPartialNoData captures enum value "partial_no_data"
	AggregateStatisticsStatusPartialNoData string = "partial_no_data"

	// BEGIN DEBUGGING
	// AggregateStatistics
	// AggregateStatistics
	// status
	// Status
	// partial_no_response
	// END DEBUGGING
	// AggregateStatisticsStatusPartialNoResponse captures enum value "partial_no_response"
	AggregateStatisticsStatusPartialNoResponse string = "partial_no_response"

	// BEGIN DEBUGGING
	// AggregateStatistics
	// AggregateStatistics
	// status
	// Status
	// partial_other_error
	// END DEBUGGING
	// AggregateStatisticsStatusPartialOtherError captures enum value "partial_other_error"
	AggregateStatisticsStatusPartialOtherError string = "partial_other_error"

	// BEGIN DEBUGGING
	// AggregateStatistics
	// AggregateStatistics
	// status
	// Status
	// negative_delta
	// END DEBUGGING
	// AggregateStatisticsStatusNegativeDelta captures enum value "negative_delta"
	AggregateStatisticsStatusNegativeDelta string = "negative_delta"

	// BEGIN DEBUGGING
	// AggregateStatistics
	// AggregateStatistics
	// status
	// Status
	// not_found
	// END DEBUGGING
	// AggregateStatisticsStatusNotFound captures enum value "not_found"
	AggregateStatisticsStatusNotFound string = "not_found"

	// BEGIN DEBUGGING
	// AggregateStatistics
	// AggregateStatistics
	// status
	// Status
	// backfilled_data
	// END DEBUGGING
	// AggregateStatisticsStatusBackfilledData captures enum value "backfilled_data"
	AggregateStatisticsStatusBackfilledData string = "backfilled_data"

	// BEGIN DEBUGGING
	// AggregateStatistics
	// AggregateStatistics
	// status
	// Status
	// inconsistent_delta_time
	// END DEBUGGING
	// AggregateStatisticsStatusInconsistentDeltaTime captures enum value "inconsistent_delta_time"
	AggregateStatisticsStatusInconsistentDeltaTime string = "inconsistent_delta_time"

	// BEGIN DEBUGGING
	// AggregateStatistics
	// AggregateStatistics
	// status
	// Status
	// inconsistent_old_data
	// END DEBUGGING
	// AggregateStatisticsStatusInconsistentOldData captures enum value "inconsistent_old_data"
	AggregateStatisticsStatusInconsistentOldData string = "inconsistent_old_data"

	// BEGIN DEBUGGING
	// AggregateStatistics
	// AggregateStatistics
	// status
	// Status
	// partial_no_uuid
	// END DEBUGGING
	// AggregateStatisticsStatusPartialNoUUID captures enum value "partial_no_uuid"
	AggregateStatisticsStatusPartialNoUUID string = "partial_no_uuid"
)

// prop value enum
func (m *AggregateStatistics) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, aggregateStatisticsTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AggregateStatistics) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("statistics"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *AggregateStatistics) validateThroughputRaw(formats strfmt.Registry) error {
	if swag.IsZero(m.ThroughputRaw) { // not required
		return nil
	}

	if m.ThroughputRaw != nil {
		if err := m.ThroughputRaw.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "throughput_raw")
			}
			return err
		}
	}

	return nil
}

func (m *AggregateStatistics) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("statistics"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this aggregate statistics based on the context it is used
func (m *AggregateStatistics) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIopsRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLatencyRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThroughputRaw(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimestamp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AggregateStatistics) contextValidateIopsRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.IopsRaw != nil {
		if err := m.IopsRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "iops_raw")
			}
			return err
		}
	}

	return nil
}

func (m *AggregateStatistics) contextValidateLatencyRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.LatencyRaw != nil {
		if err := m.LatencyRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "latency_raw")
			}
			return err
		}
	}

	return nil
}

func (m *AggregateStatistics) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"status", "body", string(m.Status)); err != nil {
		return err
	}

	return nil
}

func (m *AggregateStatistics) contextValidateThroughputRaw(ctx context.Context, formats strfmt.Registry) error {

	if m.ThroughputRaw != nil {
		if err := m.ThroughputRaw.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics" + "." + "throughput_raw")
			}
			return err
		}
	}

	return nil
}

func (m *AggregateStatistics) contextValidateTimestamp(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "statistics"+"."+"timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AggregateStatistics) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AggregateStatistics) UnmarshalBinary(b []byte) error {
	var res AggregateStatistics
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AggregateStatisticsIopsRaw The number of I/O operations observed at the storage object. This can be used along with delta time to calculate the rate of I/O operations per unit of time.
//
// swagger:model AggregateStatisticsIopsRaw
type AggregateStatisticsIopsRaw struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this aggregate statistics iops raw
func (m *AggregateStatisticsIopsRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this aggregate statistics iops raw based on the context it is used
func (m *AggregateStatisticsIopsRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *AggregateStatisticsIopsRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AggregateStatisticsIopsRaw) UnmarshalBinary(b []byte) error {
	var res AggregateStatisticsIopsRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AggregateStatisticsLatencyRaw The raw latency in microseconds observed at the storage object. This can be divided by the raw IOPS value to calculate the average latency per I/O operation.
//
// swagger:model AggregateStatisticsLatencyRaw
type AggregateStatisticsLatencyRaw struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this aggregate statistics latency raw
func (m *AggregateStatisticsLatencyRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this aggregate statistics latency raw based on the context it is used
func (m *AggregateStatisticsLatencyRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *AggregateStatisticsLatencyRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AggregateStatisticsLatencyRaw) UnmarshalBinary(b []byte) error {
	var res AggregateStatisticsLatencyRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AggregateStatisticsThroughputRaw Throughput bytes observed at the storage object. This can be used along with delta time to calculate the rate of throughput bytes per unit of time.
//
// swagger:model AggregateStatisticsThroughputRaw
type AggregateStatisticsThroughputRaw struct {

	// Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.
	Other int64 `json:"other,omitempty"`

	// Performance metric for read I/O operations.
	// Example: 200
	Read int64 `json:"read,omitempty"`

	// Performance metric aggregated over all types of I/O operations.
	// Example: 1000
	Total int64 `json:"total,omitempty"`

	// Peformance metric for write I/O operations.
	// Example: 100
	Write int64 `json:"write,omitempty"`
}

// Validate validates this aggregate statistics throughput raw
func (m *AggregateStatisticsThroughputRaw) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this aggregate statistics throughput raw based on the context it is used
func (m *AggregateStatisticsThroughputRaw) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *AggregateStatisticsThroughputRaw) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AggregateStatisticsThroughputRaw) UnmarshalBinary(b []byte) error {
	var res AggregateStatisticsThroughputRaw
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
