local FisherMarginLoss, parent = torch.class('nn.FisherMarginLoss', 'nn.Criterion')

function FisherMarginLoss:__init(opt) 
	parent.__init(self)
	self.L_1 = torch.Tensor()
	self.L_2 = torch.Tensor()
	self.gradInput_1 = torch.Tensor()
	self.gradInput_2 = torch.Tensor()
	self.alpha = opt.alpha
	--self.margin = nil 
	self.ind = torch.Tensor()
	self.num_samples = opt.num_samples
	self.margin = opt.margin
end

function FisherMarginLoss:updateOutput(input,  label)	
	--Calculate modified_centerloss 
 	local pair_ = {}
	local pair = {}
	local label = label:squeeze()
	local x = input
	local c = centers
	local bs = x:size(1)
	local diff = torch.Tensor(bs, x:size(2))
	for i=1, bs do
	   diff[i]:copy(x[i] - c[label[i]])	 
    end	
	self.L_1 = diff:norm(2,2):pow(2)
	local output_1 = (self.L_1:sum()  / bs ) / 2 
	print('batch averaged intra class distance:', self.L_1:mean())
	print('Intra class loss:', output_1)
	--self.margin = self.L_1:mean() * self.coeff
	print('Set margin to:', self.margin)
        --find unique labels
        uniqueLabels = {}
        foundLabels = {}
        for i=1,bs do
            l = label[i]
            if foundLabels[l] == nil then
                foundLabels[l] = true
                uniqueLabels[#uniqueLabels+1] = l
            end
        end
--Calculate between class difference
	--for i=1, bs-1 do
	--	for j = i+1, bs do
	--		if (label[i] ~= label[j]) then
	--			table.insert(pair_, {label[i],label[j]})
	--		end
	--	end
	--end
        for i=1, #uniqueLabels do
              for j = i+1, #uniqueLabels do
                      a = uniqueLabels[i]
                      b = uniqueLabels[j]
                      if (a ~= b) then
                              table.insert(pair_, {a,b})
                      end
              end
        end

--Use sampled pair
	local randperm = torch.randperm(#pair_):long()
	self.ind = randperm:narrow(1,1,self.num_samples)
	for i=1, self.ind:size(1) do
		table.insert(pair, pair_[self.ind[i]])
	end
--	print('self.pair:', pair)

	
	local diff_ = torch.Tensor(#pair, c:size(2))
	for i=1, #pair do
		diff_[i]:copy(c[pair[i][1]] - centers[pair[i][2]])
	end
	diff_ = diff_:norm(2,2):pow(2)
	diff_ = diff_:resize(diff_:size(1))

	print('batch averaged inter class distance:', diff_:mean())

	local m = torch.Tensor(#pair):fill(self.margin):type(torch.type(diff_))
--	print('check margin:', m)

	local zero = torch.Tensor(#pair):zero():type(torch.type(diff_))

	local tmp = torch.cat(zero, m - diff_, 2)

	self.L_2 = torch.max(tmp, 2)

	local output_2 = (self.L_2:sum() / #pair) / 2
	
	print('Inter class loss: ', output_2)
	
	self.output = output_1 + output_2

	return self.output 
end

function FisherMarginLoss:updateGradInput(input,  label)
	local pair_ = {}	
	local pair = {}
	local label = label:squeeze()
	local x = input
	local c = centers	
	local bs = x:size(1)

        uniqueLabels = {}
        foundLabels = {}
        for i=1,bs do
            l = label[i]
            if foundLabels[l] == nil then
                foundLabels[l] = true
                uniqueLabels[#uniqueLabels+1] = l
            end
        end
--Calculate between class difference
        --for i=1, bs-1 do
        --      for j = i+1, bs do
        --              if (label[i] ~= label[j]) then
        --                      table.insert(pair_, {label[i],label[j]})
        --              end
        --      end
        --end
        for i=1, #uniqueLabels do
              for j = i+1, #uniqueLabels do
                      a = uniqueLabels[i]
                      b = uniqueLabels[j]
                      if (a ~= b) then
                              table.insert(pair_, {a,b})
                      end
              end
        end

	for i=1, self.ind:size(1) do
		table.insert(pair, pair_[self.ind[i]])
	end

--	print('self.pair check:', pair)

	self.gradInput_1 = self.gradInput_1:resize(x:size()):type(x:type()):fill(0)
	self.gradInput_2 = self.gradInput_2:resize(x:size()):type(x:type()):fill(0)

--Calculate Grad w.r.t. Intra_class x_i
	for i=1, bs do
		local find_y = torch.find(label, label[i])
		local denominator = 1 + #find_y
		self.gradInput_1[i]:copy((x[i] - c[label[i]]) * (1 - self.alpha / denominator)) 
	end

--Calculate Grad w.r.t. Inter_class x_i
	for i=1, bs do
		local find_y = torch.find(label, label[i])
		for j=1, #pair do
			local dist = (c[pair[j][1]]-c[pair[j][2]]):norm(2) 
--			print('pairwise squared dist: ', dist * dist)
			if (dist * dist < self.margin) then
				if (label[i] == pair[j][1] or label[i] == pair[j][2]) then
					local tmp_grad =  self.alpha * (c[pair[j][1]]-c[pair[j][2]]) / (1 + #find_y)
					if (pair[j][1] == label[i]) then
						self.gradInput_2[i] = self.gradInput_2[i]:add(-tmp_grad)
					else		
						self.gradInput_2[i] = self.gradInput_2[i]:add(tmp_grad)
					end
				end
			end	
		end
	end
	

	self.gradInput_1 = self.gradInput_1 / bs
	print('abs gradInput_1 sum:', torch.abs(self.gradInput_1):sum())
	self.gradInput_2 = self.gradInput_2 / #pair 
	print('abs gradInput_2 sum:', torch.abs(self.gradInput_2):sum())
	print('\n')
	
		
	self.gradInput = self.gradInput_1 +  self.gradInput_2		

	return self.gradInput

end


