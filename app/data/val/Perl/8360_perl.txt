#!/usr/bin/env perl

# Pragma
use strict;
use utf8;
use warnings;
use Encode;
use lib 'lib/';

# Modules
use Time::HiRes 'time';
use Data::Dumper;

# Gestion de l'output, pour éviter les soucis d'encodage
binmode STDOUT, ':utf8';
if ($^O eq 'MSWin32') {
    eval "use Win32::Console;";
    Win32::Console::OutputCP(65001);
}
use IO::Handle;
STDOUT->autoflush(1);

# Gestion de l'output statique
mkdir 'out' unless -d 'out';

# Récupération des paramètres
my $lex = shift @ARGV;
eval "use Lexicators::$lex;";

my %args;
my @path_source;
my @path_meta;

while (@ARGV) {
    my @item = split /=/, (shift @ARGV);
    die unless defined $item[1];
    if ($item[0] eq 'path_source' or $item[0] eq 'path_meta') {
        eval "push \@$item[0], \$item[1];";
    } else {
        $args{$item[0]} = $item[1];
    }
}
$args{path_source} = shift @path_source;
$args{path_meta}   = shift @path_meta;
mkdir 'out' if $args{file_output};
$args{output}      = 'dump' unless ($args{output} and $args{output} eq 'xml' || $args{output} eq 'html');

#############################################################################

# Exécution
$::time = time();
my $lexicator;
eval "\$lexicator = $lex->new(\%args);";

for (@path_meta)   { $lexicator->add_metadata($_); }
for (@path_source) { $lexicator->add_source($_);   }

$lexicator->start_processing();
$lexicator->get_content(\$args{output}, \$args{file_output});
undef $lexicator;

# Fin d'exécution

printf 'Temps écoulé : %.3fs', (time() - $::time);
print "\n";
