use std;
extern crate serde_json;
extern crate serde;
use std::io::Read;
use emote;
use emote::{EmoteError,JsonError};
use http;

const GLOBAL_URL:&'static str = "https://api.twitch.tv/kraken/chat/emoticon_images?emotesets=0";


pub struct Emote<'a>{
    http: &'a http::Http,
}
#[derive(Serialize, Deserialize,Default)]
pub struct Set{
    id: u64,
    code: String,
}

impl emote::Emote for Set{
    fn name(&self)->&str{
        &self.code
    }
}

impl <'a>Emote<'a>{
    pub fn new(http:&http::Http)->Result<Emote,String>{
        Ok(Emote{
            http
        })
    }

    pub fn get_global(&self)->Result<Vec<Set>,EmoteError>{
        //let s = try!(self.http.get_body_string(GLOBAL_URL).map_err(EmoteError::Http));



        let mut file = match std::fs::File::open("twitch_global.json"){
            Ok(a)=>a,
            Err(_)=>panic!("could not open twitch global file"),
        };
        let mut s = String::new();
        file.read_to_string(&mut s);

        let v:serde_json::Value = try_map!(serde_json::from_str(&s),EmoteError::Json(JsonError::ParseError));
        let emoticon_sets = &v["emoticon_sets"];
        let mut sets = match emoticon_sets["0"].as_array(){
            Some(a)=>a.clone(),
            None=>return Err(EmoteError::Json(JsonError::ParseError)),
        };
        let mut emotes = Vec::new();
        for set in sets{
            let emote = try_map!(serde_json::from_value(set),EmoteError::Json(JsonError::ParseError));
            emotes.push(emote);
        }
        Ok(emotes)
    }
}

#[cfg(test)]
mod test {
    #[test]
    fn twitch_test(){
        let http_client = http::Http::new().unwrap();
        let mut twitch = Emote::new(&http_client).unwrap();
    }
}
