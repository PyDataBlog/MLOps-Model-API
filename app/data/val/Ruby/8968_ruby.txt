# RELEASE 2: NESTED STRUCTURE GOLF
# Hole 1
# Target element: "FORE"

array = [[1,2], ["inner", ["eagle", "par", ["FORE", "hook"]]]]

# attempts:
# ============================================================
#p array[1][0][1][0]
#p array[1][0[1][0]]
p array[1][1][2][0]



# ============================================================

# Hole 2
# Target element: "congrats!"

hash = {outer: {inner: {"almost" => {3 => "congrats!"}}}}

# attempts:
# ============================================================
p hash[:outer][:inner]["almost"][3]


# ============================================================


# Hole 3
# Target element: "finished"

nested_data = {array: ["array", {hash: "finished"}]}

# attempts:
# ============================================================
# p nested_data[:array][1]
p nested_data[:array][1][:hash]

# ============================================================

# RELEASE 3: ITERATE OVER NESTED STRUCTURES

number_array = [5, [10, 15], [20,25,30], 35]

my_plus_five = number_array.map do |element|
  if element.kind_of?(Integer)
    element + 5 #=> 10
  elsif element.kind_of?(Array)
    element.map do |x|
      x + 5
    end #=> [15, 20]
  end
end

p my_plus_five

# Bonus:
startup_names = ["bit", ["find", "fast", ["optimize", "scope"]]]

startup_name_generator = startup_names.map do |element|
  if element.kind_of?(String)
    element << "ly"
  elsif element.kind_of?(Array)
    element.map do |inner_element|
      if inner_element.kind_of?(String)
        inner_element << "ly"
      elsif inner_element.kind_of?(Array)
        inner_element.map do |third_level_element|
          if third_level_element.kind_of?(String)
            third_level_element << "ly"
          end
        end
      end
    end
  end
end

p startup_name_generator

=begin

Reflection:

What are some general rules you can apply to nested arrays?

Nested arrays work very similarly to regular arrays.  It really helps to just look at the array as whole first and break it down into it's individual elements.  You can recall indices in the same way, but you have to be aware of the levels in which you are working in order to recall them correctly.  It really helped me out to draw a diagram on paper to better visualize this at first.  As in the first example above, you would have to call array[1][1][2][0] to access the first index of the second index of the first index of the original containing index.  Just that explanation alone is confusing.

What are some ways you can iterate over nested arrays?

For these particular exercises, we found that it was better to iterate with ".map."  You can use ".each", but ".map" will return a new array which can be easily accessed through variable assignment.

Did you find any good new methods to implement or did you re-use one you were already familiar with? What was it and why did you decide that was a good option?

The main methods we used we were already familiar with but what really helped us in iterating through inner arrays was querying with the "kind_of?()" method in order to perform the desired operation on the appropriate objects.  For instance, in our initial work, we kept running into errors where our code tried to add FixNum objects to Array objects and that doesn't work.  We needed to be able to get inside the inner arrays before we were able to apply any of our code to the elements and "kind_of?()" was the key.

=end