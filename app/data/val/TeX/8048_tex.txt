\documentclass[11pt,fleqn,x11names,table]{book}                                                      
\usepackage[text={15cm,25cm},centering,headsep=20pt,top=0.8in,
bottom = 0.8in,letterpaper,showframe=false]{geometry} 

%----------------------------------------------------------------------
\input{include}
%----------------------------------------------------------------------

\renewcommand{\tablename}{Tabla}
\definecolor{styrmitcrwcgray1}{rgb}{0.2,0.2,0.2}
\definecolor{wcgray}{rgb}{0,0.1333,0.3333}
\usetikzlibrary{arrows}

\usepackage{makeidx}
\makeindex
\usepackage{fourier}
\usepackage{pdfpages}
\usepackage{parskip}

%---------------------------------------------------------------------------------------------------------------------
% FOR PYTHON LISTING  \begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
%---------------------------------------------------------------------------------------------------------------------
\usepackage{amsmath}
\usepackage[latin1]{inputenc}
\usepackage{minted} %minted requiere Python, Pygments y habilitar 'shell escape'
   %\usemintedstyle{vs} % estilo

%---------------------------------------------------------------------------------------------------------------------
% Patch to prevent red boxes for minted
%---------------------------------------------------------------------------------------------------------------------
\makeatletter
\AtBeginEnvironment{minted}{\dontdofcolorbox}
\def\dontdofcolorbox{\renewcommand\fcolorbox[4][]{##4}}
\makeatother


%---------------------------------------------------------------------------------------------------------------------
% Patch to prevent the error: sorry some package has redefined the meeaning of math-mode dollar sign
%---------------------------------------------------------------------------------------------------------------------
\makeatletter
\global\let\tikz@ensure@dollar@catcode=\relax
\makeatother

%---------------------------------------------------------------------------------------------------------------------
% BEGIN DOCUMENT - CHAPTERS
%---------------------------------------------------------------------------------------------------------------------

\begin{document}
%\includepdf[pages=-]{images/Portada}

\pagenumbering{roman} 
%\pagecolor{grisamarillo}
\parindent=0mm    % No indent
\pagestyle{empty}
\titulo{% Autor (\Fnte is a command for a special font type)
       \huge\bfseries\color{wcolornotas} Rahul Atlury., Fabian David Tschopp.}{%
        %Pre-title
        \color{verdeF}A Practical Guide to Real-Time Inference
        }{%
        %Main Title
         {\fontsize{40}{1} \selectfont Python Deep Learning using OpenCL Caffe}
        }{%
        %Additional
        ANNs, CNNs, RNNs, SOMs,\\
Autoencoders, Quantization, Compression 
        }
       

% %----------------------------------------------------------------------------------------
% % ISBN, licencia creative commons, etc.
% %----------------------------------------------------------------------------------------
\clearpage


%\noindent {\color{colordominante} Photos by}: Viviana Loaiza. Parque Nacional ChirripÃ³, Costa Rica.\\


\includegraphics[scale=0.7]{images/logocc}
\noindent  {\fontsize{9}{1} \selectfont This book is distributed under the Creative Commons Attribution-Noncommercial-No Derivative CC BY-NC-ND (the "License") license. You may use this file in accordance with the License. You may obtain a copy of the License at \url{https://creativecommons.org/licenses/by-nc-nd/4.0/}. In particular, this license allows free copying and distribution, but does not allow sale or modification of this material.\\
  Limitation of Liability and Warranty Disclaimer: The author (s) have done their best to prepare this material.
  This edition is provided "as is". It is distributed free of charge in the hope that it will be useful, but without any express or implied warranty as to the accuracy or completeness of the content.
  The Python Deep Learning using OpenCL Caffe is an electronic publication. The material published in it expresses the opinion of its authors and not necessarily the opinion of organization nor that of any institution.}\\
  
  
%--------------------------------------------------------------------------------
% TOC
%--------------------------------------------------------------------------------
\tableofcontents

%---------------------------------------------------------------------------------
% Forward
%---------------------------------------------------------------------------------

\begin{prologo}
\thispagestyle{empty}

\end{prologo}


\cleardoublepage
\pagestyle{fancy} % Habilitar encabezados
\pagenumbering{arabic}
\setcounter{page}{1}


%--------------------------------------------------------------------------------------
%	Chapter 1
%---------------------------------------------------------------------------------------
\chapter{Python Programming Basics}
%%\input{chapter1.tex}
\begin{caja}[Note]
 This introduction to Python assumes exposure to introductory programming principles, including concepts relating to variables, objects, and classes. That said, we do not expect the reader to be an expert. Indentation is part of Python's syntax, and when we are talking about Python, we are explicitly referring to {\it Python 3}.
 \end{caja}

\section{Variables and types}
Fundamentally everything in Python is considered an {\bf object}. These objects often have {\bf methods} (basically functions). This aspect is critical for understanding and using Python as a programming language.

Variables in Python are just names and have no information associated with them. Variables just point to objects.
\begin{tikzpicture}[remember picture,overlay]
 %\node at (current page.center) {I am NOT MOOVING!};
 \draw [blue,line width=2mm]
 (current page.south west)
 rectangle
 (current page.north east)
 ;
 \draw [green]
 (current page text area.south west)
 rectangle
 (current page text area.north east)
 ;
 \draw [yellow]
 (current page marginpar area.south west)
 rectangle
 (current page marginpar area.north east)
 ;
 \draw [red]
 (current page header area.south west)
 rectangle
 (current page header area.north east)
 ;
 \draw [orange]
 (current page footer area.south west)
 rectangle
 (current page footer area.north east)
 ;
 \begin{scope}[shift=(current page.south west)]
    \fill (5,5) circle (1cm);
    \draw (0,0) -- (60:10);
\end{scope}
\end{tikzpicture}
\begin{ejemplo}
 \begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> x = 1911
>>> y = 1911.0
>>> print(x)
1911
 \end{minted}
\end{ejemplo}

It is the objects that have an associated {\bf type} information. Type information of an object determines whether it is {\bf mutable} or {\bf immutable}. 

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> print(type(x))
<class 'int'>
>>> print(type(y))
<class 'float'>
\end{minted}
\end{ejemplo}

Examples of immutable and mutable objects include the following:

\begin{description}
\item[Immutable:] bool, int, long, complex, string, bytes, tuple, frozen set, range.
\item[Mutable:] byte array, list, set, dictionary, user-defined classes.
\end{description}

\begin{caja}[Note]
Python does not allow changing the contents of immutable objects. Assigning a new value to immutable objects can create newer versions of the same object consuming lots of memory. Hence, careful attention to mutability is necessary while developing applications in Python.
\end{caja}

The assignment operation is performed using the single equal to symbol ({\em =}).

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> a = 'razor'
>>> b = 'class'
>>> c = a
\end{minted}
\end{ejemplo}

\begin{caja}[Note]
It does not matter if string literals are represented using single quotes or double quotes.
\end{caja}

A double equal to symbol ({\em ==}) tests the equality between two variables.

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> print(c == a)
True
>>> print(c == b)
False
\end{minted}
\end{ejemplo}

The double equal to symbol ({\em ==}) symbol compares the values of two objects while the {\em is} operator compares their identities (compares the {\em id()} value of the two objects).

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> print(c is b)
False
>>> print(c is a)
True
>>> id(a)
140189383867112
>>> id(c)
140189383867112
\end{minted}
\end{ejemplo}

The boolean type {\em bool} is a data type, having two values intended to represent either true or false. The default value is {\em False}. Integers, floating point numbers having zero value are considered false. There is also the {\em None} type in Python, which primarily represents a null object.

Python includes operators for Boolean logic like {\em and}, {\em or}, {\em not}. Python does not support the use of the increment ({\em x++}) or decrement ({\em x--}) operators.

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> x = 1911
>>> x+=1
>>> print(x)        
1912
>>> x*=2
>>> print(x)
3824
\end{minted}
\end{ejemplo}

Conversion between types is possible within python using the inbuilt functions like {\em int()}, {\em float()}. For further study Python has an on-line language reference guide available at the following Url, \url{https://docs.python.org/3/reference/index.html} and we firmly urge readers to refer to it.

\section{Sequences}
\label{sequences}
The variables shown above were all single-valued. Sequences in Python are a {\bf multivalued} set of objects. Sequences are crucial for the study of deep learning.

\begin{tcolorbox}[tabularx={X||X||X||X},title= {\white Summary of sequences}, beamer]
SEQUENCE  	& TYPE        & SYNTAX & Notes \\\hline\hline
Strings & Immutable &  "python"	   \\\hline
Tuples & Immutable & (1,2,3)		\\\hline
Lists & Mutable &  [1,2,3]			\\\hline
Bytes & Immutable &  b'abc			\\\hline
Bytearrays & Mutable & bytearray(b'abc') 
\end{tcolorbox}

Sequences are categorized based on their mutability. As mentioned before, immutable sequence objects cannot be changed once created. The created immutable object may contain references to other mutable objects. 

The starting index of a sequence is always zero and indexed from zero to length-1. The statement {\em sequence[index]} returns the item at that particular index.

\begin{verbatim}
Index from back:    -12 -11 -10  -9  -8  -7  -6  -5  -4  -3  -2  -1  	  
Index from front:     0   1   2   3   4   5   6   7   8   9   10  12
                    +---+---+---+---+---+---+---+---+---+---+---+---+    
                    | t | h | e |   | b | o | x |   | b | a | n | d |    
                    +---+---+---+---+---+---+---+---+---+---+---+---+
\end{verbatim}

Interestingly sequences can also be indexed by using negative indices so that the last item in the sequence has an index of -1. The built-in function {\em len()} returns the number of items in a sequence.

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> sample_string = "the box band"
>>> len(sample_string)
12
>>> sample_string[1]
'h'
>>> sample_string[-12]
't'
\end{minted}
\end{ejemplo}

\begin{caja}[Note]
We specify the index in square brackets for sequences.
\end{caja}

\subsection{Tuples and lists}
\label{tuples-lists}
Tuples and lists are {\bf ordered} sequences and can be used to store {\bf homogeneous} as well as {\bf heterogeneous} data types. They can have {\bf duplicate} values. 

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> sample_tuple = (1,2,3)
>>> sample_list = [1,2,3]
>>> sample_tuple_dup = (1,1,2,2,3,3)
>>> sample_list_dup = [1,1,2,2,3,3]
>>> type(sample_tuple)
<class 'tuple'>
>>> type(sample_list)
<class 'list'>
\end{minted}
\end{ejemplo}

Tuples are fixed in size whereas lists are dynamic, in other words, tuples do not allow the addition of new items nor the removal of existing items once created.

A list permits the addition of items to the end. They can also be removed and returned from the last item of the list. No, append or extend methods, nor any remove or pop methods are available for tuples.

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> sample_tuple.pop(1)
AttributeError: 'tuple' object has no attribute 'pop'
>>> sample_list.pop(1)
2
\end{minted}
\end{ejemplo}

Tuples are inherently {\bf faster} compared to lists. Since elements of the tuple do not change, they can be easily found using the {\em in} operator. Essentially it is the commas, not the parentheses, that define the tuple.

The {\em count()} method returns the number of occurrences while {\em in} operator returns true if the value is in the sequence. The {\em index()} method returns only the index of the first occurrence of the value searched.

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> sample_list_dup.count(1)
2
>>> sample_tuple_dup.count(3)
2
>>> 3 in sample_tuple_dup
True
>>> sample_tuple_dup.index(3)
4
\end{minted}
\end{ejemplo}

Python includes the {\em any()} method which will return {\em True} when atleast one of the elements is true and the {\em all()} method will return {\em True} only when all the elements are true.

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> any([False, False, False])
False
>>> any([False, True, False])
True
>>> all([False, True, True])
False
>>> all([True, True, True])
True
\end{minted}
\end{ejemplo}

\subsection{Bytes and bytearrays}
\label{bytes-bytearrays}
A bytearray and a byte object are almost similar (integers from 0 to 256) except that bytearrays offer mutability. They are used during scenarios like the handling of binary data from a file or a network.

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> b1 = b'leader'
>>> b2 = b'class'
>>> b1[0] == b2
False
>>> b1[0] == b2[1]
True. 
\end{minted}
\end{ejemplo}

The built-in {\em bytearray()} function can be used to convert a bytes object into a mutable bytearray object.

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> byarray = bytearray(b1)
>>> type(b1)
bytes
>>> type(byarray)
bytearray
\end{minted}
\end{ejemplo}

\subsection{Slicing}
\label{slicing}
Sequences support what is known as slicing. A slice[i:j] selects and returns a new sequence of same type starting with the first slice[i] up to but excluding slice[j]. Slicing works even when one or both of the indices are negative.

The first index specifies the first slice we want, and the second index specifies the first slice we do not want. The return value is everything in between.

\begin{figure}[!ht]
\begin{center}
\includegraphics[width=5in]{images/slices.png}
\caption{Slicing.}
\label{fig.slices}
\end{center}
\end{figure}

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> sample_string = "Monty Python"
>>> sample_string[6:10]
'Pyth'
>>> sample_string[-12:-7]
'Monty'
>>> sample_string[3:]
'ty Python'
\end{minted}
\end{ejemplo}

Slice[i:j:k] selects and returns a new object of the same type containing all slices from i to j including slice[i] excluding slice[j] but this time taking into consideration the value of k called step size.

All index values of a slice are optional, and the defaults values are the start of the sequence, the last item in the sequence, and a step size of one where it cannot be zero. A negative step size can reverse the order of the output result.

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> sample_string[6:10:1]
'Pyth'
>>> sample_string[-12:-7:1]
'Monty'
>>> sample_string[::-1]
'nohtyP ytnoM'
\end{minted}
\end{ejemplo}

Most of the sequences can be sorted by the the {\em sorted()} function. Additionally {\em any()} and {\em all()} take sequences and return {\em True} if any or all of the elements are true respectively.

\subsection{Multi value assignments}
\label{multi-value}
Assigning multiple values at once in Python is very useful. It is possible to extract the sequence of values into individual values and further store the unique values in separate variables. 

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> vals = ('china', 911, True)
>>> type(vals)
tuple
>>> (c,n,b)= vals
>>> type(c)
str
>>> type(n)
int
>>> print(c)
china
\end{minted}
\end{ejemplo}

The built-in {\em range()} function constructs a sequence of integers.

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> (mon,tue,wed,thu,fri,sat,sun) = range(7)
>>> type(mon)
int
>>> print(mon)
0
>>> print(tue)
1
\end{minted}
\end{ejemplo}

\section{Sets}
\label{set-types}
Sets store {\bf unordered} and {\bf unique} values. Standard set of operations like union, intersection, and set difference can be performed on sets. They have {\bf no index} and unlike tuples and lists, sets can have {\bf no duplicate} data. They {\bf do not support} indexing or slicing.

Sets are two types, namely, sets and frozensets.

\begin{tcolorbox}[tabularx={X||X||X},title= {\white Summary of sequences}, beamer]
SET & TYPE & SYNTAX 		   \\\hline\hline
Sets & Mutable &   set()	   \\\hline
Froozensets & Immutable &  frozenset() 
\end{tcolorbox}

The mutable sets can be created by the built-in {\em set()} constructor or by putting the values in curly brackets ({}). They can be modified afterward by several methods, such as {\em add()}.

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> frameworks = {"tensorflow","caffe","tiny-dnn","pytorch"}
>>> type (frameworks)
<class 'set'>
>>> frameworks.add("chainer")
>>> frameworks
{'tensorflow', 'chainer', 'caffe', 'pytorch', 'tiny-dnn'}
\end{minted}
\end{ejemplo}

Sets are unordered and don't remember the original order that was used to create it. Items added to sets would not remember the order of their addition.

We can create a set out of a list. A single set can contain values of any datatype. 

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
sample_list = ['my', 'memory', 'is', 'new', 'neuro', 'memory']
sample_set = set(sample_list)
sample_set        
# Output: {'is', 'memory', 'my', 'neuro', 'new'}
\end{minted}
\end{ejemplo}

Frozenset represents an immutable set. They are created by the built-in {\em frozenset()} constructor. 

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> vehicles = set(["cars", "buses","trucks"])
>>> vehicles.add("bike")
>>> vehicles        
{'bike', 'buses', 'cars', 'trucks'}

>>> vehicles_frozen = frozenset(["cars", "buses","trucks"])
>>> vehicles_frozen.add("bike")    
Error: no attribute 'add'
\end{minted}
\end{ejemplo}

As the frozenset is immutable and hashable, it can be used as an element of another set, or as a dictionary key. 

\section{Mappings}
\label{mappings}
A mapping maps immutable values to arbitrary values. The complete mapping is considered a {\bf mutable} object.

A dictionary is a mapping that consists of an {\bf unordered} set of comma-separated list of key:value pairs within braces, for example: \{'name': '1911', 'subject': 'alien'\}. As with a typical dictionary in real-life, in Python, the word we are looking up is called a {\bf 'key'}, and the meaning is the {\bf 'value'}. 

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> sample_dict = {'city': 'Alpharetta', 'pincode': 30004}
>>> sample_dict        
{'pincode': 30004, 'city': 'Alpharetta'}
\end{minted}
\end{ejemplo}

Dictionary keys must be unique, immutable and {\bf no duplicate keys} are allowed in a dictionary.  Dictionary keys cannot exist in isolation, and each key must have a value defined. Assignment of new value to an existing key replaces the old value. 

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> len(sample_dict)        
2
>>> sample_dict['pincode']    
30004
>>> sample_dict['pincode'] = 30009
>>> sample_dict['pincode']
30009
\end{minted}
\end{ejemplo}

The built-in function {\em len()} returns the number of items in a mapping. The subscript notation dictionary[key] selects the item indexed by key value.

Note: Keys in the dictionary are {\bf case-sensitive} and dictionaries do not support slicing. 

Dictionaries support various objects like integers, strings, and even other dictionaries. Values in the same dictionary can be mixed and matched with different types. 

Tuples which contain immutable objects like strings, numbers can be used as dictionary keys. Lists cannot be employed as dictionary keys, as they are not immutable.

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> storage = {1000: ['KB', 'MB', 'GB', 'TB'],
      1024: ['KiB', 'MiB', 'GiB', 'TiB']}
>>> storage[1000][3]                
TB
\end{minted}
\end{ejemplo}

\section{Conditions}

\subsection{If statement}
\label{if-statement}

In an {\em if} selection statement, the {\em elif} and {\em else} sections are optional and an arbitrary number of {\em elif} sections can be included but only a single {\em else} clause can exist.

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> age=8
>>> if age < 9:
>>>     print("Kid")
>>> elif age > 59:
>>>     print("Old")
>>> else: print("Young")    
Kid
\end{minted}
\end{ejemplo}

\subsection{Conditional expression selector}
\label{conditional-expression-selector}
Python supports what is called as a conditional expression selector.

\begin{align*}
  <value>  if  <expression>  else  <another value>
\end{align*}

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> is_fat = True
>>> state = "fat" if is_fat else "not fat"
>>> state
'fat'
\end{minted}
\end{ejemplo}

More traditionally it can be written as following:
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
if expression:
    value
else: 
    another-value
\end{minted}

Python also includes a very useful shortcut that combines comparisons.

\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
if lower-limit < value < upper-limit:
    statement
\end{minted}


\section{Loops}

\subsection{While statement}
\label{while-statement}
The {\em while} statement is one of the several alternatives available for iteration.

\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
while boolean-expression:
    block
else: 
    another-block
\end{minted}

The {\em else} section is optional and gets executed only when the boolean expression is false. It is not executed when the loop exists because of {\em break} or {\em return} statement.

\subsection{For statement}
\label{for-statement}
The {\em for} loop iterates through sequences such as a list, tuple or a function that returns a collection of values such as {\em range()}.

\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
for item in <iterable>:
    block
else: 
    anotherblock
\end{minted}

The {\em else} section gets executed when all the iterations are complete. It is not executed when the loop exists because of {\em break} or {\em return} statement.

\subsection{Enumerate}
\label{enumerate}
The {\em enumerate()} function is an in-built function used particularly with {\em for} loops and returns the enumerate object. 

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> countries = ['uk', 'us', 'canada', 'china']
>>> list(enumerate(countries))
[(0, 'uk'), (1, 'us'), (2, 'canada'), (3, 'china')]
\end{minted}
\end{ejemplo}

Notice the different versions of {\em for} loop return the same set of values each time.

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> for index, item in enumerate(countries, start = 1):
>>>    print(index, item)
1 uk
2 us
3 canada
4 china

>>> for index, item in enumerate(countries, 1):
>>>     print(index, item)
1 uk
2 us
3 canada
4 china

>>> for index, item in enumerate(countries):
>>>     print(index, item)
0 uk
1 us
2 canada
3 china
\end{minted}
\end{ejemplo}

\subsection{Comprehensions}
\label{comprehensions}
Python comprehensions are a sequence of elements constructed syntactically when a given condition is satisfied from an iterable. Python comprehensions are of three types namely:

\begin{enumerate}
\item List comprehensions,
\item Set comprehensions and
\item Dictionary comprehensions.
\end{enumerate}

Comprehensions are specific applications of a more general form of loops known as generator expressions that can be used anywhere, a sequence of values is required. The syntax is as follows.
\begin{align*}
 <result> for <variable> in <iterable> if <filter> 
\end{align*}

The {\em for} loop is executed first, and filter conditions are checked next followed by the execution of the resultant expression on the left.

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> numbers = [0, 1, 2, 3, 4]
>>> squares = [n ** 2 for n in numbers]
>>> squares
[0, 1, 4, 9, 16]

>>> even_squares = [n ** 2 for n in numbers if n % 2 == 0]
>>> even_squares
[0, 4, 16]
\end{minted}
\end{ejemplo}

Generator expressions can lead to significant savings in memory usage as they do not generate the entire data at once.

\section{Error handling}
\label{error-handling}
Python supports a simple syntax for exception handling. Along with the {\em try} section, atleast one {\em except} or {\em finally} section must exist, rest are considered optional. Multiple {\em except} sections can co-exist, but only one {\em else} or {\em finally} section is possible. The {\em as} syntax which is part of the except line is optional.

\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
try:
      statements
except <type-of-error> as <exception-object>:
      statement to handle error
else:
      statements
finally:
      final code 
\end{minted}

Exceptions do not need to be always called by the interpreter; rather they can be raised manually from user's code using the {\em raise} syntax. In addition to inbuilt exception types, it is also possible to define custom error handling classes.

\section{Context management}
\label{context-management}
Context management in Python frees resources automatically after use. Context management often eliminates the need to use error handling constructs.

In-built context management implementations are available in Python. However, it is possible to define custom context management classes. 

Context manager can be invoked using the {\em with} statement.

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> import os
>>> print(os.getcwd())  
/home/runner
>>> with open("caffe.proto", "w") as new_file:
>>>     print("OpenCL", "start", end="EOL", sep="-", file=new_file)
\end{minted}
\end{ejemplo}

Python uses context management to close the file automatically, thus taking care of resource management, it prints the "OpenCL-startEOL" message specified as two strings, to a file named caffe.proto using a hyphen separator and the string "EOL" as an end marker.

Context managers can also be nested.

\section{Input output}
\label{input-output}

The {\em input()} function communicates with the user and reads values typed by the user in response to a given on?screen prompt.

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> age = input("Please enter your age: ")
Please enter your age: 35
>>> age
'35'
\end{minted}
\end{ejemplo}

Along with on-screen input and output, operations on files are central to the use of Python in production environments.

\begin{align*}
file\_object\_name = open(file\_name, access\_mode, buffering)
\end{align*}

Access modes for opening files include read, write, and append. If buffering is 0, no buffering takes place, for a value of 1, line buffering takes place. Any value greater than one is the actual buffer size.

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> import os
>>> with open("caffe.proto", "w",2) as new_file:
>>>        new_file.write("Caffe with OpenCL is just great.")
>>>     print(new_file.name,new_file.closed,new_file.mode)
caffe.proto False w
>>> print(new_file.closed)
True
>>> os.listdir()
['.ipynb_checkpoints',
 'caffe.proto',
 'dump.txt',
 'Untitled.ipynb']
\end{minted}
\end{ejemplo}

An opened file is read by the {\em read()}, {\em readlines()}, or {\em readline()} functions line-by-line.

A file object is an iterable object, and it can be used with a for loop, without requiring the need for any of the read methods. Hence the following pattern can be utilized for reading the lines in a file.

\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
  with open(file-name, mode) as file-object:
       for line in file-object:
           process line
\end{minted}

The {\em write()} or {\em writelines()} methods, can be used for working with writable file objects.  There is no method called writeline() available for writing single lines. 

The {\em rw} mode, may require pointing to a particular position in the file to overwrite any existing data. The current position in the file can be found using the {\em tell()} method. It then can be used in combination with a {\em seek()} method to go to a particular position. The {\em seek()} method has many modes for calculating the position in a file, and the default value is the offset from the start of the file. 

\section{Functions}
\label{functions}
In python functions are defined using the {\em def} keyboard.

\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
def function-name(param-1,param-2,...):
    function-block
\end{minted}

Functions in Python always return a {\em None} value by default unless explicitly a return value is mentioned using the {\em return} statement.

\subsection{Generator function}
\label{generator-functions}
Generator functions involve the use of the {\em yield} statement instead of the {\em return} statement. Unlike the {\em return} statement, the {\em yield} statement preserves data and doesn't immediately throw it away. Hence, generator functions (or simply generators) can be used inside an iterator.

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> def razor_numbers():
>>>     yield 1
>>>     yield 9
>>>     yield 1
>>>     yield "1"

>>> for i in razor_numbers():
>>>     print(i)
1
9
1
1
\end{minted}
\end{ejemplo}

There can be multiple {\em yield} statements within a single function. 

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> def simple_sum(max):
>>>     result = 0
>>>     while result <= max:
>>>         yield result
>>>         result += 1

>>> for x in simple_sum(10):
>>>     print(x)
0
1
2
3
4
5
6
7
8
9
10
\end{minted}
\end{ejemplo}

\subsection{Lambda function}
\label{lamda-function}
Lambda functions are used when there is a requirement for a nameless function for a short period of time. 

\begin{align*}
   lambda <param1, param2, ...,paramN> : <expression> 
\end{align*}

Lambda functions can be used along with built-in functions like {\em filter()}, {\em map()}. Note that a lambda function should only be written in one line.

Note that Lambda functions cannot have more than one 'expression,' meaning they can only be defined in one line.

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> square=lambda x: x**2
>>>     print(square(5))
25

>>> def square(x):
>>>    return x ** 2
>>> print(square(5))
25
\end{minted}
\end{ejemplo}

Lambda functions resemble a normal function. They are often handy when a lot of small features are needed but only once.

\section{Classes and objects}
\label{classes-objects}
A class is like a template. A good analogy for understanding a class is comparing it with a blank application form. The blank application form itself is a class, a template for filling in different data. The filled applications with data are thus instances of the class or objects of the class. In addition to filled data, the objects or instances inherit the methods of the class.

Just like functions, classes do not require any separate syntax definition except for the usage of the keyword {\em class}.

\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
class class_name:
    <statement1>
    .
    .
    <statementN>
    
class application:
    pass
\end{minted}

The class named application does not inherit anything from other classes. In general, there needs to be something in the class definition, hence the {\em pass} statement. It is a reserved keyword in Python that does nothing.

\subsection{Instance objects and instance methods}
\label{instance-objects}
A new parent class called vehicle is defined with one variable and one method. {\em self} is a parameter common to all class methods. 

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> class vehicle:
>>>     number_of_wheels = 4    
>>>     def sound_horn(self):
>>>         print("beep")
\end{minted}
\end{ejemplo}

In general, a function is floating free, unencumbered whereas a class (instance) method has to be aware of the parent (and parent properties) so {\em self} is a way of passing the method a reference to the parent class. The jeep object is a new {\bf instance} inherited from the vehicle parent class. Note that Python adds the {\em self} argument automatically when calling the methods.

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> jeep = vehicle()
>>> print(jeep.number_of_wheels)
4
>>> jeep.sound_horn()
beep
\end{minted}
\end{ejemplo}

Static methods do not have access to self. Static methods work independently of the class instance. Unlike class instances, static methods have no self-parameter.

Sounds are the same for all vehicles. The sound method is hence defined using the {\em @staticmethod} decorator.

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> class vehicle:
>>>     number_of_wheels = 4 
>>>     @staticmethod
>>>     def sound\_horn():
>>>         print("beep")
\end{minted}
\end{ejemplo}

Two instances assigned to each other refer to the same class instance like pointers in other languages, where instance\_a=instance\_b, means that the instance\_a is pointing to instance\_b.

\subsection{Class variables and instance variables}
\label{instance-variables}

Class variables get shared among all instances of the class. Instance variables are unique to each instance of the class.

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> class vehicle:
>>>     number_of_wheels = 4    
>>>     def sound_horn(self):
>>>         print("beep")        
>>>     def vehicle_name(self,name):
>>>         self.name = name
\end{minted}
\end{ejemplo}

All instances share the class variable number\_of\_wheels. 

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> sports = vehicle()
>>> normal = vehicle()
>>> sports.number_of_wheels
4
>>> normal.number_of_wheels
4
\end{minted}
\end{ejemplo}

The instance variable name is unique to each instance.

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> sports.vehicle_name("Ferrari")
>>> normal.vehicle_name("non-ferrari")
>>> sports.name
'Ferrari'
>>> normal.name
'non-ferrari'
\end{minted}
\end{ejemplo}

\subsection{Private variables}
\label{private-variables}
Variables specified by a single underscore before a name are private. It is more a convention than a rule so that the coder knows that a name starting with \_ is for internal use.

\subsection{Special methods}
\label{special-methods}

A name followed by the double underscore is not a convention but has a specific meaning to the Python interpreter. The identifiers of the form \_\_calculate (at least two leading underscores, at most one trailing underscore) are replaced with \_classname\_\_calculate, where the class name is the current class name with leading underscore(s) stripped.

Special method names have double underscore before and after them, and Python invokes them to perform certain useful functions. Some of them include the \_\_new\_\_(), \_\_init\_\_(), \_\_del\_\_(), and \_\_str\_\_() methods. All signified by the use of double underscores.

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> class shape:
>>>     def __init__(self, a, b):
>>>         self.a = a
>>>         self.b = b
>>>            print("init called")
>>>     def area(self):
>>>         return self.a * self.b
\end{minted}
\end{ejemplo}

The method call to \_\_init\_\_ is immediate and automatic after the creation of the triangle instance. It is used to initialize an instance.

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> triangle = shape (1,1)
init called
>>> triangle.area()
1
\end{minted}
\end{ejemplo}

For constructors, the \_\_new\_\_() method is used.

\subsection{Inheritance}
\label{inheritance}
Inheritance is the process by which a child class derives the data and behavior of a parent class. Such a class is defined using the class keyword followed by the class name and a parenthesized list of parent classes. The child class can also override data members and methods from the parent class.

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> class main_class:
>>>    main_attribute = 1911
>>>    def __init__(self):
>>>       print("Calling main class init method")
>>>   def main_method(self):
>>>       print('Calling main class method')
>>>   def set_attribute(self, attribute):
>>>       main_class.main_attribute = attribute
>>>   def get_attribute(self):
>>>       print("Main class attribute :", main_class.main_attribute)

>>> class child_class(main_class):
>>>    def __init__(self):
>>>       print("Calling child class init method")
>>>    def child_method(self):
>>>       print('Calling child class method')

>>> c1 = child_class()
Calling child class init method
>>> c1.child_method()
Calling child class method

>>> c1.main_method()
Calling main class method
>>> c1.set_attribute(200)      
>>> c1.get_attribute()
Main class attribute : 200
\end{minted}
\end{ejemplo}

If and when required, {\bf overriding} the main class methods is possible for implementing a special or a different functionality in the child class.

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> class main_class:        
>>>    def main_method(self):
>>>       print('Calling main class method')

>>> class child_class(main_class):    
>>>    def main_method(self):
>>>       print('Calling child class method')
\end{minted}
\end{ejemplo}

The {\em issubclass(child, parent)} function returns true if the child class is a subclass of the parent class. The {\em isinstance(object, class)} function returns true if the class object is created from an instance of the class. In Python 3 each class derives from the root {\em object} class even when not indicated explicitly.

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> c1 = child_class()            
>>> c1.main_method()
Calling child class method
>>> issubclass(child_class, main_class)
True
>>> isinstance(c1,child_class)
True
\end{minted}
\end{ejemplo}

\subsection{Operator overloading}
Operator overloading is supported via a set of special methods including: \_\_ add \_\_ (), \_\_ sub \_\_ (), \_\_ mul \_\_ (), \_\_ div \_\_ (), and so on. The following example shows the addition of vectors, notice how the + sign is overloaded to perform addition of two vector classes.

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> class vector:
>>>    def __init__(self, x, y):
>>>       self.x = x
>>>       self.y = y

>>>    def __str__(self):
>>>       return 'vector (%d, %d)' % (self.x, self.y)
   
>>>    def __add__(self,var):
>>>       return vector(self.x + var.x, self.y + var.y)

>>> vec1 = vector(2,10)
>>> vec2 = vector(5,-2)
>>> print(vec1 + vec2)
vector (7, 8)
\end{minted}
\end{ejemplo}

\subsection{Multiple inheritance}
\label{multiple-inheritance}
A child class can derive from multiple parent classes.

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> class A:        
>>>     pass
>>> class B:         
>>>     pass
>>> class C(A, B):   
>>>     pass
\end{minted}
\end{ejemplo}

In multiple inheritances {\em super()} is like a shortcut that allows access to the parent class of a child class, without having to know or type the parent class name; {\em super()} just calls the parent function implicitly. The {\em super()} keyword helps to ensure that the proper method resolution order (MRO) is followed when moving up the inheritance tree.

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> class A(object):
>>>     def foo(self):
>>>         print('A')
 
>>> class B(A):
>>>     def foo(self):
>>>         print('B')
>>>         super().foo()
 
>>> class C(A):
>>>     def foo(self):
>>>         print('C')
>>>         super().foo()
 
>>> class D(B,C):
>>>     def foo(self):
>>>         print('D')
>>>         super().foo()
>>>         print(D.__mro__)
 
>>> d1 = D()
>>> d1.foo()
D
B
C
A
(<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, 
<class '__main__.A'>, <class 'object'>)
\end{minted}
\end{ejemplo}

The value "A" is only printed once even after two classes derive from it. It is due to the method resolution order (MRO) that is inherent in the new style classes of Python 3. The function to print D.\_\_mro\_\_ underneath the super call in class D's foo function outputs method resolution order (MRO). The same is written in Python 2.x style as follows.

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> class A(object):
>>>     def foo(self):
>>>         print('A')
 
>>> class B(A):
>>>     def foo(self):
>>>         print('B')
>>>         super(B, self).foo()
 
>>> class C(A):
>>>     def foo(self):
>>>         print('C')
>>>         super(C, self).foo()
 
>>> class D(B,C):
>>>     def foo(self):
>>>         print('D')
>>>         super(D, self).foo()
>>>         print(D.__mro__)
 
>>> d1 = D()
>>> d1.foo()
\end{minted}
\end{ejemplo}

If two parents are on the same level of inheritance (direct parents) and the resolution of the super method is not very clear. It is called the diamond inheritance problem.

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> class X():
>>>     def who_am_i(self):
>>>         print("I am a X")
    
>>> class Y():
>>>     def who_am_i(self):
>>>         print("I am a Y")
    
>>> class A(X, Y):
>>>     def who_am_i(self):
>>>         print("I am a A")
    
>>> class B(Y, X):
>>>      def who_am_i(self):
>>>          print("I am a B")

>>> class F (A, B):
>>>     def who_am_i(self):
>>>         print("I am a F")
 Cannot create a consistent method resolution order (MRO) for bases Y, X
\end{minted}
\end{ejemplo}

\subsection{Abstract methods}
\label{abstract-methods}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
from abc import abstractmethod
@abstractmethod
    def weapon\_type():
        pass
\end{minted}

Notice how the weapon\_type is declared an abstract method using the decorator. They may not provide any implementation. However, any class inheriting should implement and override the abstract methods. An exception may raise otherwise.

\subsection{Decorators}
\label{decorators}
The {\em @} symbol decorates classes and functions. Decorating alters a function or class object once it is constructed but before it is bound to its name.

Two things are hidden behind the name "decorator", one is the function which does the work of decorating, performing the real job, and the other one is the expression adhering to the decorator syntax, which is the at-symbol and the name of the decorating function.

Fundamentally, everything is an object in Python and decorators build on it. A function assigned to a variable may pass to another function or return from another function. The decorated syntax for functions uses @ symbol before the beginning of the function.

\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
@decorator
def decorator\_function():
    print("decorator")
\end{minted}

Decorators apply not just to Python functions but also to Python classes and class methods. A function squared is passed to decorator named identity. Once inside the identity decorator, function squared is referenced as object input\_function. The input\_function is then used to calculate and display the required result. 

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> def identity(input_function):
>>>     result = input_function(5)
>>>     print("The result square is :"+ str(result))

>>> @identity
>>> def squared(value):
>>>     return value*value
The result square is :25    
\end{minted}
\end{ejemplo}

\subsection{Iterators}
\label{iterators}
Comprehensions, generators are considered very simple forms of iterators. Iterators in Python are simply objects which are iterated on. They can return data, one element at a time. Iterators have two special methods \_\_iter\_\_() and \_\_next\_\_().

The iter function returns the iterator from say list, tuple or string.

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> st1 = 'cnc'
>>> it1 = iter(st1)
>>> print(next(it1))
'c'
>>> print(next(it1))
'n'
>>> print(next(it1))
'c'
\end{minted}
\end{ejemplo}

\section{Modules and packages}
\label{modules-packages}
\noindent A package is essentially a folder full of modules. The folder must contain a file called \_\_init\_\_.py, which may be empty.

\begin{ejemplo}
\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
>>> import module
>>> import module as alias
>>> import first_module, second_module, third_module
>>> from module import object
>>> from module import object as alias
>>> from module import first_object, second_object, third_object
>>> from module import *
>>> import os.path 
>>> import os.path as path-new 
\end{minted}
\end{ejemplo}

A common requirement when creating a package is to have a set of functions or data shared between all the included modules. By putting the common code into a module file called, common.py at the top level of the package and having all of the other modules import common, date sharing is achieved.

In practice, for a nontrivial program, most function and class definitions exist in module files and are included in the imports.  

This leaves a short section of driver code to start the application. Often this code is placed in a function, and the function is called main(), but that is purely a nod to programming convention, not a requirement of Python.

Finally this main function needs to be called. This is often done within a special if statement at the end of the main script. It looks like this: 

\begin{minted}[mathescape, frame=none, fontseries=b, rulecolor=\color{gray}]{python}
  if __name__ == "__main__":
	  main()
\end{minted}

When Python detects that a program file is being executed by the interpreter rather than imported as a module, it sets the special variable \_\_name\_\_ (note the double underscores on either side) to "\_\_main\_\_". 

This means that any code inside this if block is executed only when the script is run as the main program and not when the file is imported into another program. If the file is only ever expected to be used as a module, the main() function may be replaced by a test() function that executes a set of unit tests. Again, the actual name used is of no significance to python.


%----------------------------------------------------------------------------------------
%	Chapter 2
%----------------------------------------------------------------------------------------
\chapter{Python Scientific Computing}

%%\input{AccionesSesionLaTeX.tex}
\section{The nature of data}
Data is ultimately represented as numbers in computing. A vector is a series of numbers. If you notice objects around us, a list of important features are used to describe, say a dog. Such an ordered list of those important features is called a {\bf feature vector}. A feature vector is thus just a vector that contains information describing an object's important characteristics.

Vectors are generally flat and have very simple structure. While modeling the world surrounding us, each object can have a very large feature vector and a dataset of these objects can have many thousands of feature vectors. 

A {\bf matrix} is then a very concise representation of a list of vectors, where each {\bf column} of a matrix is a feature vector.


\section{Data representation using Numpy}

\section{Numpy array creation}

\section{Numpy data types}

\section{Numpy operations}

\subsection{Indexing}

\subsection{Slicing}

\subsection{Iterating arrays}

\subsection{Arithematic operators}

\subsection{Matrix operators}

\subsection{Increment decrement operators}

\subsection{Universal operations}

\subsection{Aggregate operations}

\subsection{Conditions and boolean arrays}

\subsection{Shape manipulation}

\subsection{Joining arrays}

\subsection{Splitting arrays}

\subsection{Copy and views}

\subsection{Vectorization}

\subsection{Broadcasting}

\subsection{Structured arrays}

\subsection{Reading and Writing data}

files with tabular data


\section{Matplotlib}

%----------------------------------------------------------------------------------------
%	Chapter 3
%----------------------------------------------------------------------------------------
% \clearpage
\chapter{Introduction to ANNs}

%%\input{EscrituraTextoNormal.tex}

%----------------------------------------------------------------------------------------
%	Chapter 4
%----------------------------------------------------------------------------------------
\chapter{Introduction to CNNs}
% \clearpage
%%\input{TextoModoMatematico.tex}
% 
%----------------------------------------------------------------------------------------
%	Chapter 5
%----------------------------------------------------------------------------------------
\chapter{Caffe Installation and Configuration}
% \clearpage
%%\input{Tablas.tex}
% 
%----------------------------------------------------------------------------------------
%	Chapter 6
%----------------------------------------------------------------------------------------
\chapter{Inside the Caffe Framework}
% \clearpage
%\input{aInsertarFiguras.tex}
% 

%----------------------------------------------------------------------------------------
%	Chapter 7
%----------------------------------------------------------------------------------------
\chapter{Understanding the Caffe Architecture}
% \clearpage
%\input{edicionFiguras.tex}
% 


%----------------------------------------------------------------------------------------
%	Chapter 8
%----------------------------------------------------------------------------------------
\chapter{Exploring and Preparing Data}
% \clearpage
%%\input{HacerBibliografia.tex}
% 

%----------------------------------------------------------------------------------------
%	Chapter 9
%----------------------------------------------------------------------------------------
\chapter{Modeling Deep Neural Networks}
% \clearpage
%%\input{DisenoEditorial.tex}
% 

%----------------------------------------------------------------------------------------
%	Chapter 10
%----------------------------------------------------------------------------------------

\chapter{Introduction to RNNs}
% \clearpage
%%\input{cajas.tex}
% 


%----------------------------------------------------------------------------------------
%	Chapter 11
%----------------------------------------------------------------------------------------
\chapter{Introduction to SOMs}
% \clearpage
%\input{PersonalizarElDocumento.tex}
% 




%----------------------------------------------------------------------------------------
%	Chapter 12
%----------------------------------------------------------------------------------------
\chapter{Introduction to Auto Encoders}
% \clearpage
% \input{Beamer.tex}
% 

%----------------------------------------------------------------------------------------
%	Chapter 13
%----------------------------------------------------------------------------------------
\chapter{Real Time Inference}
% \clearpage
% \input{PosterYBrochures.tex}
% 

%----------------------------------------------------------------------------------------
%	Chapter 14
%----------------------------------------------------------------------------------------
\chapter{Training using Transfer Learning}
% \clearpage
% \input{LaTeXInternet.tex}
% 

%----------------------------------------------------------------------------------------
%	Chapter 15
%----------------------------------------------------------------------------------------
\chapter{Quantization and Compression of Networks}
% \clearpage
% \input{LaTeXInternet.tex}
% 

%----------------------------------------------------------------------------------------
%	Chapter 16
%----------------------------------------------------------------------------------------
\chapter{Caffe in Production}
% \clearpage
% \input{LaTeXInternet.tex}
%

 

%----------------------------------------------------------------------------------------
%	BibliografÃ­a
%----------------------------------------------------------------------------------------
 \clearpage
\thispagestyle{empty}
\addcontentsline{toc}{schapter}{\addvspace{30pt}\large\sc\bfseries BibliografÃ­a \color{azulF}\hfill   }

\begin{thebibliography}{AAAAAA}
  \bibitem{abbot} S. Abbot. "{\it Understanding Analysis}". Springer. 2000.\\
  
  \bibitem{Andrew} Andrew Mertz y  William Slough. {\it "Beamer by Example"}.
  En \url{http://www.tug.org/pracjourn/2005-4/mertz/mertz.pdf}
  


\bibitem{} Joseph Wright. "From \verb+\newcommand+ to \verb+\NewDocumentCommand+
with xparse".  \url{https://www.tug.org/TUGboat/tb31-3/tb99wright.pdf}.
Consultada el 10 de Enero 2014.

\end{thebibliography}
% \clearpage
%\input{Bibliografia}
% 

%----------------------------------------------------------------------------------------
%	ApÃ©ndices
%----------------------------------------------------------------------------------------

% \input{apendiceAgregarPaquetesNuevos.tex}
% \input{Habilitarshellescape.tex}
% \input{ApendiceA.tex}%insalar una distribuciÃ³n y un editor
% \input{softwareadicional}
% \input{massoftwareadicional}
% \input{ApendiceB.tex}
% \input{IndiceComun.tex}
% 
% %%%%%%%%%%% ImprimirIndice
%\printindex

\end{document}
