\section{Structure de données}

Choisir la bonne structure de données est une phase importante dans le
développement d'une application. En effet celle-ci va conditionner la
difficulté de mise en place de l'algorithme du point de vue du
développeur dans la conception de celui-ci avec une manipulation des
données plus ou moins aisée. L'utilisateur est aussi impacté par ce
choix autant pour la rapidité d'exécution que par la quantité de mémoire
nécessaire.

Il est important de prendre en compte lors de la conception de la
structure de données que la taille de la grille de sudoku doit pouvoir
varier afin de faire varier le nombre de possibilités offertes à
l'algorithme lors de la résolution et ainsi son temps d'exécution. 

À la suite d'un brainstorming avec l'ensemble de l'équipe, deux types de
structure de base sont ressortis:

\begin{itemize}
    \item[Tableau à 2 dimensions:] La première dimmension représentant
    les lignes et l'autre les colonnes de la grille de sudoku. \\
    L'intérêt d'une telle représentation permet un accès facilité à
    chaque case du jeu lors de la conception de l'algorithme. \\
    Le désavantage de celle-ci réside dans le fait que la mémoire
    allouée pour les différents tableaux n'est pas contigüe. Cela ne
    nous permet donc pas de bénéficier de l'optimisation faite par le
    processeur avec le chargement en cache suivant une
    localité spatiale.
    \item[Tableau simple dimension:] Un unique tableau contenant les
    différentes lignes de la grille de sudoku mises bout à bout.\\ 
    Par rapport à la représentation précédente, l'accès à une case
    spécifique est moins aisé. Cependant la puissance des langages
    orientés-objet permet de définir des accesseurs ce qui permet de
    passer outre cette difficulté. \\
    De plus une telle structure permet d'allouer une zone de mémoire
    contigüe et donc de profiter du mécanisme de cache avec localité
    spatiale du processeur.
\end{itemize}

Notre choix s'est donc porté sur une structure linéaire (tableau simple
dimension) que l'on représentera dans l'algorithme par une instance de la
classe de la librairie standard \emph{Vector}.

Lors du déroulement de l'algorithme, les différentes valeurs déterminées à
partir des contraintes doivent être stockées. Toujours dans l'optique de
profiter des optimisations dues à la localité spatiale, plutôt que
d'utiliser un ensemble de valeurs à part, les possibilités (domaines de valeurs) seront à la
suite les unes des autres formant ainsi un unique tableau. \\
Comme dans l'exemple ci-dessous, pour une grille de sudoku de 4x4, il y
aura 16 cases contenant elles mêmes 4 possibilités différentes. La
représentation en mémoire résultante sera alors un vecteur de 64
éléments. \\

\begin{figure}[h!]
  \centering
    \includegraphics[width=\textwidth]{mem-repr}
  \caption{Représentation d'une grille en mémoire}
\end{figure}

Chaque case de la grille de sudoku est ainsi représentée en mémoire
par le nombre de possibilités total que pourrait potentiellement avoir
la case (dans l'exemple, de 1 à 4 donc 4 cases). Cette solution a été
préférée par rapport à un sous ensemble car elle permet d'éviter d'avoir
à faire un grand nombre d'ajout et de suppression d'éléments et ainsi
d'allocations de mémoire (en plus de la localité spatiale).
Ces possibilités sont représentées dans le code par un booléen afin de
minimiser la taille en mémoire. En effet, le type \emph{bool} (au sein d'un \emph{Vector}) en C++
utilise un seul bit alors que le type \emph{int} tient lui sur 32 bits
ou 64 bits en fonction du processeur. Ainsi une grille de sudoku 4x4
nécessite seulement 64 bits de mémoire pour être stockée avec tous les
domaines possibles.

