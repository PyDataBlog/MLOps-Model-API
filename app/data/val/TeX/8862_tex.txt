%
% 1. process this file with pdflatex
% 2. remind to process it twice otherwise cross-references will be wrong
%
\documentclass[a4paper,12pt]{article}
%
% This is to create hyperlinks for index, URLs and citations
% (now we can use the command \url{...} to create URL with hyperlink)
% 
\usepackage[hyphens]{url}
\usepackage{listings}
\lstset{
    language=Bash,
    basicstyle=\ttfamily\small,
    aboveskip={1.0\baselineskip},
    belowskip={1.0\baselineskip},
    columns=fixed,
    extendedchars=true,
    %breaklines=true,
    breaklines=false,
    tabsize=4,
    prebreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
    frame=lines,
    showtabs=false,
    showspaces=false,
    showstringspaces=false,
    keywordstyle=\color[rgb]{0.627,0.126,0.941},
    commentstyle=\color[rgb]{0.133,0.545,0.133},
    stringstyle=\color[rgb]{01,0,0},
   % numbers=left,
    numberstyle=\small,
    stepnumber=1,
    numbersep=10pt,
    captionpos=t,
    escapeinside={\%*}{*)}
}

\usepackage{color}
\usepackage[a4paper,colorlinks=true,urlcolor=blue,citecolor=blue,linkcolor=blue,bookmarks=false]{hyperref}

%
% This allows inclusion of pictures.
% Create figures with PowerPoint and then export them individually
% in PDF, PNG, JPEG, or GIF format (in order of preference)
%
\usepackage[pdftex]{graphicx}
\DeclareGraphicsExtensions{.pdf,.png,.jpg,.gif}
%
% phantom space (for abbreviations)
%
\usepackage{xspace}
%
% Definition of margins
%
\usepackage[top=2cm,bottom=2cm,left=2cm,right=2cm]{geometry}
%
% This is needed if you write the report in Italian
%
\usepackage[latin1]{inputenc}% IMPORTANTE! usare codifica ISO-8859-1 per le lettere accentate
%
% Paragraph skip and indent
%
\setlength\parskip{\medskipamount}
\setlength\parindent{0pt}
%
% Frequently used abbreviations.
% - example1: \ie this is an example
% - example2: the \ipsec protocol
%
\def\eg{e.g.\xspace}
\def\ie{i.e.\xspace}
\def\ipsec{IPsec\xspace}
\def\myfig#1{Fig.~#1\xspace}
\def\mytab#1{Tab.~#1\xspace}
\def\rfc#1{RFC-#1\xspace}% usage: \rfc{1422}
\def\ms{M\$\xspace}
\begin{document}

\title{UEFI Secure Boot
\\
{\normalsize Instructions and Tutorials to UEFI Secure Boot}
}
\author{S. Zhao 
\\
% {\normalsize tutor: Jack-The-Ripper}
}
\date{February 2016}
\maketitle

\vfill

\rule{\textwidth}{1pt}

\tableofcontents

\rule{\textwidth}{1pt}

\vfill

\newpage



\section{UEFI Secure Boot}

Secure Boot is a booting feature of Unified Extensible Firmware Interface (UEFI). Secure Boot secures the boot process by preventing the loading of drivers or OS loaders that are not signed with an acceptable digital signature.

\subsection{Platform Keys (PK)}

PK establishes a trust relationship between the owner and firmware. The platform owner enrols the PKpub into the platform firmware. The owner later can use the PKpriv to change ownership or to enrol a KEK.

The PKpub must be stored in non-volatile storage which is tamper and delete resistant.

Authenticated PK variable can always be read but can only be written if: 
\begin{itemize}
    \item it is in user mode, the provided PKpub is signed with the current PKpriv or
    \item it is during setup mode, and the provided PKpub is signed with its PKpriv counterpart.
\end{itemize}

\subsection{Key Exchange Keys (KEK)}

KEKs establish a trust relationship between the operating system and the platform firmware. Each operating system and potentially, each 3rd party application which need to communicate with platform firmware (\ie Shim, boot loader), enrols a public key (KEKpub) into the platform firmware.

The public key must be stored in non-volatile storage which is tamper resistant.

KEKs can always be read but only be written if:  
\begin{itemize}
    \item it is in user mode, the provided variable data is signed with the current PKpriv or
    \item it is during setup mode.
\end{itemize}

\subsection{DB and DBX}
Signature database (DB) stores signatures or image hashes of UEFI applications, operating system loaders, and UEFI drivers that can be loaded.

The Revoked signatures database (DBX) stores no longer trusted/loadable signers or image hashes.

If one wants to build a custom kernel or load 3rd party kernel modules, he will need to disable Secure Boot, or setup his own keys and sign everything with them.

More introduction to PKs, KEKs, DB and DBX can be found on \cite{uefi_spec, ubuntu_sb, fedora_uefi_sb, suse_sb}.

\section{Secure Boot with Windows}
\subsection{Windows Hardware Certification Program}
Windows Hardware Certification Program is formerly known as Windows Logo Program. For a PC vendor to receive a certification/logo/sticker from Windows, his product must meet certain requirements \cite{windows_whcp}. 

Requirements concerning the Secure Boot are:
\begin{itemize}
    \item All client systems must support UEFI Secure Boot;
    \item Windows systems must ship with Secure Boot enabled (Windows Server excepted);
    \item A valid Microsoft provided KEK is included in the KEK database.
\end{itemize}

\subsection{Windows Secure Boot requirements}
As a conformance to the Windows Hardware Certification Program, on the non-ARM systems, the platform MUST implement the ability for a physically present user to select between two Secure Boot modes in firmware setup, \ie ``Custom'' and ``Standard''.

When in Custom Mode, a physically present user should be able to modify the signature database and the PK. And this could be implemented as first cleaning all Secure Boot databases (db, dbx, PK, KEK) and then enter Setup Mode.

Also, a physically present user MUST be allowed to disable Secure Boot via firmware setup without possession of PKpriv.

Sadly, nothing mentioned above is allowed on ARM Platforms.

\section{Wiping out Secure Boot keys}
On a ACER Aspire PC, press {\it Delete} when system boots up and enter ``BIOS Setup Utility'' and go to tab {\it Authentication} and set the options as indicated in the following Listing~\ref{list:wipe}.

\begin{lstlisting}[label={list:wipe},caption=Wipe out Secure Boot keys.]
Secure Boot 					    [Enabled]
Secure Boot Mode 				    [Custom]
Default Key Provisioning  		    [Disabled]
\end{lstlisting}

If {\it Default Key Provisioning} enabled, the factory default keys will be loaded after reboot.
Choose {\it Clear Secure Boot Keys}, pops up message {\it Deleting all variables will reset Platform to Setup Mode. Do you wish to proceed?}, choose {\it Yes}.


\section{Secure Boot with Linux} 
For the Linux distributors, they could either work with hardware vendors to have them endorse a Key and sign the boot loader with that key. Or using a boot loader signed by \ms, which seems to be the most simple and direct way to deal with Secure Boot.

But GRUB/GRUB2 is NOT signed by \ms, because: 
\begin{itemize}
    \item \ms refuses to sign binaries distributed under certain open source licenses (\ie GPLv3) and also
    \item Signing process involving third party (\ie \ms) slows down the developing process.
\end{itemize}

\subsection{Fedora Shim}
As a work-around, Fedora created the Shim program, which is a front-end to boot loaders, meaning that it loads the boot loader during the boot process \cite{fedora_shim}.

The shim program itself changes very rarely and signed by \ms.

It has public key build-in (\ie during the {\it make} process, specifying the public key file), which is used to verify the boot loader. And for the purpose of development flexibility, it allows to enrol additional keys (\ie Machine Owner Keys).  Boot loader calls back into Shim to verify the kernel signature.

\subsection{Machine Owner Keys (MOK)}
MOKs are managed by Shim. Note that they are not part of UEFI and are generated by users to sign EFI binaries.

MOKs empower users to run locally-compiled kernels and boot loaders which are delivered by the distribution maintainer.

MOKs are stored in Non-Volatile RAM (NVRAM).

However, it should be noted that, the ability to use MOKs creates risk, if the user is tricked to enrol a MOK generated by malware author.

\section{Embedded signatures}

The signatures for signing the UEFI executables (conforming to the PE format) are directly embedded inside executable itself.

Portable Executable (PE) format is a file format for executables, object code, DLLs and others used in 32-bit and 64-bit Windows operating systems. PE is a modified version of Unix Common Object File Format (COFF) \cite{wiki_uefi}.

Within the PE file header is an array of directory entries. Each of these entries points to interested places within the executable image. The fifth data directory entry contains a pointer to a list of certificates along with the length of the certificate areas. Each certificate may contain a digital signature used for validating the driver.

When embedding the signature in the file, the signing process can modify the certificate areas without affecting the file's hash value.

For windows, Authenticode is a digital signature format that is used to determine the origin and integrity of software binaries. Authenticode is based on Public-Key Cryptography Standards (PKCS) \#7 signed data and X.509 certificates to bind an Authenticode-signed binary to the identity of a software publisher. the PKCS \#7 structures include the PE file hash, the signer's X.509 certificates, and the signed hash \cite{windows_pe}.

\begin{center}
\includegraphics[trim=25mm 70mm 25mm 20mm]{PEsign.jpg}
\end{center}
See \cite{windows_pe} for more information about the PE file format.

\section{Singing Linux kernel for Secure Boot}

Create a NSS database: 
\begin{lstlisting}
[szhao@localhost Documents]$ mkdir db
[szhao@localhost Documents]$ cd db
[szhao@localhost db]$ ls
[szhao@localhost db]$ certutil -d $PWD -N
Enter a password which will be used to encrypt your keys.
The password should be at least 8 characters long,
and should contain at least one non-alphabetic character.

Enter new password: shilong.zhao
Re-enter password: shilong.zhao
\end{lstlisting}

Generate a self signed certificate: 

\begin{lstlisting}
efikeygen -d $PWD --ca --self-sign --nickname='My Fedora CA' \
--common-name='CN=ALT UEFI SB CA 2015,\
OU=Example Certification Authority,O=Example Linux Team,C=US' \
--url='http://example.org/UEFI' --serial=00
Enter Password or Pin for "NSS Certificate DB":shilong.zhao

\end{lstlisting}

Export the certificate and private key: 
\begin{lstlisting}
[szhao@localhost db]$ certutil -d $PWD -L -n "My Fedora CA" -r \
> fedora-ca.cer
[szhao@localhost db]$ ls
cert8.db fedora-ca.cer key3.db secmod.db
[szhao@localhost db]$ pk12util -d $PWD -o fedora-ca.p12 \
-n "My Fedora CA"
Enter Password or Pin for "NSS Certificate DB": shilong.zhao
Enter password for PKCS12 file: shilong.zhao
Re-enter password: shilong.zhao
pk12util: PKCS12 EXPORT SUCCESSFUL
[szhao@localhost db]$ certutil -d $PWD -L
Certificate Nickname                         Trust Attributes
                                            SSL,S/MIME,JAR/XPI
My Fedora CA                                     u,u,u

\end{lstlisting}

Copy kernel image to current directory: 

\begin{lstlisting}
[szhao@localhost db]$ cp /boot/vmlinuz-3.10.0-123.el7.x86_64 .
[szhao@localhost db]$ ls
cert8.db fedora-ca.cer fedora-ca.p12 key3.db secmod.db vmlinux
vmlinuz-3.10.0-123.el7.x86_64
\end{lstlisting}

Remove all previous signatures of the file to be signed: 
\begin{lstlisting}
[szhao@localhost db]$ pesign -i vmlinuz-3.10.0-123.el7.x86_64 -o \
vmlinuz-3.10.0-123.el7-unsigned.x86_64 -r -u 0
[szhao@localhost db]$ ls
cert8.db fedora-ca.p12 secmod.db vmlinuz-3.10.0-123.el7.x86_64
fedora-ca.cer key3.db vmlinuz-3.10.0-123.el7-unsigned.x86_64
\end{lstlisting}

Sign with your own certificate and show the result: 

\begin{lstlisting}
[szhao@localhost db]$ pesign -n $PWD -c "My Fedora CA" -s -i \
vmlinuz-3.10.0-123.el7-unsigned.x86_64 \
-o vmlinuz-3.10.0-123.el7-signed.x86-64
Enter Password or Pin for "NSS Certificate DB":shilong.zhao
[szhao@localhost db]$pesign -n $PWD -S -i \
vmlinuz-3.10.0-123.el7-signed.x86-64
---------------------------------------------
certificate address is 0x7fb45b86ff88
Content was not encrypted.
Content is detached; signature cannot be verified.
The signer s common name is ALT UEFI SB CA 2015
No signer email address.
Signing time: Wed Feb 03, 2016
There were certs or crls included.
---------------------------------------------
\end{lstlisting}

If the signatures are not cleaned, there could be multiple signatures available:

\begin{lstlisting}
[root@localhost sign_kernel_for_secure_book]# pesign -n certdb \
-c "shilong" -s -i centos/shim.efi -o centos/shim-signed.efi
Enter Password or Pin for "NSS Certificate DB":

[root@localhost sign_kernel_for_secure_book]# pesign -n certdb \
-S -i centos/shim-signed.efi
---------------------------------------------
certificate address is 0x7f1ba74beff8
Content was not encrypted.
Content is detached; signature cannot be verified.
The signer's common name is Microsoft Windows UEFI Driver Publisher
No signer email address.
No signing time included.
There were certs or crls included.
---------------------------------------------
certificate address is 0x7f1ba74c11e0
Content was not encrypted.
Content is detached; signature cannot be verified.
The signer's common name is Red Hat Inc.
No signer email address.
Signing time: Wed Jul 02, 2014
There were certs or crls included.
---------------------------------------------
certificate address is 0x7f1ba74c2160
Content was not encrypted.
Content is detached; signature cannot be verified.
The signer's common name is shilong
No signer email address.
Signing time: Tue Feb 02, 2016
There were certs or crls included.
---------------------------------------------
\end{lstlisting}

Here the message showing {\it content is detached}, because to verify the signature, the signature should first be extracted from the signed PE/COFF executable. And {\it pesign} itself cannot verify the signature (function not implemented), that's the reason why it's saying {\it signature cannot be verified};

For Ubuntu, there is another different tool chain called {\it sbtools} which includes {\it sbsign, sbverity}, etc. \cite{ubuntu_sb} is a complete guide of signing and verifying on Unbuntu. 

To verify Ubuntu signature on the signed kernel, you must first extract the signature from the kernel image, then use sbverify to verify the image with the detached signature:
\begin{lstlisting}
$ sbattach --detach /tmp/vmlinuz-3.5.0-27-generic.efi.signature \
  /boot/vmlinuz-3.5.0-27-generic.efi.signed
$ sbverify --cert ~/keys/canonical-master-signing-public-chain.pem --detached /tmp/vmlinuz-3.5.0-27-generic.efi.signature /boot/vmlinuz-3.5.0-27-generic.efi.signed

Signature verification OK
\end{lstlisting}

In the end you have to enrol the signing public key to the MOK database (or PK or KEK databases depending if you want to change also Shim and Grub).

For more information about how to sign a kernel image, reference \cite{altlinux_sb, fedora_selfsign, fedora_sb_card}.

\section{Sign Linux modules for Secure Boot}

Suppose there's already a compiled module named {\it hello.ko} and when trying to insert the module

\begin{lstlisting}
# insmod ./hello.ko
insmod: ERROR: could not insert module
./hello.ko: Required key not available
\end{lstlisting}
The same error will happen if you try to install Virtual Box \cite{fedora_vb, fedora_vb2}.

List current loaded keys:
\begin{lstlisting}
$ sudo keyctl list %:.system_keyring

\end{lstlisting}

Show keys loaded at boot time:
\begin{lstlisting}
$ dmesg | grep "EFI: Loaded cert"
\end{lstlisting}

Create public/private key pair, one good tutorial is \cite{ubuntu_ssl}. 

Import the public key into MOK list. You will be asked a password. Remember it, as it will be used to confirm the MOK request.
\begin{lstlisting}
$ sudo mokutil --import signing_key_pub.der
\end{lstlisting}

And reboot:
\begin{lstlisting}
$ reboot
\end{lstlisting}

At boot time, choose to enrol MOK, you will be requested for the key that you've typed when run `mokutil --import` after that system will reboot.

Check if import is successful
\begin{lstlisting}
$ sudo keyctl list %:.system_keyring
\end{lstlisting}

Now sign the module you want to insert:
\begin{lstlisting}
$ sudo /usr/src/kernels/`uname -r`/scripts/sign-file \
sha256 private_key.priv public_key.der my_module.ko
\end{lstlisting}

Now you should be able to load the modules \cite{redhat_sb}.

\begin{thebibliography}{99}

\bibitem{ubuntu_ssl} Ubuntu OpenSSL guide, \url{https://help.ubuntu.com/community/OpenSSL}

\bibitem{uefi_spec} UEFI specification 2.6, \url{http://www.uefi.org/sites/default/files/resources/UEFI%20Spec%202_6.pdf}

\bibitem{ubuntu_sb} Ubuntu Secure Boot, \url{https://wiki.ubuntu.com/SecurityTeam/SecureBoot}

\bibitem{fedora_uefi_sb} Fedora UEFI Secure Boot guide, \url{https://docs.fedoraproject.org/en-US/Fedora/18/html/UEFI_Secure_Boot_Guide/}

\bibitem{suse_sb} OpenSUSE Secure Boot guide, \url{https://www.suse.com/documentation/sled11/book_sle_admin/data/sec_uefi_secboot.html}

\bibitem{wiki_uefi} Wikipedia UEFI, \url{https://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface#UEFI_booting}

\bibitem{fedora_vb} Virtual Box fails on Fedora 19, \url{https://ask.fedoraproject.org/en/question/34470/virtual-box-on-fedora-19-fails-to-start-a-vm}

\bibitem{fedora_vb2} Virtual Box does not work on Fedora 20, \url{https://ask.fedoraproject.org/en/question/54155/virtualbox-not-working-on-fedora-20/}

\bibitem{windows_whcp} Windows Hardware Certification Program, \url{https://msdn.microsoft.com/en-us/library/windows/hardware/jj125187(v=vs.85).aspx}

\bibitem{redhat_sb}RedHat: signing kernel modules for secure boot, \url{https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/System_Administrators_Guide/sect-signing-kernel-modules-for-secure-boot.html}

\bibitem{windows_pe}Windows Authenticode Portable Executable Signature Format, \url{https://msdn.microsoft.com/en-us/windows/hardware/gg463180.aspx}

\bibitem{altlinux_sb} AltLinux Secure Boot PE signature How-to, \url{https://en.altlinux.org/UEFI_SecureBoot_mini-HOWTO#pesign}

\bibitem{fedora_selfsign}Fedora Secure Boot self signing, \url{https://fedoraproject.org/wiki/User:Pjones/SecureBootSelfSigning}

\bibitem{fedora_sb_card} Fedora Secure Boot smart card deployment, \url{https://fedoraproject.org/wiki/User:Pjones/SecureBootSmartCardDeployment}

\bibitem{suse_uefi} OpenSUSE UEFI image file sign tools, \url{https://en.opensuse.org/openSUSE:UEFI_Image_File_Sign_Tools#Related_articles}

\bibitem{fedora_shim} Fedora Shim, \url{https://docs.fedoraproject.org/en-US/Fedora/18/html/UEFI_Secure_Boot_Guide/sect-UEFI_Secure_Boot_Guide-Implementation_of_UEFI_Secure_Boot-Shim.html}



\end{thebibliography}

\end{document}
%
% Before delivering your report, don't forget to run a spell checker,
% such as aspell (with a UK-english dictionary)
%
