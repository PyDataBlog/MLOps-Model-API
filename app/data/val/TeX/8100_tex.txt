\chapter*{Unidirectional payment channel}
\addcontentsline{toc}{chapter}{Unidirectional payment channel}
\label{chap:unidir-pc}
Once we can create transactions and more important, scripts, in an easy way, we are prepared to design more complex scripts to create \textit{smart contracts}. This means in the following iteration of development, we have to provide new models that allow the generation of \textit{multisig} redeem scripts and other special conditions like \textit{time / expire} conditions or \textit{hashlock} contracts.

\section{Understanding a payment channel}
There's quite few information about payment channels over Bitcoin cryptocurrency online. We've used the knowledge our tutors have provided us and an article also referenced by them on the \textit{Bitcoin Magazine}\cite{bitcoin_magazine_bidir_pc:online}.\\\\
The basics of a payment channel is that there has to be a \textit{commitment} or \textit{funding} transaction to fund the channel and then make payments using those funds to generate transactions that share out the funds to give more funds to a party. After the channel operation, the channel must be closed with a \textit{closing} transaction. \\\\
The idea is that those transactions that share out the funds can end in the blockchain (maybe after some time) and be valid, so that both nodes trust the transaction and can verify them using their nodes. But they don't get broadcasted to the network until the close transaction sets the final funds distribution, relieving the blockchain from storing those transactions and allowing to increase the speed of transactions between these parties as they can be generated and validated in much less time than the time it takes a regular transaction to appear on the blockchain and confirmed. At the time they exchange the payment transaction (that distributes the channel funds) the payment has been done as they know, can validate theirselves and trust that if the transaction ends in the blockchain would be valid.\\\\
The key is how to create those transactions in order that no attacks are possible (even DoS) to the channel by any of the parties by using cryptography and game theory
\section{Modelling a unidirectional payment channel}
Knowing that a payment channel implies the creation of scripts that ensure no attacks on the channel are possible and the parties play fair, the effort and problem is to create those scripts to be functional and secure at the same time. To speed up development, we will evade the malleability issues and assume the same scripts can be coded using \code{SegWit}, but without implementing them using \code{SegWit} to save time.
\subsection{Schedule problems}
At the time of writing this document, the schedule said we should have implemented those three scripts and transactions to allow \textit{commitment}, \textit{payment} and channel \textit{closure}. Due to the lack of awareness and excess of optimism, we couldn't design all three scripts and we just modelled the first one. In the rescheduling chapter, more details are given about how the schedule has changed.
\subsection{Commitment}
The commitment for a unidirectional channel can be done in two ways: a transaction that funds the channel and expires at a certain time, returning the funds to the funder(s) to prevent the funds from being locked out if a party doesn't collaborate or create a simple funding transaction and after that a refund transaction that is valid after a certain time. The easiest is two create two transactions, but triggers problems of who signs the transaction first, trust problems in the timelapse the first transaction is created and signed and the refund is signed too, .... The first option requires a complex script but avoids such trust problems
\subsubsection{Single-transaction commitment script}
This transaction funding transaction must spend inputs owned by the parties of the channel and set the output conditions to a \textit{multisig} output that requires both parties signatures to create transactions on, therefore creating the channel, or to return the funds after a certain time in order to prevent fund-locking if a party doesn't collaborate.

Creating a \textit{multisig} script requires the comprehension of Bitcoin P2SH scripts, that as many low-level aspects of the Bitcoin subject, few information can be found over the Internet. Fortunately, a blogger and developer posted a really detailed and clear explanation about the subject\cite{soroushjp_multisig:online}

Our \code{scriptSig} proposal for the payment transaction (whose partial hash, just of the redeemScript piece, would define the first commitment transaction using a P2SH).
\begin{center}
\code{OP\_0 <sigA> <sigB> | OP\_2 <pubKeyA> <pubKeyB> OP\_2 OP\_NOTIF <time> OP\_CHECKLOCKTIMEVERIFY OP\_DROP <PubKeyFunder> OP\_CHECKSIG}
\end{center}
Where \code{<PubKeyFunder>} would be the public key of the channel funder (we assume an easy case where just one of the parties fund the channel). In the case the channel expires, the \code{scriptSig} would change to spend the funds from \code{OP\_0 <sigA> <sigB>} to \code{OP\_0 <sigFunder> OP\_DUP OP\_OVER} so the \textit{multisig} fails but doesn't triggers and error and then the time is verified and after that the signature is checked agains the funder public key. This script has been revised by one of our tutors and requires its implementation and further testing