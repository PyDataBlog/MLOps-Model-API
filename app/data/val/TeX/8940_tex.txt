\chapter{Design}

\section{Problem}
The problem can be broken down into three smaller parts suitable for
computational solutions.

\begin{enumerate}
  \item \textbf{Acquiring presence status} The change of states are acquired
        automatically without the intervention of the user. When the
        client\footnote{The client here is referring to the web
        browser/machine, not the user} connects to a Zulip server instance, we
        can acknowledge this as a transition of state for the user from offline
        to online.

        If the user is connected to the server but no user interaction is
        detected for a fixed period of time, we can implied that the user is
        idle and thus update their status to idle. This transition can be done
        both client side or server side, but since this is an implementation
        detail it will not be decided in the design section here.

        Finally, the online/idle-offline transition can be triggered by a
        WebSocket disconnection. It might also be worthwhile for the server to
        wait for a short length of time (a few seconds) before updating the
        presence table to accommodate unintentional network disconnection,
        usually caused by flaky wireless network connection.

  \item \textbf{Server side processing} This is where the so-called "business
        logic" is executed. This will include any server side logic, such as
        caching changes in user states, writing changes to database and
        broadcasting back to clients.

        Apart from the defined pipeline, the presence library also allows
        developers to write arbitrary defined functions to be executed in any
        stages of the presence system. This is achieved by registering
        functions onto \textit{hooks} that the presence library exposes. An
        example usage of this can be found in HPC, where new nodes can be
        brought online when some other nodes are found to be unresponsive.

  \item \textbf{Broadcasting presence list to client} This part involves
        updating all the online clients with the aggregated presence data.
        To do so, the presence system will push the updated presence list
        to all connected clients using the full-duplex WebSocket protocol.

        We will need to decide how the updated presence list is encoded for
        efficient transmission and how often updates are broadcasted.
\end{enumerate}

\section{Solution}
By doing various optimization to the design of a presence system, one can steer
away from the quadratic time complexity of the original "naive" solution.

When the client first connect to a Zulip server, a full page would be rendered
server side with the entire presence list embedded. After this initial load,
sending the presence information of all users is redundant and unnecessarily
saturate network bandwidths. It is possible instead to only transfer the
presence "delta" since the last update, this design is commonly found in
version control softwares (eg Git, mercurial, CVS, etc) where data is store as
differences (delta) between sequential data, unlike traditional file system
where data is stored in "blobs" containing complete files. Although this would
require additional computation from the client, the bandwidth and latency
reduced from this design outweighs the tiny processing overhead.

\blockquote{The data difference generated using delta encoding (otherwise known
as delta compression) will be called a \textbf{diff} from this point onwards.}

There is a potential problem associated with this design; transmitting data
over HTTP could be unreliable and there is no guarantee that the clients
receives every single updates. If a client misses an update, the next diff
received by the client would be incorrect and thus cause the client's presence
list to deviate from the server's single source of truth. The simple but naive
solution to this problem is to synchronize the client occasionally (say every
10 minutes) with a full presence list; however, the implication of this is that
clients' data could potentially be stale for up to \(10 - \text{update
interval}\) minutes, assuming that we want each interval to be fairly small. A
better solution would be to bundle a diff with the hash value of the latest
(full) presence list. A hash generated by a hash function maps arbitrary sized
data to a fixed size string, which is usually tiny, 160 bit in Git's case. This
allows the hash to be transmitted across the network with minimal network
usage. Upon receiving an update, the client would apply the new diff to their
existing list and calculate the hash value of the resulting presence
information; if it is not an exact match with the update's hash, the client has
missed one or more updates and thus request a full presence list from the
server.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[node distance=1.75cm]
    \node (start) [startstop] {Start};
    \node (io1) [io, below of=start] {Wait for new client connection};
    \node (current page.center) (dec1) [decision, below of=io1, yshift=-1.5cm] {New client connected?};
    \node (pro1) [process, below of=dec1, yshift=-2.5cm] {Update client's status to "online" in KV store};
    \node (pro2) [process, below of=pro1] {Wait until next update interval};
    \node (io2) [io, below of=pro2, align=center] {Calculate hash and\\push presence data to clients};

    \draw [arrow] (start) -- (io1);
    \draw [arrow] (io1) -- (dec1);
    \draw [arrow] (dec1) -- node[midway,fill=white, align=center] {yes\\(process client asynchronously)} (pro1);
    \draw [arrow] (dec1) --+ (7cm, 0cm) node[midway,fill=white] {no} |- (io1);
    \draw [arrow] (pro1) -- (pro2);
    \draw [arrow] (pro2) -- (io2);
    \draw [arrow] (io2) --+ (7cm, 0cm) |- (io1);
  \end{tikzpicture}
  \caption{20,000 foot view of the Presence algorithm}
\end{figure}
The flowchart only describes the procedure for handling new client connections,
for idling and disconnections we uses a similar approach. Also noticed that
the flowchart does not have an \textit{End} box, this is intentional since
all servers runs on an infinite loop responding to client requests.

Each algorithm that handles a state change is implemented in a python library
as a component of the Zulip architecture. The following diagrams shows how the
original structure and a modified one that accommodates the proposed
solution.

\begin{figure}[H]
  \includegraphics[width=\textwidth]{img/structure_original}
  \caption{Original Zulip architecture}
\end{figure}

As shown in the diagram above, the Zulip project uses a traditional
server/client design. All services are routed through a reverse proxy server,
NGINX, which is undoubtedly the most popular choice for production websites.
The main application is handled by the django framework while the Tornado
server handles all real-time events, including chat messages, presence
information, etc. Persistent data are written to the PostgreSQL relational
database in regular intervals.

This project proposed to extract the presence system out of the Zulip codebase
(currently residing in the Tornado event loop) and instead uses a high level
presence library - which is the product of the proposed solution.

\begin{figure}[H]
  \includegraphics[width=\textwidth]{img/structure}
  \caption{Zulip architecture with the proposed solution}
\end{figure}

The proposed presence system will respond to presence events directly from
NGINX, skipping the backend entirely. The solution requires a new project
dependency, redis, which is a in-memory data structure store. It will be
responsible for temporarily storing the current presence states.

\subsection{Algorithm design}
To put the algorithms more concretely, here are them in pseudocode. The solution
needs to handle four different types of states transitions, offline to online,
online to idle, idle to offline and online to offline.

The offline to online transition is triggered when a new client connection is
established. It first establish a database connection and starts a websocket
server listening on port 80. When a client connects to the server, it update
the corresponding database field. On each update interval, the server broadcast
the presence diff to all online users.

\begin{minted}{text}
db <- Database connection
handle <- WebSocket Server listening on HTTP port 80

procedure offline_to_online
    on connection to handle (user_id)
        user <- db query user_id
        set user status to online
    end
end

procedure broadcast
    presence_diff <- difference between old and current db snapshot
    hash <- md5(current db snapshot)
    websocket.send (presence_diff, hash) to all online clients
end

loop
    offline_to_online
    on time out (update_interval seconds)
        broadcast
    end
end
\end{minted}

The second transition, online to idle, happens when the chat window is not
on focus (eg when the web browser window is minimised). For this to work,
we need an algorithm for both the client and server. On the client side,
the browser detects whether the chat window is focused, if not, alert the
server to update the user's state to idle.

\begin{minted}{text}
// Client code
user_id <- Client user identification
not on focus
    // Don't immediately update the state since the user could just be
    // temporarily switching tabs
    on time out (5 seconds)
        websocket.send ({'user': user_id, 'state': idle}) to server
    end
end

// Server code
db <- Database connection
handle <- WebSocket Server listening on HTTP port 80

loop
    on websocket.receive(message)
        match message
            {'user': user_id, 'state': idle} =>
                user <- db query user_id
                set user status to idle
            else => continue
        end
    end
end
\end{minted}

The final algorithm, idle/online to offline transition is handled on the
server side. It simply detects websocket disconnection events, and set
the disconnected user's state to offline in the database.

\begin{minted}{text}
db <- Database connection
handle <- WebSocket Server listening on HTTP port 80

loop
    on websocket.disconnect(user_id)
        user <- db query user_id
        set user status to offline
    end
end
\end{minted}

Together, these three algorithms forms a complete solution to the problem.
State changes on the client side are detected and the corresponding users'
status are updated in the database. At regular update intervals, the server
calculates a presence diff by comparing the old and current presence table,
and broadcast to all active online users.

\section{Usability features}
Given that the proposed solution is an alternative and improved version of
the presence distribution algorithm, the user-facing part of the project
should not be considered as part of the solution. However, a good and intuitive
UI design is still highly desirable.

An intuitive presence list UI should convey the status of other users
clearly without the need for explanation. In the example of Facebook' s presence
list (Figure 1.1), the status of each user is expressed twice - the colour circle
on the right of each row and the two separated list. This is redundant and is
an example of poor design.

By making use of design convention, we reduce the need for explicit information
in the form of text, which requires an extra cognition from the user. In our
presence list design, a green circle means that an user is online. This is
analogous to a green light in a traffic light or a green button next to an
automatic door, nowhere on Earth is the colour green associated with negative
action while red is positive. On the other hand, if the user is offline, we
represent that using a grey circle. Grey is an emotionless colour that usually
expresses the idea inaccessibility, for example, an input field is "greyout"
if it should/can not be edited.

In addition to the user interace, the usability features the API design should
also be considered.

Simplicity is the main goal of the API. It should provide a simple and
intuitive interface for receiving, aggregating and broadcasting client's
presence information. Ideally, the sending and receiving part would be handled
automatically after initiating a "Presence" instance. The library should
provide the following API interface for use server side:

\begin{minted}{python}
  # Check the presence status of a user
  def presence_of_user(user_id: int) -> PresenceStatus

  # Given a list of user ids, return a dictionary with user id as keys
  # and presence status as values.
  def presence_of_users(user_ids: List[int]) -> Dict[int, PresenceStatus]

  # Milliseconds since last synchronization with client
  def time_since_last_update() -> int
\end{minted}

\mintinline{python}{PresenceStatus} is a enumeration type
\mintinline{python}{class enum.Enum} with members
\mintinline{python}{online, idle, offline}. The library should also allow
user-defined \mintinline{python}{PresenceStatus} that can be passed into the
presence object upon initialization.

\section{Data structures and key variables}
The main data structure used in Presence, for storing the presence information,
is a hashtable (otherwise known as an \textit{associative array} or
\textit{dictionary}). A hashtable is a lookup table relating unique keys to
values. The lookup process works by hashing the key to a memory location, such
that the time complexity of the lookup, insert and delete operations is
\(O(1)\). We will cache the presence list in Python's built-in dictionary data
structure, but write to an in-memory key-value store for persistent storage.

A hashtable is chosen for this project for the following reasons:

\begin{enumerate}
  \item Performance. Since Presence is a latency sensitive application, the
  time it takes for fetching and writing operation is critical.
  \item It is a common practice to put a cache layer in front of a persistent
  SQL RDBMS. In our case, the presence data updates so frequently that the
  cache would be stale for most of the time.
  \item ACID, fault tolerance or complex queries support from traditional
  rational database are not required. Using a simple KV store allows for
  simpler and easier to understand code.
\end{enumerate}

Other data structures used in the project includes the Presence class. For
obvious reasons it will be named \mintinline{python}{Presence}. This object is
a subclass of the base class \mintinline{python}{object} defined by the Python
language. It will inherits all the default methods provided by the super-class
as well as a few additional methods for presence status lookup, caching and
broadcasting.

There are a few variables defined in the library. All of them should be
configurable in a config file by the server administrator. These include:

\begin{itemize}
  \item \textbf{Update interval:} (identifier:
        \mintinline{python}{update_interval}, type: 32-bit integer
        (milliseconds)) This determines the time interval between each presence
        update.
  \item \textbf{Presence status:} (identifier:
        \mintinline{python}{PresenceStatus}, type:
        \mintinline{python}{class enum.Enum}) The two states of an user,
        online, idle and offline. This is mapped into integers for efficient
        network transmission.
\end{itemize}

These variables parsed from the configuration file should be validated before
they are used by the server. Validation steps includes checking the data type
and whether they are in a given range. For example, the update interval should
be greater than 0 milliseconds, and presence status should have at least one
state.

\section{Testing}
Testing is an essential part of the project for verifying the correctness of the
implementation. We have automated tests that checks the entire solution
frequently and manually testing for each feature.

In automated testing, \textbf{tests are code}. Given the size of today's
application, manual testing is simply impossible. For example, the Google
Chrome application is compiled from 4,490,488 lines of source code (most of
which are highly optimized C and C++) and contains thousands of features. If it
were to be manually tested, a tester would have to go through every single
feature that exists in the application and check that it behaves according to
the spec every time a developer updates the source code. Not only is this error
prone, it is unscalable for today's softwares.
\textbf{As a result, pretty much all modern softwares have automated tests.}
Manual testing is done rarely and only for newly implemented features.

Automated tests itself is code, which executes a small section of the program
and checks if it performs the desired action. There are also
regression\footnote{Regression testing is a type of software testing that
ensures that previously developed and tested software still performs the same
way after it is changed or interfaced with other software.
\cite{wiki-regression-testing}} tests that checks if previously fixed bugs
resurfaced. The following shows tests and tests data that will be executed
during the development and post development phase of the process. The manual
test procedure is used right after the implementation of the feature while all
the automated unit tests are executed whenever I change the source code to
prevent regression.

\subsection{Test 1 - connection to presence server}
The first test is to ensure that users can connect to the presence server and
that the presence system transition the user's status to online. To express
this action in automated test format, we will use the requests HTTP client
library to connect to the presence system.

\subsubsection{Unit test}

\begin{minted}{python}
# /presence/tests/test_connection.py
import time
import requests
from .presence import Presence, PresenceStatus

presence = Presence()

# We are running the presence sever locally so the address is
# localhost and port 8000.
server_uri = 'http://localhost:8000/chat'

username = 'user001'

def test_server_connect():
    # Checks that before connecting, the user's status is offline
    assert presence.table[username] == PresenceStatus.OFFLINE

    # Connect to the server using a test account
    r = requests.get(server_uri, auth=(username, 'password'))

    assert r.status_code == 200  # Connection OK

    # Wait a few seconds for presence information to propagate.
    time.sleep(5)

    # Check that the user's status is now online.
    assert presence.table[username] == PresenceStatus.ONLINE
\end{minted}

As shown above, each \mintinline{python}{assert} statement checks that the left
hand side is the same as the right hand side. The test function is named
\mintinline{python}{test_function_name} - this is done so that the automated
test runner, pytest, "discovers" and execute the unit tests properly. Obviously
if we were to run to the test now it would fail, since I haven't implemented
the server or presence system yet. The following screenshot shows how Pytest
report a test failure.

\begin{figure}[H]
  \includegraphics[width=\textwidth]{img/pytest_server_connection}
  \caption{Result from Pytest}
\end{figure}

If the tests passed, pytest would show something similar to the following example
screenshot.

\begin{figure}[H]
  \includegraphics[width=\textwidth]{img/test_passed}
  \caption{Pytest build successfully}
\end{figure}

\subsubsection{Manual test}

We can also manually test this functionality during post development by logging
into a Zulip instance and check if the presence list is showing a green circle
next to the test user account. The steps are:

\begin{enumerate}
  \item Start presence server (bind server to localhost/127.0.0.1 and port
        8000)
  \item Login to 2 separate Zulip test account using any test account
  \item Check each one that the other user is online with a green circle next
        to their name in the presence list.
\end{enumerate}

\subsection{Test 2 - online to idle transition}
The second state transition involves going from online to idle. This transition
is triggered when the user have not interact with the application for a fixed
period of time while still being logged on to the chat session. To test this
we call the sleep function after a authentication with the presence server,
then we check whether the user's status is idle.

\subsubsection{Unit test}

\begin{minted}{python}
# /presence/tests/test_online_idle.py
import requests
import time

from .presence import Presence, PresenceStatus

presence = Presence()

server_uri = 'http://localhost:8000/chat'
username = 'user001'

def test_online_idle():
    assert presence.table[username] == PresenceStatus.OFFLINE

    # Connect to the server using a test account
    r = requests.get(server_uri, auth=(username, 'password'))

    assert r.status_code == 200

    time.sleep(5)
    assert presence.table[username] == PresenceStatus.ONLINE

    # Sleep for 5 minutes (5 x 60 seconds)
    time.sleep(5 * 60)

    assert presence.table[username] == PresenceStatus.IDLE
\end{minted}

\subsubsection{Manual test}

To test this manually, we just have to login to two account and wait for
the idle timeout and check if the presence list is showing the correct
status.

\begin{enumerate}
  \item Start presence server (bind server to localhost/127.0.0.1 and port
        8000)
  \item Login to 2 separate Zulip test account using any test account
  \item Check that each one that the other user is online with a green circle
        next to their name in the presence list.
  \item Keep both windows open, interact with one but not the other for 5+
  minutes
  \item Check that the presence of the idle user is idle with an orange circle
        while the other user remain green.
\end{enumerate}

\subsection{Test 3 - online to offline transition}
The third transition is initiate when the user exit the application and
triggered when the presence server detect a WebSocket disconnection event.

\subsubsection{Unit test}

\begin{minted}{python}
# /presence/tests/test_online_offline.py
import requests
import time

import websocket as ws

from .presence import Presence, PresenceStatus

presence = Presence()

server_uri = 'http://localhost:8000/chat'
username = 'user001'

def test_online_offline():
    assert presence.table[username] == PresenceStatus.OFFLINE

    # Connect to the server using a test account
    r = requests.get(server_uri, auth=(username, 'password'))

    assert r.status_code == 200

    time.sleep(5)
    assert presence.table[username] == PresenceStatus.ONLINE

    # Disconnect websocket connection
    ws.disconnect()

    # Wait a few seconds for the offline status to propagate.
    time.sleep(5)
    assert presence.table[username] == PresenceStatus.OFFLINE
\end{minted}

\subsubsection{Manual test}
To test this transition we login to two accounts, log one out and then check
that the user's status is offline.

\begin{enumerate}
  \item Start presence server (bind server to localhost/127.0.0.1 and port
        8000)
  \item Login to 2 separate Zulip test account using any test account
  \item Check the presence list to see two users online.
  \item Exit one of the chat session.
  \item Check the status of that user is now offline in the presence list.
\end{enumerate}
