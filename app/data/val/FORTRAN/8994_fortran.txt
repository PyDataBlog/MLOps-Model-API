!
! Distinct powers
!
! Problem 29
!
! Consider all integer combinations of ab for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:
!
!   2^2=4, 2^3=8, 2^4=16, 2^5=32
!   3^2=9, 3^3=27, 3^4=81, 3^5=243
!   4^2=16, 4^3=64, 4^4=256, 4^5=1024
!   5^2=25, 5^3=125, 5^4=625, 5^5=3125
!
! If they are then placed in numerical order, with any repeats removed, we get
! the following sequence of 15 distinct terms:
!
!   4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
!
! How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100
! and 2 ≤ b ≤ 100?
!
program distinct_powers
    implicit none

    integer, parameter :: max_number = 100
    logical, allocatable :: prime_table(:)
    integer, allocatable :: prime_list(:)

    call sieve_of_eratosthenes(max_number, prime_table, prime_list)
    call solver

contains
    subroutine sieve_of_eratosthenes(n, table, list)
        integer, intent(in) :: n
        logical, allocatable :: table(:)
        integer, allocatable :: list(:)
        integer :: i, j

        allocate(table(n))
        table = .true.
        table(1) = .false.
        do i = 2, n
            if (table(i)) then
                do j = i * 2, n, i
                    table(j) = .false.
                end do
            end if
        end do

        allocate(list(n))
        list(1) = 2
        j = 2
        do i = 3, n, 2
            if (table(i)) then
                list(j) = i
                j = j + 1
            end if
        end do
        list = list(1:j-1)

    end subroutine sieve_of_eratosthenes

    subroutine factorization(n, prime, factor)
        integer, intent(in) :: n, prime(:)
        integer, allocatable :: factor(:)
        integer :: a, i

        factor = [ (0, i = 1, ubound(prime, 1))]
        a = n
        i = 1
        do i = 1, ubound(prime, 1)
            if (a == 1) exit
            do while(mod(a, prime(i)) == 0)
                a = a / prime(i)
                factor(i) = factor(i) + 1
            end do
        end do

    end subroutine

    function compare(a, b) result(result)
        integer, intent(in) :: a(:), b(:)
        logical :: result
        integer :: i

        result = .true.
        do i = 1, ubound(a, 1)
            if (a(i) /= b(i)) then
                result = .false.
                return
            end if
        end do
    end function compare

    subroutine solver
        integer :: result
        integer :: n, m, i, j, k
        integer, allocatable :: a(:, :), b(:), f(:)
        integer, allocatable :: factor(:, :)

        n = ubound(prime_list, 1)
        allocate(factor(2:max_number, n))
        do i = 2, max_number
            call factorization(i, prime_list, f)
            factor(i, :) = f(:)
        end do
        do i = 2, max_number
            print '("facor: ", i3, ": ", 25i3)', i,  factor(i, :)
        end do

        allocate(a((max_number - 1) ** 2, n))
        a = 0

        m = 0
        do i = 2, max_number
            all_power: do j = 2, max_number
                b = factor(i, :) * j
                !print '(a,2i5": "2(i5))', 'b = ', i, j, b
                do k = 1, m
                    !print '(a,2i5": ["2(i5)" ] ? ["2(i5)" ]")', 'compare', i, j, a(k, :), b
                    if (compare(a(k, :), b)) then
                        !print '(a,2i3": "25(i5:))', 'same', i, j, b
                        cycle all_power
                    end if
                end do
                m = m + 1
                a(m, :) = b
                !print '("("i3", "i3"): "25(i5:))', i, j, b
            end do all_power
        end do
        result = m

        print *, 'result = ', result
    end subroutine

end program distinct_powers