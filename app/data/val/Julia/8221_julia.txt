# treenn
o = """Dict{Symbol,Any}(Pair{Symbol,Any}(:seed,-1),Pair{Symbol,Any}(:SPARSE,0),Pair{Symbol,Any}(:minoccur,0),Pair{Symbol,Any}(:TIMEOUT,600),Pair{Symbol,Any}(:dev,"data/trees/dev.txt"),Pair{Symbol,Any}(:epochs,100),Pair{Symbol,Any}(:HIDDEN_SIZE,128),Pair{Symbol,Any}(:gpu,true),Pair{Symbol,Any}(:EMBED_SIZE,128),Pair{Symbol,Any}(:train,"data/trees/train.txt"))"""
o = eval(parse(o))

# START
o[:seed] > 0 && srand(o[:seed])
atype = o[:gpu] ? KnetArray{Float32} : Array{Float32}

# read data
trn = read_file(o[:train])
tst = read_file(o[:dev])

# count words and build vocabulary
l2i, w2i, i2l, i2w = build_vocabs(trn)
nwords = length(w2i); nlabels = length(l2i)
make_data!(trn, w2i, l2i); make_data!(tst, w2i, l2i)

# build model
w = initweights(
    atype, o[:HIDDEN_SIZE], length(w2i), length(l2i), o[:EMBED_SIZE])
s = initstate(atype, o[:HIDDEN_SIZE])
opt = map(x->Adam(), w)
# END

# essential part
tree = trn[1]
train!(w,s,tree,opt) # compile
Profile.clear()
@profile (for k=1:67; train!(w,s,tree,opt); end)
# @profile (for k=1:200; loss(w,s,tree); end)
Profile.print()
Profile.print(format=:flat)
