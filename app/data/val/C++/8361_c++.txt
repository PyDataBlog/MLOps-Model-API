#include "LdpcEncoder.h"
#include "LdpcDecoder.h"

using namespace std;

namespace encode
{

LdpcEncoder::LdpcEncoder(const BitMatrixFactory& matrixFactory, const EquationSolverFactory& solverFactory,
                         const uint32_t symbolSize, const DataSource& source)
    : Encoder(matrixFactory, solverFactory, symbolSize), mSource(source)
{
    mSource.assertNoWordPadding();
}

vector<word_t> LdpcEncoder::createSymbol(SymbolID id) const
{
    const uint32_t numSymbols = mSource.wordSize() / getSourceSymbolSize();
    vector<word_t> encodedSymbol(getEncodedSymbolSize());

    if(static_cast<uint32_t>(id) < numSymbols)
    {
        uint32_t pos = static_cast<uint32_t>(id) * getSourceSymbolSize();

        for(uint32_t j = 0; j < getSourceSymbolSize(); ++j)
            encodedSymbol[j] = mSource.wordData()[pos + j];
    }
    else
    {
        //TODO move to baseclass
        auto rels = LdpcDecoder::generateRelationships(id - numSymbols, numSymbols);

        for(uint32_t j = 0; j < getEncodedSymbolSize(); ++j)
        {
            word_t data = 0;

            for(auto it: rels)
            {
                data ^= mSource.wordData()[it*getSourceSymbolSize() + j];
            }

            encodedSymbol[j] = data;
        }
    }

    return encodedSymbol;
}

}
