/*60142233 °­¹Î°æ
 * Copyright (C) 2011-2012 Me and My Shadow
 *
 * This file is part of Me and My Shadow.
 *
 * Me and My Shadow is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Me and My Shadow is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Me and My Shadow.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <stdio.h>
#include <iostream>
#include <string>
#include <vector>
#include "Globals.h"
#include "FileManager.h"
#include "Functions.h"
#include <archive.h>
#include <archive_entry.h>
using namespace std;

#ifdef WIN32
#include <windows.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <direct.h>
#pragma comment(lib,"shlwapi.lib")
#else
#include <strings.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <dirent.h>
#endif


#ifdef WIN32
string userPath,dataPath,appPath,exeName;
#else
//´Ù¸¥ ÇÃ·§Æû¿¡¼­ userPath (¼³Á¤ ÆÄÀÏ) ¹× userDataPath (µ¥ÀÌÅÍ ÆÄÀÏ) »çÀÌÀÇ Â÷ÀÌ¸¦ È®ÀÎ
//Ä³½Ã µ¥ÀÌÅÍ userCachePathÀÇ °æ·Î°¡ÀÖ´Ù.
string userPath,userDataPath,userCachePath,dataPath,appPath,exeName;
#endif

bool configurePaths() {
	//appPath°ú EXENAME¸¦ °¡Á®¿É´Ï´Ù.
	{
		char s[4096];
		int i,m;
		#ifdef WIN32
		m=GetModuleFileNameA(NULL,s,sizeof(s));
		#else
		m=readlink("/proc/self/exe",s,sizeof(s));
		#endif
		s[m]=0;
		for(i=m-1;i>=0;i--){
			if(s[i]=='/'||s[i]=='\\'){
				s[i]=0;
				break;
			}
		}
		appPath=s;
		exeName=s+i+1;
	}
	
	//TODO : userpathÀÌ userPathÀ» ¼³Á¤ÇÏ±â Àü¿¡ ºñ¾î ÀÖ´ÂÁö È®ÀÎ
	//userPathÀÌ ºñ¾î ÀÖ´ÂÁö È®ÀÎÇÕ´Ï´Ù.
	if(getUserPath().empty()){
#ifdef WIN32
		//userPath¸¦ °¡Á®¿É´Ï´Ù.
		char s[1024];
		SHGetSpecialFolderPathA(NULL,s,CSIDL_PERSONAL,1);
		userPath=s;
		userPath+="\\My Games\\meandmyshadow\\";		
#else
		//NULL ÇÒ´çÀ» ¹æÁöÇÏ´Â µ¥ »ç¿ëµÇ´Â ÀÓ½Ã º¯¼ö.
		char* env;
		
		//$XDG_CONFIG_HOME env var¸¦ ¾ò´Â´Ù
		env=getenv("XDG_CONFIG_HOME");
		//±×°ÍÀÌ $ HOME / .config /¿¡ ³Î (null) ¼³Á¤ userPath¿¡ ÀÖ´Ù¸é.
		if(env!=NULL){
			userPath=env;
		}else{
			userPath=getenv("HOME");
			userPath+="/.config";
		}
		//userPath¿¡ meandmyshadow¸¦ Ãß°¡ ÇÒ ¼ö ÀÖ½À´Ï´Ù.
		userPath+="/meandmyshadow/";
		
		//$XDG_DATA_HOME env var¸¦ ¾ò´Â´Ù.
		env=getenv("XDG_DATA_HOME");
		//$ HOME /.local/share¿¡ ³Î (null) ¼³Á¤ userDataPathÀÌ ÀÖ´Ù¸é.
		if(env!=NULL){
			userDataPath=env;
		}else{
			userDataPath=getenv("HOME");
			userDataPath+="/.local/share";
		}
		//userPath¿¡ meandmyshadow¸¦ Ãß°¡
		userDataPath+="/meandmyshadow/";
		
		//$XDG_CACHE_HOME env var¸¦ ¾ò´Â´Ù.
		env=getenv("XDG_CACHE_HOME");
		//$ HOME / .cache¿¡ ³Î (null) ¼³Á¤ userCachePathÀÌ ÀÖ´Ù¸é.
		if(env!=NULL){
			userCachePath=env;
		}else{
			userCachePath=getenv("HOME");
			userCachePath+="/.cache";
		}
		//AuserPath¿¡ meandmyshadow¸¦ Ãß°¡ ÇÒ ¼ö ÀÖ½À´Ï´Ù.
		userCachePath+="/meandmyshadow/";
		
		//null ¼³Á¤
		env=NULL;
#endif
		
		//userPathÀ» Ãâ·Â.
		cout<<"User preferences will be fetched from: "<<userPath<<endl;
#ifndef WIN32
		//ºñ Windows ½Ã½ºÅÛÀÇ °æ¿ì¿¡´Â »ç¿ëÀÚ µ¥ÀÌÅÍÀÇ °æ·Î¸¦ ³ªÅ¸³½´Ù.
		cout<<"User data will be fetched from: "<<userDataPath<<endl;
#endif
	}

#ifdef WIN32
	//userPath Æú´õ¿Í ´Ù¸¥ ÇÏÀ§ Æú´õ¸¦ ¸¸µì´Ï´Ù.
	createDirectory(userPath.c_str());
	createDirectory((userPath+"levels").c_str());
	createDirectory((userPath+"levelpacks").c_str());
	createDirectory((userPath+"themes").c_str());
	createDirectory((userPath+"progress").c_str());
	createDirectory((userPath+"tmp").c_str());
	//record Æú´õ
	createDirectory((userPath+"records").c_str());
	createDirectory((userPath+"records\\autosave").c_str());
	//±×¸®°í userpath ³»ºÎÀÇ »ç¿ëÀÚ ÁöÁ¤ Æú´õ.
	createDirectory((userPath+"custom").c_str());
	createDirectory((userPath+"custom\\levels").c_str());
	createDirectory((userPath+"custom\\levelpacks").c_str());
#else
	// userPath »ý¼º.
	createDirectory(userPath.c_str());
	createDirectory(userDataPath.c_str());
	createDirectory(userCachePath.c_str());
	//¶ÇÇÑ userpath¿¡ ´Ù¸¥ Æú´õ¸¦ ¸¸µé ¼ö ÀÖ½À´Ï´Ù.
	createDirectory((userDataPath+"/levels").c_str());
	createDirectory((userDataPath+"/levelpacks").c_str());
	createDirectory((userDataPath+"/themes").c_str());
	createDirectory((userDataPath+"/progress").c_str());
	createDirectory((userCachePath+"/tmp").c_str());
	//record Æú´õ
	createDirectory((userDataPath+"/records").c_str());
	createDirectory((userDataPath+"/records/autosave").c_str());
	//±×¸®°í userpath ³»ºÎÀÇ »ç¿ëÀÚ ÁöÁ¤ Æú´õ.
	createDirectory((userDataPath+"/custom").c_str());
	createDirectory((userDataPath+"/custom/levels").c_str());
	createDirectory((userDataPath+"/custom/levelpacks").c_str());
#endif

	//º¹¼öÀÇ »ó´ë À§Ä¡¸¦ ½ÃµµÇÏ¿© µ¥ÀÌÅÍ °æ·Î¸¦ °¡Á®¿É´Ï´Ù.
	{
		FILE *f;
		string s;
		while(true){
			//½Ãµµ
			if(!dataPath.empty()){
				s=dataPath+"font/knewave.ttf";
				if((f=fopen(s.c_str(),"rb"))!=NULL){
					fclose(f);
					break;
				}
			}
			//try "./"
			dataPath="./data/";
			s=dataPath+"font/knewave.ttf";
			if((f=fopen(s.c_str(),"rb"))!=NULL){
				fclose(f);
				break;
			}
			//try "../"
			dataPath="../data/";
			s=dataPath+"font/knewave.ttf";
			if((f=fopen(s.c_str(),"rb"))!=NULL){
				fclose(f);
				break;
			}
			//try App.Path
			dataPath=getAppPath()+"/data/";
			s=dataPath+"font/knewave.ttf";
			if((f=fopen(s.c_str(),"rb"))!=NULL){
				fclose(f);
				break;
			}
			//try App.Path+"/../"
			dataPath=getAppPath()+"/../data/";
			s=dataPath+"font/knewave.ttf";
			if((f=fopen(s.c_str(),"rb"))!=NULL){
				fclose(f);
				break;
			}
			//try DATA_PATH
#ifdef DATA_PATH
			dataPath=DATA_PATH;
			s=dataPath+"font/knewave.ttf";
			if((f=fopen(s.c_str(),"rb"))!=NULL){
				fclose(f);
				break;
			}
#endif
			//¿À·ù : ÆÄÀÏÀ» Ã£À» ¼ö ¾ø½À´Ï´Ù
			return false;
		}

		//µ¥ÀÌÅÍ °æ·Î¸¦ ÀÎ¼âÇÕ´Ï´Ù.
		cout<<"Data files will be fetched from: "<<dataPath<<endl;
	}
	return true;
}

std::vector<std::string> enumAllFiles(std::string path,const char* extension,bool containsPath){
	vector<string> v;
#ifdef WIN32
	string s1;
	WIN32_FIND_DATAA f;
	if(!path.empty()){
		char c=path[path.size()-1];
		if(c!='/'&&c!='\\') path+="\\";
	}
	s1=path;
	if(extension!=NULL && *extension){
		s1+="*.";
		s1+=extension;
	}else{
		s1+="*";
	}
	HANDLE h=FindFirstFileA(s1.c_str(),&f);
	if(h==NULL||h==INVALID_HANDLE_VALUE) return v;
	do{
		if(!(f.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)){
			if(containsPath){
				v.push_back(path+f.cFileName);
			}else{
				v.push_back(f.cFileName);
			}
		}
	}while(FindNextFileA(h,&f));
	FindClose(h);
	return v;
#else
	int len=0;
	if(extension!=NULL && *extension) len=strlen(extension);
	if(!path.empty()){
		char c=path[path.size()-1];
		if(c!='/'&&c!='\\') path+="/";
	}
	DIR *pDir;
	struct dirent *pDirent;
	pDir=opendir(path.c_str());
	if(pDir==NULL) return v;
	while((pDirent=readdir(pDir))!=NULL){
		if(pDirent->d_name[0]=='.'){
			if(pDirent->d_name[1]==0||
				(pDirent->d_name[1]=='.'&&pDirent->d_name[2]==0)) continue;
		}
		string s1=path+pDirent->d_name;
		struct stat S_stat;
		lstat(s1.c_str(),&S_stat);
		if(!S_ISDIR(S_stat.st_mode)){
			if(len>0){
				if((int)s1.size()<len+1) continue;
				if(s1[s1.size()-len-1]!='.') continue;
				if(strcasecmp(&s1[s1.size()-len],extension)) continue;
			}

			if(containsPath){
				v.push_back(s1);
			}else{
				v.push_back(string(pDirent->d_name));
			}
		}
	}
	closedir(pDir);
	return v;
#endif
}

std::vector<std::string> enumAllDirs(std::string path,bool containsPath){
	vector<string> v;
#ifdef WIN32
	string s1;
	WIN32_FIND_DATAA f;
	if(!path.empty()){
		char c=path[path.size()-1];
		if(c!='/'&&c!='\\') path+="\\";
	}
	s1=path+"*";
	HANDLE h=FindFirstFileA(s1.c_str(),&f);
	if(h==NULL||h==INVALID_HANDLE_VALUE) return v;
	do{
		// skip '.' and '..' and hidden folders
		if(f.cFileName[0]=='.'){
			/*if(f.cFileName[1]==0||
				(f.cFileName[1]=='.'&&f.cFileName[2]==0))*/ continue;
		}
		if(f.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY){
			if(containsPath){
				v.push_back(path+f.cFileName);
			}else{
				v.push_back(f.cFileName);
			}
		}
	}while(FindNextFileA(h,&f));
	FindClose(h);
	return v;
#else
	if(!path.empty()){
		char c=path[path.size()-1];
		if(c!='/'&&c!='\\') path+="/";
	}
	DIR *pDir;
	struct dirent *pDirent;
	pDir=opendir(path.c_str());
	if(pDir==NULL) return v;
	while((pDirent=readdir(pDir))!=NULL){
		if(pDirent->d_name[0]=='.'){
			if(pDirent->d_name[1]==0||
				(pDirent->d_name[1]=='.'&&pDirent->d_name[2]==0)) continue;
		}
		string s1=path+pDirent->d_name;
		struct stat S_stat;
		lstat(s1.c_str(),&S_stat);
		if(S_ISDIR(S_stat.st_mode)){
			//¼û°ÜÁø Æú´õ¸¦ °Ç³Ê ¶Ý´Ï´Ù.
			s1=string(pDirent->d_name);
			if(s1.find('.')==0) continue;
			
			//º¤ÅÍ¿¡ °á°ú¸¦ Ãß°¡ÇÕ´Ï´Ù.
			if(containsPath){
				v.push_back(path+pDirent->d_name);
			}else{
				v.push_back(s1);
			}
		}
	}
	closedir(pDir);
	return v;
#endif
}

std::string processFileName(const std::string& s){
	string prefix=dataPath;
  
	//FIXME: Do we still need those last three?
	//REMARK: maybe 'return prefix+s;' is not needed (?)
	// ±×·¯ÇÑ ¼öÁØÀÇ ÁøÇà »óÈ²À» ÀúÀåÇÒ ¼ö ¾ø½À´Ï´Ù °°Àº ¸î °¡Áö ¹ö±×°¡ ¹ß»ýÇÕ´Ï´Ù
	if(s.compare(0,6,"%DATA%")==0){
		if(s.size()>6 && (s[6]=='/' || s[6]=='\\')){
			return dataPath+s.substr(7);
		}else{
			return dataPath+s.substr(6);
		}
	}else if(s.compare(0,6,"%USER%")==0){
		if(s.size()>6 && (s[6]=='/' || s[6]=='\\')){
			return getUserPath(USER_DATA)+s.substr(7);
		}else{
			return getUserPath(USER_DATA)+s.substr(6);
		}
	}else if(s.compare(0,9,"%LVLPACK%")==0){
		if(s.size()>9 && (s[9]=='/' || s[9]=='\\')){
			return prefix+"levelpacks/"+s.substr(10);
		}else{
			return prefix+"levelpacks/"+s.substr(9);
		}
	}else if(s.compare(0,5,"%LVL%")==0){
		if(s.size()>5 && (s[5]=='/' || s[5]=='\\')){
			return prefix+"levels/"+s.substr(6);
		}else{
			return prefix+"levels/"+s.substr(5);
		}
	}else if(s.compare(0,8,"%THEMES%")==0){
		if(s.size()>8 && (s[8]=='/' || s[8]=='\\')){
			return prefix+"themes/"+s.substr(9);
		}else{
			return prefix+"themes/"+s.substr(8);
		}
	}else if(s.size()>0 && (s[0]=='/' || s[0]=='\\')){
		return s;
#ifdef WIN32
	// Another fix for Windows :(
	}else if(s.size()>1 && (s[1]==':')){
		return s;
#endif
	}else{
		return prefix+s;
	}
}

std::string fileNameFromPath(const std::string &path, const bool webURL){
	std::string filename;
	size_t pos;
#ifdef WIN32
	// FIXME: '/' in string should be '/' not '\/',
	// we don't need to escape it
	if(webURL){
		pos = path.find_last_of("/");
	}else{
		// Âü°í : ¶§¶§·Î WindowsÀÇ °æ·Î ±¸ºÐÀº '/'¸¦ ÇÒ ¼öÀÖ´Ù,
		// ±×·¡¼­ ¿ì¸®´Â '\'¿Í '/'¸¦ È®ÀÎÇØ¾ßÇÑ´Ù 
		pos = path.find_last_of("\\/");
	}
#else
	// FIXME: '/' in string should be '/' not '\/',
	// we don't need to escape it
	pos = path.find_last_of("/");
#endif
	if(pos != std::string::npos)
		filename.assign(path.begin() + pos + 1, path.end());
	else
		filename=path;
	
	return filename;
}

std::string pathFromFileName(const std::string &filename){
	std::string path;
	// FIXME: '/' in string should be '/' not '\/',
	// we don't need to escape it
#ifdef WIN32
	// Âü°í : ¶§¶§·Î WindowsÀÇ °æ·Î ±¸ºÐÀº '/'¸¦ ÇÒ ¼öÀÖ´Ù,
	//  ±×·¡¼­ ¿ì¸®´Â '\'¿Í '/'¸¦ È®ÀÎÇØ¾ßÇÑ´Ù 
	size_t pos = filename.find_last_of("\\/");
#else
	size_t pos = filename.find_last_of("/");
#endif
	if(pos != std::string::npos)
		path.assign(filename.begin(), filename.begin() + pos +1);
	else
		path=filename;
	
	return path;
}

bool downloadFile(const string &path, const string &destination) {
	string filename=fileNameFromPath(path,true);
	
	FILE* file = fopen((destination+filename).c_str(), "wb");
	bool status=downloadFile(path,file);
	fclose(file);
	
	//±×¸®°í »óÅÂ¸¦ ¹ÝÈ¯ÇÕ´Ï´Ù.
	return status;
}

bool downloadFile(const string &path, FILE* destination) {
	CURL* curl=curl_easy_init();

	// ÇÁ·Ï½Ã Å×½ºÆ® (Å×½ºÆ® Àü¿ë)
	string internetProxy = getSettings()->getValue("internet-proxy");
	size_t pos = internetProxy.find_first_of(":");
	if(pos!=string::npos){
		curl_easy_setopt(curl,CURLOPT_PROXYPORT,atoi(internetProxy.substr(pos+1).c_str()));
		internetProxy = internetProxy.substr(0,pos);
		curl_easy_setopt(curl,CURLOPT_PROXY,internetProxy.c_str());
	}

	curl_easy_setopt(curl,CURLOPT_URL,path.c_str());
	curl_easy_setopt(curl,CURLOPT_WRITEFUNCTION,writeData);
	curl_easy_setopt(curl,CURLOPT_WRITEDATA,destination);
	CURLcode res = curl_easy_perform(curl);
	curl_easy_cleanup(curl);
	
	return (res==0);
}

size_t writeData(void *ptr, size_t size, size_t nmemb, void *stream){
	return fwrite(ptr, size, nmemb, (FILE *)stream);
}


bool extractFile(const string &fileName, const string &destination) {
	//¿ì¸®°¡ ÃßÃâÇÏ´Â ¾ÆÄ«ÀÌºê¸¦ ¸¸µì´Ï´Ù.
	archive* file=NULL;
	//¿ì¸®°¡ ÃßÃâÇÏ´Â ´ë»óÀ» ¸¸µì´Ï´Ù.
	archive* dest=NULL;
	
	file=archive_read_new();
	dest=archive_write_disk_new();
	archive_write_disk_set_options(dest, ARCHIVE_EXTRACT_TIME);
	
	archive_read_support_format_zip(file);
	
	//ÀÌÁ¦ ¾ÆÄ«ÀÌºê¸¦ ÀÐ´Â´Ù.
	if(archive_read_open_file(file,fileName.c_str(),10240)) {
		cerr<<"Error while reading archive "+fileName<<endl;
		return false;
	}
	
	//ÀÌÁ¦ µð½ºÅ©¿¡ÀÖ´Â ¸ðµç Ç×¸ñÀ» ÀÛ¼ºÇÕ´Ï´Ù.
	int status;
	archive_entry* entry=NULL;
	while(true) {
		status=archive_read_next_header(file,&entry);
		if(status==ARCHIVE_EOF){
			break;
		}
		if(status!=ARCHIVE_OK){
			cerr<<"Error while reading archive "+fileName<<endl;
			return false;
		}
		archive_entry_copy_pathname(entry,(destination+archive_entry_pathname(entry)).c_str());
		
		status=archive_write_header(dest,entry);
		if(status!=ARCHIVE_OK){
			cerr<<"Error while extracting archive "+fileName<<endl;
			return false;
		}else{
			copyData(file, dest);
			status=archive_write_finish_entry(dest);
			if(status!=ARCHIVE_OK){
				cerr<<"Error while extracting archive "+fileName<<endl;
				return false;
			}

		}
	}
	
	//¸¶Áö¸·À¸·Î ¾ÆÄ«ÀÌºê¸¦ ´Ý½À´Ï´Ù.
	archive_read_close(file);
	archive_read_finish(file);
	return true;
}

bool createDirectory(const char* path){
#ifdef WIN32
	char s0[1024],s[1024];

	GetCurrentDirectoryA(sizeof(s0),s0);
	PathCombineA(s,s0,path);

	for(unsigned int i=0;i<sizeof(s);i++){
		if(s[i]=='\0') break;
		else if(s[i]=='/') s[i]='\\';
	}

	//printf("createDirectory:%s\n",s);
	return SHCreateDirectoryExA(NULL,s,NULL)!=0;
#else
	return mkdir(path,0777)==0;
#endif
}

bool removeDirectory(const char *path){
#ifdef WIN32
	WIN32_FIND_DATAA f;
	HANDLE h = FindFirstFileA((string(path)+"\\*").c_str(),&f);
#else
	//Á¦°Å ÇÒ ÇÊ¿ä°¡ÀÖ´Â µð·ºÅä¸®¸¦ ¿±´Ï´Ù.
	DIR* d=opendir(path);
#endif
	//°æ·Î ±æÀÌ¸¦ °¡Á®¿É´Ï´Ù
	size_t path_len = strlen(path);
	//µð·ºÅä¸®°¡ ºñ¾îÀÖ´Â °æ¿ì ºÎ¿ï.
	//True: succees		False: failure
	//µð·ºÅä¸®°¡ ºó »óÅÂ (empty)ÀÇ °æ¿ì while ·çÇÁ¸¦ ÀÔ·ÂÇÏÁö ¾Ê½À´Ï´Ù,ÇÏÁö¸¸ ¼º°øÀ» °¡Áö°í ÀÖ±â ¶§¹®¿¡ ±âº»°ªÀº true.
	bool r = true;

#ifdef WIN32
	if(h!=NULL && h!=INVALID_HANDLE_VALUE) {
#else
	//µð·ºÅä¸®°¡ Á¸ÀçÇÏ´ÂÁö È®ÀÎÇÕ´Ï´Ù.
	if(d) {
		//µð·ºÅä¸® ¿£Æ®¸®ÀÇ Æ÷ÀÎÅÍ.
		struct dirent* p;
#endif

#ifdef WIN32
		do{
#else
		//¿À·ù°¡ ¾ø½À´Ï´Ù °°Àº Á¦°Å ÇÒ ÇÊ¿ä°¡ÀÖ´Â µð·ºÅä¸®ÀÇ Ç×¸ñµéÀ» ¹Ýº¹ÇØ¶ó 
		while(r && (p=readdir(d))) {
#endif

			// Skip the names "." and ".." as we don't want to recurse on them.
#ifdef WIN32
			if (!strcmp(f.cFileName, ".") || !strcmp(f.cFileName, "..")) {
#else
			if (!strcmp(p->d_name, ".") || !strcmp(p->d_name, "..")) {
#endif
				//The filename is . or .. so we continue to the next entry.
				continue;
			} else {
				//Ç×¸ñÀÌ »èÁ¦ µÈ °æ¿ì R2
				//True: succees		False: failure
				//±âº»°ªÀº falseÀÔ´Ï´Ù.
				bool r2 = false;
				char* buf;
				size_t len;

#ifdef WIN32
				//°æ·Î + µð·ºÅä¸® ¿£Æ®¸® ÀÌ¸§ÀÇ ±æÀÌ¸¦ °¡Á®¿É´Ï´Ù.
				len = path_len + strlen(f.cFileName) + 2; 
#else
				//°æ·Î + µð·ºÅä¸® ¿£Æ®¸® ÀÌ¸§ÀÇ ±æÀÌ¸¦ °¡Á®¿É´Ï´Ù.
				len = path_len + strlen(p->d_name) + 2; 
#endif
				buf = (char*) malloc(len);

				if(buf) {
#ifdef WIN32
					_snprintf(buf, len, "%s\\%s", path, f.cFileName);

					if(f.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY){
						r2 = removeDirectory(buf);
					}else{
						r2 = unlink(buf)==0;
					}
#else
					struct stat statbuf;
					snprintf(buf, len, "%s/%s", path, p->d_name);

					if(!stat(buf, &statbuf)){
						//Ç×¸ñÀÌ µð·ºÅä¸® ³ª ÆÄÀÏÀÎÁö È®ÀÎÇÕ´Ï´Ù.
						if (S_ISDIR(statbuf.st_mode)){
							//¹Ýº¹ÀûÀ¸·Î ÇØ°áÇÒ (removeDirectory)È£Ãâ
							//¼º°ø¿¡ true¸¦ µ¹·ÁÁÝ´Ï´Ù.
							r2 = removeDirectory(buf);
						}else{
							//unlink() returns zero on succes so we set r2 to the unlink(buf)==0.
							r2 = unlink(buf)==0;
						}
					}
#endif
					//buf free
					free(buf);
				}
				//R2´Â ÃÖ±Ù »èÁ¦ÀÇ »óÅÂ¸¦ Æ÷ÇÔÇÏ°í ÀÖ±â ¶§¹®¿¡ R2·Î RÀ» ¼³Á¤ÇÕ´Ï´Ù.
				r = r2;
			}
#ifdef WIN32
		}while(r && FindNextFileA(h,&f));
		FindClose(h);
#else
		}
		//µð·ºÅä¸®¸¦ ´Ý½À´Ï´Ù.
		closedir(d);
#endif
	}
	
	//while ·çÇÁ´Â ¿ì¸®°¡ (½Ãµµ) ÀÇ¹Ì, Á¾·á´Â µð·ºÅä¸®¸¦ »èÁ¦.
	//rÀº ¿À·ù¸¦ ÀÇ¹ÌÇÑ´Ù¸é, rÀº ¿¡·¯¾øÀ½À» ÀÇ¹Ì. µð·ºÅä¸®¸¦ »èÁ¦ÇÒ ¼ö ÀÖ½À´Ï´Ù.
	if(r){
		//ÀÌ ¶§ RmDirÀ» ¼º°øÀÇ ¹ÝÈ¯ °ªÀº 0ÀÌ´Ù.
		r = rmdir(path)==0;
	}
	
	//»óÅÂ¸¦ µ¹·ÁÁÝ´Ï´Ù.
	return r;
}

bool renameDirectory(const char* oldPath,const char* newPath){
	return rename(oldPath,newPath)==0;
}


void copyData(archive* file, archive* dest) {
	int status;
	const void* buff;
	size_t size;
#if ARCHIVE_VERSION_NUMBER < 3000000
	off_t offset;
#else
	int64_t offset;
#endif


	while(true) {
		status=archive_read_data_block(file, &buff, &size, &offset);
		if(status==ARCHIVE_EOF){
			return;
		}
		if(status!=ARCHIVE_OK){
			cerr<<"Error while writing data to disk."<<endl;
			return;
		}
		status=archive_write_data_block(dest, buff, size, offset);
		if(status!=ARCHIVE_OK) {
			cerr<<"Error while writing data to disk."<<endl;
			return;
		}
	}
}

bool copyFile(const char* source,const char* dest){
	//¼Ò½º ÆÄÀÏÀ» ¿±´Ï´Ù.
	ifstream fin(source,fstream::binary);
	if(!fin)
		return false;
	
	//DEST ÆÄÀÏÀ» ¿±´Ï´Ù.
	ofstream fout(dest,fstream::trunc|fstream::binary);
	if(!fout)
		return false;
	
	//º¹»ç
	fout<<fin.rdbuf();
	return true;
}

bool removeFile(const char* file){
	return remove(file)==0;
}

bool createFile(const char* file){
	//¾²±â ±ÇÇÑÀÌÀÖ´Â ÆÄÀÏÀ» ¿±´Ï ´Ù.
	FILE* f=fopen(file,"wb");
	
	//¾Æ¹«·± ¹®Á¦°¡¾ø´Â °æ¿ì È®ÀÎÇÕ´Ï´Ù.
	if(f){
		//ÆÄÀÏ´Ý±â
		fclose(f);
		return true;
	}else{
		return false;
	}
}
