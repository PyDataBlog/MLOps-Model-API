/*
 * SIGMA Framework Core Library.
 *
 * This library is distributed under the MIT License.
 * See Copyright Notice at the end of this file.
 */

#if (defined __DMC__ || defined _MSC_VER)
#  pragma once
#endif

#if (!defined SIGMA_FRAMEWORK_COMMON_CORE_LIBRARY_TEMPLATE_HPP)
#  define   SIGMA_FRAMEWORK_COMMON_CORE_LIBRARY_TEMPLATE_HPP


#  if (defined __GNUC__)
#     include <sigma/common/com_ptr.hpp>

#     include <sigma/common/threads/threads.safe.hpp>
#     include <sigma/common/threads/threads.unsafe.hpp>

#     include <sigma/core/core.category.hpp>
#     include <sigma/core/core.config.hpp>
#  else
#     include "../common/com_ptr.hpp"

#     include "../common/threads/threads.safe.hpp"
#     include "../common/threads/threads.unsafe.hpp"

#     include "core.category.hpp"
#     include "core.config.hpp"
#  endif

#  if (defined SIGMA_MANAGED)
#     pragma managed(push, off)
#  endif


CORE_BEGIN

template<class _CLSID,
         class _CATID>
class Template
   : public Interface
{
   private: typedef  Interface                        _Mybase;
   private: typedef  Template<_CLSID, _CATID>         _Mytype;

   public:  typedef  typename _CLSID::guard_type      guard_type;
   public:  typedef  typename _CATID::category_type   category_type;


   public:
      class Lock
      {
         private: typedef  Lock                       _Mytype;

         private: typedef  typename guard_type::lock  lock_type;


         public:
                                       Lock(_In_ Template<_CLSID, _CATID> const &object)
                                          :m_lock(object.m_guard)
                                       {}

                                       ~Lock()
                                       {}


         private:
                            lock_type  m_lock;


                                       Lock();

                                       Lock(_In_ _Mytype const &);


            const             _Mytype &operator =  (_In_ _Mytype const &);
      };


   friend   class    Lock;


   public:
                                       Template()
                                          :_Mybase(),
                                           m_guard()
                                       {}

      explicit                         Template(_In_ Interface &aggregate)
                                          :_Mybase(aggregate),
                                           m_guard()
                                       {}


      static   const              UID &APICALL CLSID()
                                       {
                                          return _CLSID::CLSID();
                                       }

      static   const              UID &APICALL CATID()
                                       {
                                          return _CATID::CATID();
                                       }


                                       template<class _type>
                     com_ptr_t<_type>  QueryInterface()
                                       {
                                          return _Mybase::QueryInterface<_type>();
                                       }


   protected:
      virtual                          ~Template()
                                       {}


      virtual            InterfacePtr  APICALL QueryInterface(_In_ const UID &clsid) SIGMA_OVERRIDE
                                       {
                                          if (clsid == _CLSID::CLSID())
                                             return InterfacePtr(this, true);

                                          return InterfacePtr();
                                       }


   private:
               mutable     guard_type  m_guard;


                                       Template(_In_ _Mytype const &);


               const          _Mytype &operator =  (_In_ _Mytype const &);
};



#  define   CORE_CLSID_DECLARATION(struct_name, guard)                     \
   struct struct_name                                                      \
   {                                                                       \
      typedef  guard    guard_type;                                        \
                                                                           \
      static                           SIGMA_API                           \
               const  SIGMA core::UID &APICALL CLSID();                    \
   };


#  define   CORE_CLSID_IMPLEMENTATION(struct_name, uid)                    \
   const     SIGMA core::UID &APICALL struct_name::CLSID()                 \
                              {                                            \
                                 static SIGMA core::UID instance(uid);     \
                                                                           \
                                 return instance;                          \
                              }


CORE_END

#  if (defined SIGMA_MANAGED)
#     pragma managed(pop)
#  endif

#endif

/*
 * Copyright Â© 2008-2013 by Smirnov Michael.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
