# ############################################################### #
# Project2.ASM                                                    #
# Robert Neumeyer ID:800461230                                    #
# 11/12/2013                                                      #
#  REGISTERS MUST BE CLEAR BEFOR RUNNING                          #
# ############################################################### #   

.data

SPACE: .asciiz ", "
MESSAGE: .asciiz "Primes Found\n";

    .text
	.globl 	main
	
main:		
	li $v0, 4
    la $a0, MESSAGE  
    syscall
	
	li	$s0, 0x00000000	# initialize $s0 with zeros
	li	$s1, 0x11111111	# initialize $s1 with ones
	li $t9, 50			# find prime numbers from 2 to $t9. Change this number to adjust how many primes are found

	add	$s2, $sp, 0		# backup bottom of stack address in $s2

	li	$t0, 2			# set counter variable to 2

init:	
	sw	$s1, ($sp)		# write ones to the stackpointer's address
	add	$t0, $t0, 1		# increment counter variable
	sub	$sp, $sp, 4		# subtract 4 bytes from stackpointer
	ble	$t0, $t9, init	# loop while $t0 <= $t9

	li	$t0, 1			# reset counter variable to 1

outer:	
	add $t0, $t0, 1		# increment counter variable
	mul	$t1, $t0, $t0	# multiply $t0 with itself and save to $t1
	bgt	$t1, $t9, print	# start printing prime numbers when $t1 > $t9

check:	
	add	$t2, $s2, 0		# saves the bottom of stack address to $t2
	mul	$t3, $t0, 4		# calculate the number of bytes to jump over
	sub	$t2, $t2, $t3
	add	$t2, $t2, 8		# add 2

	lw	$t3, ($t2)	

	beq	$t3, $s0, outer	# go back to the outer loop

inner:	
	add	$t2, $s2, 0		# saves the bottom of stack address to $t2
	mul	$t3, $t1, 4		# calculate the number of bytes to jump over
	sub	$t2, $t2, $t3
	add	$t2, $t2, 8		# add 2 words

	sw	$s0, ($t2)		

	add	$t1, $t1, $t0	# do this for every multiple of $t0
	bgt	$t1, $t9, outer	# go back to outer loop

	j	inner			# go back to inner loop

print:	
	li	$t0, 1			# reset counter variable to 1
count:	
	add	$t0, $t0, 1		# increment counter variable

	bgt	$t0, $t9, exit	# exit when all numbers are done

	add	$t2, $s2, 0		# saves the bottom of stack address to $t2
	mul	$t3, $t0, 4		# calculate the number of bytes to jump over
	sub	$t2, $t2, $t3
	add	$t2, $t2, 8		# add 2

	lw	$t3, ($t2)		# load the content into $t3
	beq	$t3, $s0, count	# only 0's? go back to count loop

	add	$t3, $s2, 0		# save the bottom of stack address to $t3

	sub	$t3, $t3, $t2	# substract higher from lower address
	div	$t3, $t3, 4		# divide by 4
	add	$t3, $t3, 2		# add 2

	li	$v0, 1		
	add	$a0, $t3, 0	
	syscall			

	li	$v0, 4		
	la	$a0, SPACE	
	syscall			

	ble	$t0, $t9, count	# take loop while $t0 <= $t9

exit:	
	jr	$31
