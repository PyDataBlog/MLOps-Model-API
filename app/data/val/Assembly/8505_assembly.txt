
; name : dllmain.asm

; description :	main assembly file for the Dynamic Link Library

; remark : It's a strange case/switch structure I've constructed here but doing so
;			I can put eventually long routines for each case in the code.
;			Another approach is to use subroutines but I believe it will make the
;			dll loader more complex.
;			Also notice that you can set the error code if a requirement fails.
;			This error code must be in rax before the ret instruction at the end.
;			In case you don't use a special routines for each case, you can also comment
;			the decision making component and just end with mov rax, 1 followed by a ret
; more info :	about DLL https://social.msdn.microsoft.com/Search/en-US?query=dll&pgArea=header&emptyWatermark=true&ac=4
;				about GetLastError : https://msdn.microsoft.com/en-us/library/windows/desktop/ms679360(v=vs.85).aspx
;				about SetLastError : https://msdn.microsoft.com/en-us/library/windows/desktop/ms680627(v=vs.85).aspx

; You can safely remove TestFunction.asm and TestFunction.inc. If you do also remove the
;		 extrn TestFunction : proc
; in dllfunctions.inc

option casemap :none   ; case sensitive


include dllmain.inc						; constants used in dllmain routine
include dllfunctions.inc				; each added routine must be defined as extrn in this file


USE_SWITCH_CASE_BLOCK = 0					; replace 0 by another number (e.g. 1) to let the assembler know to use the
										; switch case block



%if USE_SWITCH_CASE_BLOCK eq 1

.data
	
	; in stead of creating a switch case structure we can easily calculate the address of each attach/detach procedure. We do this only when we
	; make use of the procedures, otherwise it's waste of space.
	; DON'T ALTER the sequence of the offsets. They are placed in numerical ascending order of
	;	DLL_PROCESS_DETACH                   equ 0
	;	DLL_PROCESS_ATTACH                   equ 1
	;	DLL_THREAD_ATTACH                    equ 2
	;	DLL_THREAD_DETACH                    equ 3

	dllProcedures		dq	ProcessDetachProc, ProcessAttachProc, ThreadAttachProc, ThreadDetachProc

.code

;if SWITCH_CASE_BLOCK eq 1

	; if we make use of the switch case structure
dllmain proc hInstDLL: qword, reason: qword, reserved1: qword

			mov		hInstDLL, rcx
			mov		reason, rdx
			mov		reserved1, r8

			shl		rdx, 3				; multiply by 8 to calculate the right address
			lea		rax, dllProcedures	; load effective address of start of procedures
			add		rax, rdx			; add offset
			call	qword ptr[rax]		; jump to respective routine
			ret							; when all is ok we have rax = 1, otherwise rax = 0
dllmain endp

%else

.code

dllmain proc hInstDLL: qword, reason: qword, reserved1: qword

			xor		rax, rax
			inc		rax
			ret
dllmain endp
			
%endif

end