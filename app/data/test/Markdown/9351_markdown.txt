# Дизайн сообщений об ошибках

На основе агрегатов можно производить расчёт сообщений об ошибках проверок заказов.
Фактически, это ещё одна агрегация поверх агрегатов.  

# Требования к сообщениям об ошибках

Требования от ERM
- быстро найти все сообщения об ошибках для конкретного заказа

Требования от Экспорта:
- быстро найти все сообщения об ошибках для всех заказов в конкретном проекте за конкретный период 

Общие требования
- Машина времени. Должны вернуть информацию об ошибках в заказе на любой известный нам момент времени.    
- Локализация. Для любого проекта нужно уметь получать локализованные сообщения об ошибках на любом языке. Экспорт например захочет сообщения на английском для всех проектов, а UI системам нужно выводит сообщения на языке проекта. 

# Структура агрегатов

![required text](https://immense-sea-86195.herokuapp.com/2gis/nuclear-river/feature/validation-rules/docs/ru/validation-rules/design-messages.puml)

## Version

Идентификатором агрегата является порядковый номер версии набора проверок. Каждое вычисленное изменение состояния приводит к новой версии. 
Инкремент и уникальность достигаются без использования автоинкремента БД, на уровне логики проложения. 
Это защищает от параллельных изменений и от того, что более поздняя версия получит меньший номер.

## ErmState

В состав агрегата входит коллекция токенов (вероятнее всего UseCaseId типа guid или просто идентификатор состояния типа long).

Служит для того, чтобы при обращении клиента можно было определить, достигнуто ли требуемое состояние Erm в проверках и какие именно сообщения соответствуют тому состоянию.
В результате того, что события агрегируются на всех этапах, одно состояние проверок соответствует одному или более состояний Erm.
В результате того, что чтении данных (при получении события) хранилище не соответствует в точности состоянию в момент генерации события, состояние проверок может включать более поздние изменения.
Это приводит к необходимости заморозки изменений в заказах в случае сборки.

## ValidationResult

В состав агрегата входит полный набор результатов проверок.
Хранить их "как есть" технически дорого, поэтому нужно подумать о трюках. 
Возможное решение: в новую версию добавлять только дельту состояний относительно предыдущей, а при исключении заказа из результатов (отменён, изменён период, удалён...) использовать отметку. Отсюда поле Result, имеющее три возможных состояния: проверка пройдена, есть ошибка, заказ исключен.

Поля OrderId, Period, ProjectId обеспечивают поиск по всем известным сегодня критериям.

Поля MessageType, MessageParams обеспечивают возможность формирования локализованного сообщения об ошибке.

Как представленная структура отвечает требованиям?

- Быстрый поиск. Id заказа, период и город могут быть добавлены в индекс. Для поиска по самой актуальной информации о проверках достаточно сделать запрос по ValidationResult.

- Машина времени. ValidationResult содержит Version, таким образом хранится информация обо всех заказах во все известных нам версиях (что использовать в качестве version вопрос пока открытый)

- Контроль состояния erm. Наличие токена в таблице ErmState гарантирует, что проверки достигли требуемого состояния. Указание версии в ValidationResult позволяет получить состояние системы в прошлом (на самом деле, плюс-минус, следует учитывать лаг между получением события и чтением из базы erm и пакетную обработку - это приводит к не точному соответствию)
