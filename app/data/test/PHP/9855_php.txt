<?php

namespace module;

use Exception;
use Zend\Config\Reader\Ini;
use Zend\Config\Config;
use ulfberht\core\module;
use module\application\service\store;
use module\application\service\request;
use module\application\service\response;
use module\application\service\router;
use module\application\service\doctrine;

/**
 * The application module is the backbone of Ulfberht Applications and provides much of the
 * automatical things we see like initializing configurations.
 */
class application extends module {

    /**
     * The constructor. Registers all services for the application module.
     */
    public function __construct() {
        $this->dependsOn('module\debugger');
        $this->registerSingleton('module\application\controller\resourceBundle');
        $this->registerSingleton('module\application\service\store');
        $this->registerSingleton('module\application\service\doctrine');
        $this->registerSingleton('module\application\service\request');
        $this->registerSingleton('module\application\service\response');
        $this->registerSingleton('module\application\service\router');
        $this->registerSingleton('module\application\service\view');
        $this->registerFactory('module\application\service\doctrine\config');
        $this->registerFactory('module\application\service\minifier');
    }

    /**
     * [Ulfberht Forging Hook] Initializes an ulfberht application.
     * @param $store module\application\service\store
     * @param $request module\application\service\request
     * @param $router module\application\service\router
     * @return void
     */
    public function applicationInit(store $store, request $request, router $router, doctrine $doctrine) {
        $this->applicationInitConfig($store, $request);
        $this->applicationInitRoutes($store, $router);
        $this->applicationInitDoctrine($store, $doctrine);
    }

    /**
     * [Ulfberht Forging Hook] This method is responsible for loading in initial
     * application configurations from application ini files located in
     * /src/module/application/configs/application.ini.
     * @param $store module\application\service\store
     * @param $request module\application\service\request
     * @return void
     */
    public function applicationInitConfig(store $store, request $request) {
        //get app config and loop though additional configs
        $appConfigSrcPath = APPLICATION_ROOT . '/src/module/application/config/application.ini';
        $appConfigIni = $this->_getConfigIniFromIniPath($appConfigSrcPath);
        $appConfigName = $this->_getFileNameFromIniPath($appConfigSrcPath);
        $store->set($appConfigName, $appConfigIni);

        //look through application config configs array and setup those configs
        $configs = ($appConfigIni->configs) ? $appConfigIni->configs : [];
        foreach ($appConfigIni->application->configs as $storePath) {
            $storeSrcPath = APPLICATION_ROOT . $storePath;
            $configName = $this->_getFileNameFromIniPath($storeSrcPath);
            $configIni = $this->_getConfigIniFromIniPath($storeSrcPath);
            $existingConfig = $store->get($configName);
            if ($existingConfig) {
                $existingConfig->merge($configIni);
            } else {
                $store->set($configName, $configIni);
            }
        }

        //setup env config
        $host = $request->server->get('HTTP_HOST');

        //if host comes back undefined assume localhost:8000 settings
        if (!$host) {
            $host = 'localhost:8000';
        }
        $environmentConfig = $store->get('environment');
        $envVar = false;
        foreach ($environmentConfig->environments as $environmentVar => $domain) {
            if (strtolower($host) === strtolower($domain)) {
                $envVar = $environmentVar;
                break;
            }
        }

        if (!$envVar) {
            throw new Exception('Could not find proper environment config variable for host "' . $host . '"');
        } else {
            $envConfig = $store->get('environment')->{$envVar};
            $store->set('ENV', $envConfig);
        }
    }

    /**
     * [Ulfberht Forging Hook] This method is responsible for loading in routes
     * based on routes.ini
     * @param $store module\application\service\store
     * @param $request module\application\service\router
     * @return void
     */
    public function applicationInitRoutes(store $store, router $router) {
        $env = $store->get('ENV');
        $routesConfig = $store->get('routes');
        foreach ($routesConfig->routes as $key => $route) {
            $path = $route->path;
            $verb = $route->verb;
            $controller = $route->controller . ':' . $route->action;
            $router->{$verb}($path, $controller);
        }

        //setting default controller if it is set in routes.ini
        if ($routesConfig->default->controller && $routesConfig->default->action) {
            $router->otherwise($routesConfig->default->controller . ':' . $routesConfig->default->action);
        }

        //set routes for resource bundles if in develop mode
        if ($env->application->debug) {
            $router->get('/debug/bundle/js/{resourceBundleId}', 'module\application\controller\resourceBundle:js');
            $router->get('/debug/bundle/css/{resourceBundleId}', 'module\application\controller\resourceBundle:css');
        }
    }

    /**
     * This method is responsible for setting up the application entity manager
     * based on application.ini and environment.ini configs.
     * @param $store module\application\service\store
     * @return void
     */
    public function applicationInitDoctrine(store $store, doctrine $doctrine) {
        $envConfig = $store->get('ENV');
        $applicationConfig = $store->get('application');

        //get new doctrine config object.
        $doctrineConfig = $this->get('module\application\service\doctrine\config');
        $doctrineConfig->develop = $envConfig->application->debug;
        $doctrineConfig->enableCache = $envConfig->doctrine->cache;
        $doctrineConfig->type = $applicationConfig->doctrine->type;
        $doctrineConfig->database->driver = $envConfig->database->driver;
        $doctrineConfig->database->host = $envConfig->database->host;
        $doctrineConfig->database->name = $envConfig->database->name;
        $doctrineConfig->database->user = $envConfig->database->user;
        $doctrineConfig->database->password = $envConfig->database->password;

        //setting doctrine paths
        $doctrinePaths = [];
        foreach ($applicationConfig->doctrine->paths as $path) {
            $doctrinePaths[] = APPLICATION_ROOT . $path;
        }
        $doctrineConfig->paths = $doctrinePaths;
        //set doctrine application config
        $doctrine->addEntityManager('application', $doctrineConfig);
    }

    /**
     * [Ulfberht Forging Hook] This method is setup to run as a hook when forging
     * an ulfberht application. The purpose of this hook is to resolve a path to
     * a controller and run that controller's action.
     * @param $router module\application\service\router
     * @param $request module\application\service\request
     * @param $response module\application\service\response
     * @return void
     */
    public function applicationMvc(router $router, request $request, response $response) {
        $params = $router->resolve();
        $request->attributes->add($params);
        $controllerActionSetting = explode(':', $params['controller']);
        $controllerClass = $controllerActionSetting[0];
        $controllerAction = (isset($controllerActionSetting[1])) ? $controllerActionSetting[1] : false;
        if (!$controllerClass) {
            throw new Exception('Could not find a controller to resolve.');
        }
        if (!$controllerAction) {
            throw new Exception('A controller action was not defined.');
        }
        if (!ulfberht()->exists($controllerClass)) {
            throw new Exception('Could not find controller "' . $controllerClass . '"');
        }

        $controller = ulfberht()->get($controllerClass);
        if ($controllerAction) {
            if (!method_exists($controller, $controllerAction)) {
                throw new Exception('Cound not find action method "' . $controllerAction . '" on controller "' . $controllerClass . '"');
            }
            call_user_func([$controller, $controllerAction]);
        }

        $response->prepare($request);
        $response->send();
    }

    /**
     * This method is responsible for returning a configIni object wrapping
     * which ever ini file is passed in.
     * @param $fileSrcPath string The path to the ini file.
     * @return Zend\Config\Config
     */
    private function _getConfigIniFromIniPath($fileSrcPath) {
        $reader = new Ini();
        $config = $reader->fromFile($fileSrcPath);
        return new Config($config);
    }

    /**
     * Returns the filename of the files source path you pass into it.
     * @param $fileSrcPath string The path to the ini file.
     * @return string The filename parsed out of the path.
     */
    private function _getFileNameFromIniPath($fileSrcPath) {
        $pathParts = preg_split('/\//', $fileSrcPath);
        $fileName = $pathParts[count($pathParts) - 1];
        $fileNameParts = preg_split('/\./', $fileName);

        return $fileNameParts[0];
    }

}
