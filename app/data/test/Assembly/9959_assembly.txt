;
; nasm -g -f obj -l matrix.lst matrix.asm
; alink matrix.obj -oPE -dll
; dlltool -z matrix.def --export-all-symbol matrix.dll
; dlltool -D matrix.dll -d matrix.def -l libmatrix.a
; pexports matrix.dll | sed "s/^_//" > matrix.def
;

cpu	386

global	test1
export	test1

global	init_vector
export	init_vector

global	init_matrix
export	init_matrix

global fill_matrix_snake
export fill_matrix_snake

section code use32 class=code

test1:
	push	ebp
	mov		ebp, esp
	
	leave
	ret

init_vector:
	push	ebp
	mov		ebp, esp
	
	and		esp, -16
	sub		esp, 48
	
	mov		eax, dword [ebp+8]		; length of array. first argument of _cdecl function
	mov		eax, dword [ebp+12]		; address of vector pointer. second argument of _cdecl function
	
	mov		dword [ebp-4], 0		; i=0. local variable
	mov		dword [ebp-8], 0		; j=0; local variable
	
	mov		ecx, dword [ebp+8]		; length of array.
	mov		ebx, dword [ebp+12]
.L1:
	mov		eax, dword [ebp-4]		; eax = i
	inc		dword [ebp-4]			; i++
	sal		eax, 2					; i*=4
	add		eax, dword [ebp+12]		; address of vector element vector[i]
	mov		dword [eax], 1000		; vector[i] = ecx
	loop .L1
	
	xor		eax, eax
	
	leave
	ret
	
init_matrix:
	push	ebp
	mov		ebp, esp	
	
	leave
	ret
	
fill_matrix_snake:
	push	ebp
	mov		ebp, esp
	sub		esp, 16
	
	mov		ecx, dword [ebp+8]
	mov		edx, dword [ebp+12]
	
	mov		dword [ebp-4], 0
	mov		dword [ebp-8], 0
	
.L1:
	cmp		dword[ebp-4], ecx
	je		.DONE
	mov		ebx, dword [ebp-4]
	shl		ebx, 2
	add		ebx, dword [ebp+12]		; address of matrix
	mov		ebx, dword [ebx]		; address of vectors start eax
	
	inc		dword [ebp-4]
	
	mov		dword [ebp-8], 0
.L2:
	cmp		dword[ebp-8], ecx
	je		.L1
	
	mov		eax, dword [ebp-4]
	dec		eax

	xor		edx, edx
	mov		edi, 2
	div		edi
	cmp		edx, 1
	je		.L3						; edx is even

	mov		eax, dword [ebp-4]
	dec		eax
	
	
	mul		ecx
	add		eax, dword[ebp-8]
	inc		eax
	mov		dword [ebx], eax
	
	jmp		.L4						; edx is odd
.L3:
	mov		eax, dword [ebp-4]
	mul		ecx
	sub		eax, dword[ebp-8]
	mov		dword [ebx], eax
.L4:
	inc		dword [ebp-8]
	add		ebx, 4
	jmp		.L2

	jmp		.L1
	
.DONE:
	xor		eax, eax
	
	leave
	ret