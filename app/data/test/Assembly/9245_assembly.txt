# Timothy Miller
# arraysort.asm
# 3/31/15
.text
.globl main
main:
restart:
	jal input			#Call a subprogram to enter an array of numbers
	jal output
	jal sort
	jal output
	jal restartprompt

	la $t0,array			# t0 = address of array
	lw $t1,count			# t1 = count, exit loop when it goes to 0
	lw $t2,($t0)			# t2 = min = a[0] (initialization)
	lw $t3,($t0)			# t3 = max = a[0] (initialization)
	add $t0,$t0,4			# move pointer ahead to next array element a[1]
	add $t1,$t1,-1 			# decrement counter to keep in step with array


loop: lw $t4,($t0) 			# t4 = next element in array
	bge $t4,$t2,notMin			# if array element is  >= min goto notMin

	move $t2,$t4			# min = a[i]
	j notMax

notMin: ble $t4,$t3,notMax			# if array element is <= max goto notMax

	move $t3,$t4			# max = a[i]
notMax: add $t1,$t1,-1			# t1 --  ->  counter --
	add $t0,$t0,4			# increment counter to point to next word
	bnez $t1,loop

	la $a0,min			# Display "The minimum number is "
	li $v0,4				# a0 = address of message
	syscall				# v0 = 4 which indicates display a string	

	move $a0,$t2			# Display the minimum number 
	li $v0,1
	syscall

	la $a0,max			# Display "The maximum number is "
	li $v0,4				# a0 = address of message
	syscall				# v0 = 4 which indicates display a string

	move $a0,$t3			# Display the maximum number 
	li $v0,1
	syscall

	la $a0,nl			# Display "cr/lf"
	li $v0,4				# a0 = address of message
	syscall				# v0 = 4 which indicates display a string

	li $v0,10				# End Of Program
	syscall

output:

	la $a0, heading
	li $v0, 4
	syscall

	la $t0, array
	lw $t1, count

outloop:
	lw $t5, ($t0)
	move $a0, $t5
	li $v0, 1
	syscall

	la $a0, space
	li $v0, 4
	syscall

	addi $t0, $t0, 4
	addi $t1, $t1, -1

	bgtz $t1, outloop
	la $a0, nl
	li $v0, 4
	syscall
	jr $ra


input:					#Ask for the numbers of integers in the array
	la $a0, prompt1			#Print prompt1
	li $v0, 4
	syscall

	li $v0, 5			#Get input
	syscall
	sw $v0, count

	move $t5, $v0			# t5 = count
	li $t6, 1			# t6 = 1

	la $t0 array


inloop:
	#Display #1, #2, #3, etc...
	la $a0, pound
	li $v0, 4
	syscall

	move $a0, $t6
	li $v0, 1
	syscall

	la $a0, spacing
	li $v0, 4
	syscall

	#Enter the array numbers
	li $v0, 5
	syscall
	sw $v0,($t0)

	addi $t0, $t0, 4			#t0 = t0 + 4
	addi $t6, $t6, 1			#t6 = t6 + 1

	ble $t6, $t5, inloop


	jr $ra

sort:
	la $t0, array		# t0 is a pointer to a[0] (a[i])
	la $t1, array		# t1 is a pointer to a[0] (a[j])
	addi $t1, $t1, 4	# t1 += 4 (so t1 is now a pointer to a[1])

	# t2 = count    (i counter)
	lw $t2, count
	# t2 = count-1
	addi $t2, $t2, -1  
	# t3 = t2       (j counter)
	move $t3, $t2

sloop:                      
	# t4 = a[i]
	lw $t4, ($t0)
	# t5 = a[j]
	lw $t5, ($t1)
	# if (a[i] <= a[j]) do not swap
	ble $t4, $t5, noswap
	# swap a[i] and a[j]
swap:
	sw $t5, ($t0)
	sw $t4, ($t1)
noswap:                     
	# t1 = next address of a[j]
	addi $t1, $t1, 4
	# j count --
	addi $t3, $t3, -1
	# if j count != 0 go back to sort loop
	bnez $t3, sloop
	# t0 = next address of a[i]
	addi $t0, $t0, 4
	# i count --
	addi $t2, $t2, -1
	# j count = i count
	move $t3, $t2
	# if i count = 0 sort is complete
	beqz $t2, endsort
	# t1 = the next address of a[i]
	addi $t1, $t0, 4
	# jump to sort loop
	j sloop
	endsort:
	jr $ra
restartprompt:
	la $a0, prompt2
	li $v0, 4
	syscall

	li $v0, 5
	syscall

	bnez $v0, restart

	li $v0, 10
	syscall

.data
array:	.space	100
count:	.word	0
min:	.asciiz	"The minimum number is "
max:	.asciiz	"\nThe maximium number is "
nl:		.asciiz	"\n"
prompt1:.asciiz	"Please enter the number of numbers in the array: "
pound:	.asciiz	"#"
spacing:.asciiz ": "
heading:.asciiz	"Here's some output for ya\n"
space:	.asciiz	" "
prompt2:.asciiz "Enter 0 to quit, any other number to run again: "

#Please enter the number of numbers in the array: 4
#1: 1
#2: 2
#3: 3
#4: 4
#Here's some output for ya
#1 2 3 4 
#Here's some output for ya
#1 2 3 4 
#Enter 0 to quit, any other number to run again: 4
#Please enter the number of numbers in the array: 4
##1: 4
##2: 3
##3: 2
##4: 1
#Here's some output for ya
#4 3 2 1 
#Here's some output for ya
#1 2 3 4 
#Enter 0 to quit, any other number to run again: 0
