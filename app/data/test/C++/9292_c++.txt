/***
* Inferno Engine v4 2015-2017
* Written by Tomasz "Rex Dex" Jonarski
*
* [#filter: tcp #]
***/

#include "build.h"
#include "selector.h"

#include "tcpServer.h"
#include "tcpSocket.h"

#include "base/system/include/thread.h"
#include "base/containers/include/inplaceArray.h"

namespace base
{
    namespace socket
    {
        namespace tcp
        {
            //--

            IServerHandler::~IServerHandler()
            {}

            //--

            void ConnectionStats::print(IFormatStream& f) const
            {
                const auto aliveTime = m_startTime.timeTillNow().toSeconds();

                if (m_totalDataSent)
                    f.appendf("  Data sent: {} ({}/s)\n", MemSize(m_totalDataSent), MemSize((Double)m_totalDataSent / aliveTime));
                if (m_totalDataReceived)
                    f.appendf("  Data recv: {} ({}/s)",  MemSize(m_totalDataReceived), MemSize((Double)m_totalDataReceived / aliveTime));
            }

            //--

            Server::Server(IServerHandler* handler, const ServerConfig& config /*= ServerConfig()*/)
                : m_handler(handler)
                , m_nextConnectionID(1)
                , m_listeningFlag(0)
                , m_initFlag(0)
                , m_config(config)
            {
                m_receciveBuffer.resize(config.m_recvBufferSize);
            }

            Server::~Server()
            {
                close();
            }

            bool Server::init(const Address& listenAddress)
            {
                // lock
                const auto flag = m_initFlag.exchange(1);
                if (flag != 0)
                {
                    TRACE_ERROR("TCP Server: server is already running");
                    return true;
                }

                // open socket
                if (!m_socket.listen(listenAddress, &m_address))
                {
                    TRACE_ERROR("TCP Server: failed to create socket at address '{}'", listenAddress);
                    m_initFlag.exchange(0);
                    return false;
                }

                // inform about assigned port
                if (listenAddress.getPort() == 0)
                {
                    TRACE_INFO("TCP Server: Auto assigned socket '{}'", m_address.getPort());
                }

                // try to set socket in non-blocking mode
                if (!m_socket.setBlocking(false))
                {
                    TRACE_ERROR("TCP Server: failed to set socket into non blocking mode");
                    m_initFlag.exchange(0);
                    m_socket.close();
                    return false;
                }

                // Try to set socket buffer limits
                /*if (!m_socket->setBufferSize(Constants::MAX_DATAGRAM_SIZE, Constants::MAX_DATAGRAM_SIZE))
                {
                    TRACE_ERROR("TCP Server error: failed to check buffer sizes on socket");
                    m_socket->close();
                    m_socket.release();
                    return false;
                }*/

                // set address
                m_listeningFlag.exchange(1);

                // Create thread processing the data
                threads::ThreadSetup setup;
                setup.m_function = [this]() { threadFunc(); };
                setup.m_priority = threads::Priority::AboveNormal;
                setup.m_name = "TCPServerThread";

                // Start selector thread
                m_thread.init(setup);

                // Server is alive
                TRACE_INFO("TCP Server: Started local server on '{}'", m_address);
                return true;
            }

            void Server::close()
            {
                // make sure we close only once
                if (1 == m_initFlag.exchange(0))
                {
                    TRACE_INFO("TCP Server: Closing local server on '{}'", m_address);

                    // close listening socket, this will exit the select() and than the loop
                    m_socket.close();

                    // close socket processing thread, it should be fine now since we closed the master socket
                    m_thread.close();

                    // close all connections
                    m_activeConnections.clearPtr();
                    m_activeConnectionsSocketMap.clear();
                    m_activeConnectionsIDMap.clear();
                }
            }

            Bool Server::send(ConnectionID id, const void* data, const Uint32 dataSize)
            {
                auto lock = CreateLock(m_activeConnectionsLock);

                // don't send shit via dead server
                if (!m_listeningFlag.getValue())
                    return false;

                // get target address for connection
                Connection* connection = nullptr;
                if (!m_activeConnectionsIDMap.find(id, connection))
                    return false;

                // push data and let the system worry
                Uint32 sentLeft = dataSize;
                auto* sentPtr = (const Uint8*)data;
                while (sentLeft > 0)
                {
                    const auto sentSize = connection->m_socket.send(sentPtr, sentLeft);
                    if (sentSize < 0)
                    {
                        TRACE_ERROR("TCP Server: Failed to send {} bytes to {} ({}), closing", dataSize, id, connection->m_address);
                        connection->m_closeRequest.exchange(1);
                        return false;
                    }
                    else if (sentSize != (Int32) dataSize)
                    {
                        TRACE_WARNING("TCP Server: Truncated send ({} -> {}) when sending {} bytes to {} ({})", sentLeft, sentSize, id, connection->m_address);
                        threads::Sleep(10);
                    }

                    sentPtr += sentSize;
                    sentLeft -= sentSize;
                }

                // update stats
                connection->m_stats.m_totalDataSent += dataSize;

                // data sent
                return true;
            }

            Bool Server::disconnect(ConnectionID id)
            {
                // dead server
                if (!m_listeningFlag.getValue())
                    return false;

                auto lock = CreateLock(m_activeConnectionsLock);

                // get target address for connection
                Connection* connection = nullptr;
                if (!m_activeConnectionsIDMap.find(id, connection))
                    return false;

                // close the connection
                TRACE_INFO("TCP Server: Closing connection {} ({})", id, connection->m_address);
                connection->m_closeRequest.exchange(1);
                return true;
            }

            //--

            void Server::serviceListenerSocket(SocketType socket)
            {
                Address remoteAddress;
                RawSocket acceptedSocket;
                if (acceptedSocket.accept(m_socket, &remoteAddress))
                {
                    TRACE_INFO("TCP Server: accepted connection from {}, socket: {}", remoteAddress, acceptedSocket.getSystemSocket());

                    acceptedSocket.setBlocking(false);

                    auto *con = MemNewPool(POOL_NEW, Connection);
                    con->m_id = m_nextConnectionID.increment();
                    con->m_connectedTime.resetToNow();
                    con->m_lastMessageTime.resetToNow();
                    con->m_address = remoteAddress;
                    con->m_socket = std::move(acceptedSocket);
                    con->m_stats.m_startTime.resetToNow();

                    // add to list of active connections, next time we will loop on the receive thread we will start processing the messages
                    {
                        auto lock = CreateLock(m_activeConnectionsLock);
                        m_activeConnections.pushBack(con);
                        m_activeConnectionsIDMap[con->m_id] = con;
                        m_activeConnectionsSocketMap[con->m_socket.getSystemSocket()] = con;
                    }

                    // inform the handler about the new connection
                    m_handler->handleConnectionAccepted(this, remoteAddress, con->m_id);
                }
            }

            void Server::serviceConnectionSocket(SocketType socket, Bool error)
            {
                // find connection for given socket
                Connection *con = nullptr;
                {
                    auto lock = CreateLock(m_activeConnectionsLock);
                    m_activeConnectionsSocketMap.find(socket, con);
                }

                // not found
                if (nullptr == con)
                {
                    TRACE_ERROR("TCP Server: Got data from unrecognized socket");
                    return;
                }

                // close
                if (error)
                {
                    TRACE_ERROR("TCP Server: got error for connection {}", con->m_address);
                    con->m_closeRequest.exchange(1);
                    return;
                }

                // get data
                while (1)
                {
                    const auto dataSize = con->m_socket.receive(m_receciveBuffer.getData(), m_receciveBuffer.getDataSize());
                    if (dataSize < 0)
                    {
                        con->m_closeRequest.exchange(1);
                        break;
                    }
                    else if (dataSize > 0)
                    {
                        // update stats
                        con->m_stats.m_totalDataReceived += dataSize;

                        // pass to handler
                        m_handler->handleConnectionData(this, con->m_address, con->m_id, m_receciveBuffer.getData(), dataSize);
                    }
                    else
                    {
                        // no more data
                        break;
                    }
                }
            }

            void Server::threadFunc()
            {
                Selector selector;

                InplaceArray<SocketType, 64> activeSockets;

                SocketType listenSocket = m_socket.getSystemSocket();

                // loop
                Bool keepRunning = true;
                while (keepRunning)
                {
                    // always put the main socket on the list since we are waiting for the connections
                    activeSockets.reset();
                    activeSockets.pushBack(listenSocket);

                    // process the list of active connections, get list of sockets to look for
                    collectActiveConnections(activeSockets);

                    // wait for something
                    switch (selector.wait(SelectorOp::Read, activeSockets.getTypedData(), activeSockets.size(), 50))
                    {
                        case SelectorEvent::Ready:
                        {
                            // wow, some work
                            for (const auto& result : selector)
                            {
                                if (result.socket == listenSocket)
                                {
                                    if (result.error)
                                    {
                                        TRACE_ERROR("TCP Server: Listener socket closed/lost, existing thread");
                                        serviceListenerClose();
                                        keepRunning = false;
                                    }
                                    else
                                    {
                                        serviceListenerSocket(result.socket);
                                    }
                                }
                                else
                                {
                                    serviceConnectionSocket(result.socket, result.error);
                                }
                            }

                            break;
                        }

                        case SelectorEvent::Busy:
                        {
                            break;
                        }

                        case SelectorEvent::Error:
                        {
                            TRACE_ERROR("TCP Server: Error in poll(), existing server loop");
                            serviceListenerClose();
                            keepRunning = false;
                        }
                    }
                }

                // close all active connections
                if (!m_activeConnections.empty())
                {
                    TRACE_INFO("TCP server: closing remaining {} connections", m_activeConnections.size());
                    m_activeConnections.clearPtr();
                    m_activeConnectionsIDMap.clear();
                    m_activeConnectionsSocketMap.clear();
                }
            }

            void Server::collectActiveConnections(Array<SocketType>& outActiveSockets)
            {
                auto lock = CreateLock(m_activeConnectionsLock);

                for (Int32 i=m_activeConnections.lastValidIndex(); i >= 0; --i)
                {
                    auto* con = m_activeConnections[i];
                    FATAL_ASSERT(con->m_socket);

                    if (con->m_closeRequest.getValue())
                    {
                        TRACE_INFO("TCP Server: Got external request to close connection {} ({}), {}", con->m_id, con->m_address, con->m_socket.getSystemSocket());
                        purgeConnection(con);
                    }
                    else
                    {
                        outActiveSockets.pushBack(con->m_socket.getSystemSocket());
                    }
                }
            }

            void Server::serviceListenerClose()
            {
                if (1 == m_listeningFlag.exchange(0))
                    m_handler->handleServerClose(this);
            }

            void Server::purgeConnection(Connection* con)
            {
                // handle notification
                TRACE_INFO("TCP Server: connection '{}' closed\n{}", con->m_address, con->m_stats);
                m_handler->handleConnectionClosed(this, con->m_address, con->m_id);

                // socket is dead, it's now safe place to delete it
                m_activeConnectionsSocketMap.remove(con->m_socket.getSystemSocket());
                m_activeConnectionsIDMap.remove(con->m_id);
                m_activeConnections.remove(con);

                // close handle
                con->m_socket.close();

                // cleanup object
                MemDelete(con);
            }

            //--

        } // tcp
    } // socket
} // base