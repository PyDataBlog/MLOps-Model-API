/**
 *  one room arena
 *  Copyright (C) 2016 POSITIVE MENTAL ATTITUDE
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, version 3 of the License.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */



#include "Menu.hpp"
#include "Player.hpp"
#include <sstream>

Menu::Menu(): 
	_dead(false),
	_permakilled(false)
{
	_menu.resize(5);

	_menu[0] = new Sprite;
	_badlyAllocatedBannerTexture.loadFromFile("data/menu.png");
	_menu[0]->setTexture(_badlyAllocatedBannerTexture);
	_menu[0]->setPosition(280.f, 90.f);
	_menu[0]->setOrigin((Vector2f)_badlyAllocatedBannerTexture.getSize() / 2.f);
	
	_menu[1] = new Sprite;
	_badlyAllocatedPlayTexture.loadFromFile("data/play.png");
	_menu[1]->setTexture(_badlyAllocatedPlayTexture);
	_menu[1]->setPosition(170.f, 190.f);
	_menu[1]->setOrigin((Vector2f)_badlyAllocatedPlayTexture.getSize() / 2.f);
	
	_menu[2] = new Sprite;
	_badlyAllocatedQuitTexture.loadFromFile("data/quit.png");
	_menu[2]->setTexture(_badlyAllocatedQuitTexture);
	_menu[2]->setPosition(280.f, 270.f);
	_menu[2]->setOrigin((Vector2f)_badlyAllocatedQuitTexture.getSize() / 2.f);
	
	_menu[3] = new Sprite;
	_badlyAllocatedGaemoverTexture.loadFromFile("data/gaemover.png");
	_menu[3]->setTexture(_badlyAllocatedGaemoverTexture);
	_menu[3]->setPosition(384.f, 384.f);
	_menu[3]->setOrigin((Vector2f)_badlyAllocatedGaemoverTexture.getSize() / 2.f);
	
	_menu[4] = new Sprite;
	_badlyAllocatedRetryTexture.loadFromFile("data/retry.png");
	_menu[4]->setTexture(_badlyAllocatedRetryTexture);
	_menu[4]->setPosition(384.f, 584.f);
	_menu[4]->setOrigin((Vector2f)_badlyAllocatedRetryTexture.getSize() / 2.f);
	
	_badlyAllocatedNumberTexture.loadFromFile("data/font.png");
	
	for(unsigned i = 0; i < _menu.size(); ++i)
		_menu[i]->setColor(Color(255, 255, 255, 0));
}

Menu::~Menu()
{
	for(unsigned i = 0; i < _menu.size(); ++i)
		delete _menu[i];
	_menu.clear();
	
	for(unsigned i = 0; i < _number.size(); ++i)
		delete _number[i];
	_number.clear();
}

bool Menu::isDead() const
{
	return _dead; 
}
void Menu::revive(bool permakill)
{
	_dead = false;
	_permakilled = permakill;
	
	if(permakill)
	{
		unsigned score = Player::totalScore;
		std::string str;
		std::stringstream ss;
		ss << score;
		ss >> str;
		_number.resize(str.size());
		for(unsigned i = 0; i < _number.size(); ++i)
		{
			_number[i] = new Sprite;
			_number[i]->setTexture(_badlyAllocatedNumberTexture);
			_number[i]->setPosition(384.f + i * 32.f - _number.size() * 16.f, 484.f);
			_number[i]->setTextureRect(IntRect(32 * (str[i] - '0'), 0, 32, 46));
			_number[i]->setOrigin(16.f, 23.f);
		}
	}
}
void Menu::logic(float delta, const Vector2i mouse, bool& running, bool* keepRunning)
{
	static float transparency = 0.f;
	transparency += delta * 10.f;
	if(transparency > 200.f)
		transparency = 200.f;
	_menu[0]->setColor(Color(255, 255, 255, (int)transparency + 55));
	for(unsigned i = 1; i < _menu.size(); ++i)
		_menu[i]->setColor(Color(255, 255, 255, (int)transparency));
	
	if(!_permakilled)
	{
		for(unsigned i = 1; i < _menu.size() - 1; ++i)
		{
			if(mouse.x > _menu[i]->getPosition().x - _menu[i]->getOrigin().x
			&& mouse.x < _menu[i]->getPosition().x + _menu[i]->getOrigin().x
			&& mouse.y > _menu[i]->getPosition().y - _menu[i]->getOrigin().y
			&& mouse.y < _menu[i]->getPosition().y + _menu[i]->getOrigin().y)
			{
				_menu[i]->setColor(Color(255, 255, 255, (int)transparency + 55));
				if(Mouse::isButtonPressed(Mouse::Left))
				{
					if(i == 1)
						_dead = true;
					else
					{
						running = false;
						*keepRunning = false;
					}
				}
			}
		}
	}
	else
	{
		if(mouse.x > _menu.back()->getPosition().x - _menu.back()->getOrigin().x
			&& mouse.x < _menu.back()->getPosition().x + _menu.back()->getOrigin().x
			&& mouse.y > _menu.back()->getPosition().y - _menu.back()->getOrigin().y
			&& mouse.y < _menu.back()->getPosition().y + _menu.back()->getOrigin().y)
			{
				_menu.back()->setColor(Color(255, 255, 255, (int)transparency + 55));
				if(Mouse::isButtonPressed(Mouse::Left))
				{
					running = false;
					*keepRunning = true;
				}
			}
	}
}
void Menu::render(RenderTarget& target) const
{
	if(!_permakilled)
	{
		for(unsigned i = 0; i < _menu.size() - 2; ++i)
			target.draw(*_menu[i]);
	}
	else
	{
		for(unsigned i = 0; i < _number.size(); ++i)
			target.draw(*_number[i]);
		target.draw(*_menu[_menu.size() - 2]);
		target.draw(*_menu[_menu.size() - 1]);
	}
}
