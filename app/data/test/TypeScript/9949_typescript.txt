import { IApiErrorResponse, ModelApi } from "@chiubaka/core";
import { LOCATION_CHANGE, LocationChangeAction } from "react-router-redux";
import { Action } from "redux";

import { Intent, Toaster } from "@blueprintjs/core";
import { ActionTypes, IFilterByEnergy, IFilterByTimeEstimate, IToggleTagFilter } from "../actions/types";
import { Constants } from "../constants/index";
import { ITask, TaskState } from "../model/index";
import { IUiState } from "../model/SerenityState";
import { todayDateString } from "../utils/index";

const ErrorToaster = Toaster.create();

function defaultTaskDataForPathname(pathname: string): Partial<ITask> {
  switch (pathname) {
    case Constants.INBOX_PATH:
      return {
        state: TaskState.Inbox,
      };
    case Constants.NEXT_PATH:
      return {
        state: TaskState.Next,
      };
    case Constants.WAITING_PATH:
      return {
        state: TaskState.Waiting,
      };
    case Constants.SNOOZED_PATH:
      return {
        state: TaskState.Snoozed,
      };
    case Constants.SCHEDULED_PATH:
    case Constants.TODAY_PATH:
      return {
        scheduledDate: todayDateString(),
        state: TaskState.Scheduled,
      };
    default:
      return {
        state: TaskState.Inbox,
      };
  }
}

export function ui(state: IUiState = null, action: Action): IUiState {
  switch (action.type) {
    case ActionTypes.START_CREATING_TASK:
      return {...state, creatingTask: true};
    case ActionTypes.FINISH_CREATING_TASK:
      return {...state, creatingTask: false};
    case LOCATION_CHANGE:
      const pathname = (action as LocationChangeAction).payload.pathname;
      return {
        ...state,
        creatingTask: false,
        newTaskDefaultData: defaultTaskDataForPathname(pathname),
        activeTaskFilters: {
          dueDate: false,
        },
      };
    case ActionTypes.CLEAR_FILTERS:
      return {
        ...state,
        activeTaskFilters: {
          dueDate: false,
        },
      };
    case ActionTypes.TOGGLE_DUE_DATE_FILTER:
      return {
        ...state,
        activeTaskFilters: {
          ...state.activeTaskFilters,
          dueDate: !state.activeTaskFilters.dueDate,
        },
      };
    case ActionTypes.TOGGLE_TAG_FILTER:
      const tags = new Set(state.activeTaskFilters.tags);
      const toggleTagId = (action as IToggleTagFilter).id;

      if (tags.has(toggleTagId)) {
        tags.delete(toggleTagId);
      } else {
        tags.add(toggleTagId);
      }

      return {
        ...state,
        activeTaskFilters: {
          ...state.activeTaskFilters,
          tags: tags.size  > 0 ? tags : undefined,
        },
      };
    case ActionTypes.FILTER_BY_ENERGY:
      const energy = (action as IFilterByEnergy).value;
      return {
        ...state,
        activeTaskFilters: {
          ...state.activeTaskFilters,
          energy,
        },
      };
    case ActionTypes.FILTER_BY_TIME_ESTIMATE:
      const timeEstimate = (action as IFilterByTimeEstimate).value;
      return {
        ...state,
        activeTaskFilters: {
          ...state.activeTaskFilters,
          timeEstimate,
        },
      };
    case ModelApi.UNSUCCESSFUL_API_REQUEST_TYPE:
      const messages = new Set(ErrorToaster.getToasts().map((props) => props.message));

      const message = (action as IApiErrorResponse).reason;
      if (!messages.has(message)) {
        ErrorToaster.show({
          message: (action as IApiErrorResponse).reason,
          intent: Intent.DANGER,
        });
      }
      return state;
    default:
      return state;
  }
}
