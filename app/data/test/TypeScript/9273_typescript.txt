///<reference path="engine/dimension.ts"/>
///<reference path="engine/position.ts"/>
///<reference path="engine/engine.ts"/>
///<reference path="engine/bounds.ts"/>

///<reference path="timeManager.ts"/>

///<reference path="input/eventSet.ts"/>
///<reference path="input/keyboardKeys.ts"/>
///<reference path="input/xboxControllerKeyMap.ts"/>
///<reference path="input/inputManager.ts"/>

///<reference path="game/gameStates.ts"/>
///<reference path="game/gameManager.ts"/>

///<reference path="rendering/spriteManager.ts"/>
///<reference path="rendering/spriteIndexs.ts"/>
///<reference path="rendering/textureManager.ts"/>
///<reference path="rendering/camera.ts"/>
///<reference path="rendering/screenManager.ts"/>

///<reference path="rendering/renderer.ts"/>

///<reference path="entities/events.ts"/>
///<reference path="entities/characterType.ts"/>
///<reference path="entities/statsType.ts"/>
///<reference path="entities/stats.ts"/>
///<reference path="entities/player.ts"/>
///<reference path="entities/playerIndex.ts"/>
///<reference path="entities/entityManager.ts"/>

///<reference path="world/world.ts"/>
///<reference path="world/worldLayer.ts"/>
///<reference path="world/worldManager.ts"/>

"use strict";
/**
 * The Last Pastry
 * @author TheMuffinCoder (a.k.a Sebastian)
 */
module PastryCore {

	/*
	export class CharacterAnimation {

		constructor(public idleLeft: SpriteIndexs, public idleRight: SpriteIndexs, public idleFront: SpriteIndexs, public idleBack: SpriteIndexs) {



		}

	}
	export class AnimationManager {

		static spriteSets: Array<CharacterAnimation> = [

			///*muffin */// new CharacterAnimation(SpriteIndexs.muffinLeftIdle, SpriteIndexs.muffinRightIdle, SpriteIndexs.muffinFrontIdle, SpriteIndexs.muffinBackIdle),
			///*toaster*/

		//];

	//}

}

interface PastryFrameWork {

	VERSION: number;

	engine: PastryCore.Engine;
	timeManager: PastryCore.TimeManager;
	inputManager: PastryCore.InputManager;
	gameManager: PastryCore.GameManager;
	entityManager: PastryCore.EntityManager;
	renderer: PastryCore.Renderer;
	worldManager: PastryCore.WorldManager;

	main(): void;
	loop(): void;
	resourcesLoaded(): void;

}

var PASTRY: PastryFrameWork = {

	VERSION: 1,

	engine: new PastryCore.Engine(),
	timeManager: new PastryCore.TimeManager(),
	inputManager: new PastryCore.InputManager(),
	gameManager: new PastryCore.GameManager(),
	renderer: new PastryCore.Renderer(),
	entityManager: new PastryCore.EntityManager(),
	worldManager: new PastryCore.WorldManager(),

	main: function (): void {

		PASTRY.renderer.init();

	},

	resourcesLoaded: function (): void {

		PastryCore.Engine.log("Resources loaded!");

		PASTRY.inputManager.init();

		window.onresize = () => {

			PASTRY.inputManager.onResize();
			PASTRY.renderer.resize();

		};

		PASTRY.renderer.resize();

		PASTRY.worldManager.newWorld("o3ytou", 50);
		PASTRY.entityManager.playerOne.setPosition(PASTRY.worldManager.currentWorld.getSpawn());

		PASTRY.loop();

	},

	loop: function (): void {

		PASTRY.timeManager.update();
		PASTRY.inputManager.update();
		PASTRY.renderer.refreshBuffer();

		switch (PASTRY.gameManager.currentState) {

			case PastryCore.GameStates.INGAME:

				PASTRY.entityManager.update(PASTRY.worldManager.currentWorld);

				PASTRY.renderer.drawInGame(PASTRY.entityManager, PASTRY.worldManager.currentWorld);
				break;

			case PastryCore.GameStates.LOADING:



				break;

			case PastryCore.GameStates.MAIN:



				break;

			case PastryCore.GameStates.PAUSED:



				break;
		}

		PASTRY.renderer.render();

		requestAnimationFrame(PASTRY.loop);
	}
};

PASTRY.main();