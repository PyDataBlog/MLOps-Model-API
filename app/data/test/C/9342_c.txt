/* Generated by CIL v. 1.7.0 */
/* print_CIL_Input is false */

struct _1_sort__opaque_Node_1;
struct _IO_FILE;
struct timeval;
extern void signal(int sig , void *func ) ;
extern float strtof(char const   *str , char const   *endptr ) ;
typedef unsigned long size_t;
typedef struct _IO_FILE FILE;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
extern double strtod(char const   *str , char const   *endptr ) ;
extern int fclose(void *stream ) ;
extern void *fopen(char const   *filename , char const   *mode ) ;
extern void abort() ;
extern void exit(int status ) ;
extern int raise(int sig ) ;
extern int fprintf(struct _IO_FILE *stream , char const   *format  , ...) ;
extern int rand() ;
extern unsigned long strtoul(char const   *str , char const   *endptr , int base ) ;
typedef struct _1_sort__opaque_Node_1 *_1_sort__opaque_List_1;
extern int strncmp(char const   *s1 , char const   *s2 , unsigned long maxlen ) ;
struct _1_sort__opaque_Node_1 {
   int data ;
   struct _1_sort__opaque_Node_1 *next ;
};
struct _1_sort__opaque_Node_1 *_1_sort__opaque_list2_1  =    (struct _1_sort__opaque_Node_1 *)0;
extern int gettimeofday(struct timeval *tv , void *tz  , ...) ;
extern int printf(char const   * __restrict  __format  , ...) ;
int main(int argc , char **argv ) ;
void megaInit(void) ;
extern unsigned long strlen(char const   *s ) ;
void sort(int *mlist , int size ) ;
extern long strtol(char const   *str , char const   *endptr , int base ) ;
struct _1_sort__opaque_Node_1 *_1_sort__opaque_list1_1  =    (struct _1_sort__opaque_Node_1 *)0;
extern unsigned long strnlen(char const   *s , unsigned long maxlen ) ;
extern void *memcpy(void *s1 , void const   *s2 , unsigned long size ) ;
struct timeval {
   long tv_sec ;
   long tv_usec ;
};
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
extern int scanf(char const   *format  , ...) ;
void sort(int *mlist , int size ) 
{ 
  int i ;
  int j ;
  int tmp ;
  int i6 ;
  int r7 ;
  struct _1_sort__opaque_Node_1 *p8 ;
  int _1_sort__BEGIN_0 ;
  int _1_sort__END_0 ;
  int _1_sort__BARRIER_1 ;
  unsigned long _2_sort_next ;

  {
  {  /* __blockattribute__(__ATOMIC__)*/ 
  _1_sort__BEGIN_0 = 1;
  i6 = 0;
  while (i6 < 2) {
    r7 = rand();
    p8 = (struct _1_sort__opaque_Node_1 *)malloc(sizeof(struct _1_sort__opaque_Node_1 ));
    if (p8 != (struct _1_sort__opaque_Node_1 *)0UL) {
      p8->data = r7;
      if (_1_sort__opaque_list1_1 != (struct _1_sort__opaque_Node_1 *)0UL) {
        p8->next = _1_sort__opaque_list1_1->next;
        _1_sort__opaque_list1_1->next = p8;
      } else {
        p8->next = p8;
        _1_sort__opaque_list1_1 = p8;
      }
    } else {

    }
    i6 ++;
  }
  _1_sort__opaque_list2_1 = _1_sort__opaque_list1_1;
  _1_sort__END_0 = 1;
  }
  _1_sort__BARRIER_1 = 1;
  _2_sort_next = 12 * ! (_1_sort__opaque_list2_1 == (struct _1_sort__opaque_Node_1 *)0UL);
  while (1) {
    switch (_2_sort_next) {
    case 0: ;
    return;
    break;
    case 10: ;
    if (i < size - 1) {
      _2_sort_next = 8 + (_1_sort__opaque_list1_1 == (struct _1_sort__opaque_Node_1 *)0UL);
    } else {
      _2_sort_next = (unsigned long )(_1_sort__opaque_list1_1 != _1_sort__opaque_list2_1) + (unsigned long )(_1_sort__opaque_list1_1 != _1_sort__opaque_list2_1);
    }
    break;
    case 12: 
    i = 0;
    _2_sort_next = 10 - ! (_1_sort__opaque_list2_1 != (struct _1_sort__opaque_Node_1 *)0UL);
    break;
    case 4: ;
    if (*(mlist + j) > *(mlist + (j + 1))) {
      _2_sort_next = ((unsigned long )(_1_sort__opaque_list2_1 != (struct _1_sort__opaque_Node_1 *)0UL) - (unsigned long )(_1_sort__opaque_list2_1 == (struct _1_sort__opaque_Node_1 *)0UL)) + ((unsigned long )(! ((unsigned long )(_1_sort__opaque_list1_1 != _1_sort__opaque_list2_1))) + 1);
    } else {
      _2_sort_next = (unsigned long )(! ((unsigned long )(_1_sort__opaque_list1_1 != _1_sort__opaque_list2_1))) + 1;
    }
    break;
    case 14: 
    *(mlist + j) = *(mlist + (j + 1));
    _2_sort_next = _1_sort__opaque_list1_1 != (struct _1_sort__opaque_Node_1 *)0UL ? 13 : 5;
    break;
    case 2: 
    j ++;
    _2_sort_next = 6 - (_1_sort__opaque_list1_1 == (struct _1_sort__opaque_Node_1 *)0UL);
    break;
    case 13: 
    *(mlist + (j + 1)) = tmp;
    _2_sort_next = ((unsigned long )(_1_sort__opaque_list1_1 == (struct _1_sort__opaque_Node_1 *)0UL) + (unsigned long )(_1_sort__opaque_list1_1 == _1_sort__opaque_list2_1)) + 1;
    break;
    case 8: 
    j = 0;
    _2_sort_next = _1_sort__opaque_list1_1 != _1_sort__opaque_list2_1 ? 2 : 6;
    break;
    case 6: ;
    if (j < (size - 1) - i) {
      _2_sort_next = 4 + ((_1_sort__opaque_list1_1 != _1_sort__opaque_list2_1) + (_1_sort__opaque_list1_1 != _1_sort__opaque_list2_1));
    } else {
      _2_sort_next = (unsigned long )(! ((unsigned long )(_1_sort__opaque_list2_1 == (struct _1_sort__opaque_Node_1 *)0UL)));
    }
    break;
    case 1: 
    i ++;
    _2_sort_next = 10 - ((_1_sort__opaque_list1_1 != (struct _1_sort__opaque_Node_1 *)0UL) - (_1_sort__opaque_list1_1 != (struct _1_sort__opaque_Node_1 *)0UL));
    break;
    case 3: 
    tmp = *(mlist + j);
    _2_sort_next = 14 - ((_1_sort__opaque_list1_1 == (struct _1_sort__opaque_Node_1 *)0UL) + (_1_sort__opaque_list1_1 == (struct _1_sort__opaque_Node_1 *)0UL));
    break;
    }
  }
}
}
void megaInit(void) 
{ 


  {

}
}
int main(int argc , char **argv ) 
{ 
  int size_of_list ;
  int tmp ;
  int *list ;
  void *tmp___0 ;
  int i ;
  int i___0 ;

  {
  megaInit();
  tmp = atoi((char const   *)*(argv + 1));
  size_of_list = tmp;
  tmp___0 = malloc((unsigned long )size_of_list * sizeof(int ));
  list = (int *)tmp___0;
  i = 0;
  while (i < size_of_list) {
    *(list + i) = atoi((char const   *)*(argv + (2 + i)));
    i ++;
  }
  sort(list, size_of_list);
  i___0 = 0;
  while (i___0 < size_of_list) {
    printf((char const   */* __restrict  */)"%d", *(list + i___0));
    i___0 ++;
  }
  printf((char const   */* __restrict  */)"\n");
  return (0);
}
}
