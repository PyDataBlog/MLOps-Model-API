/*
 * @brief llib zpaq cpp header
 * @author (c) Nicolas Provost 2012-2014
 */
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

#ifndef __LLIB_ZPAQ_HPP
#define __LLIB_ZPAQ_HPP

#ifdef __cplusplus
extern "C"
{
#endif
#include "llib_types.h"
#include "llib_mem.h"
#include "llib_sys.h"
#include "llib_str.h"
#ifdef __cplusplus /* CPP part */
}
#endif

enum
{
	LLIB_ZPAQ_INIT=0,
	LLIB_ZPAQ_PASS=1,
	LLIB_ZPAQ_LOADING1=2,
	LLIB_ZPAQ_LOADING2=3,
	LLIB_ZPAQ_LOADING3=4,
	LLIB_ZPAQ_POST=5,
};

/** compression level for ZPAQ */
enum
{
	LLIB_ZPAQ_X_NONE=0,	/**< no compression */
	LLIB_ZPAQ_X_MIN=1,	/**< ZPAQ built-in level 1 */
	LLIB_ZPAQ_X_MID=2,	/**< ZPAQ built-in level 2 */
	LLIB_ZPAQ_X_MAX=3,	/**< ZPAQ built-in level 3 */
	LLIB_ZPAQ_X_LZ77=4,	/**< LZ77 preprocessing */
};

typedef unsigned char llib_zpaq_sha1_t[20];

/* declarations */
#ifdef __cplusplus /* CPP part */
#include "libzpaq.h"
#include "llib_zpaq_rw.h"

class llib_zpaq_compressor_t : public libzpaq::Compressor
{
	public:
		llib_zpaq_compressor_t();
		~llib_zpaq_compressor_t();
		void setError(const char*);
		void error(const char* msg);
		lbool haveError();
		const char* getError();
		lbool initInput(int fd, lbool lz);
		lbool initInput(const unsigned char* buf, llib_size_t len, lbool lz);
		lbool initOutput(int fd);
		lbool initOutput(unsigned char* buf, llib_size_t len);
		lbool getLZ77();

		libzpaq::Writer zout;
		libzpaq::Reader in;
		libzpaq::Writer out;
		int level;

	private:
		lbool lz77;
		const char* strerror;
};

class llib_zpaq_decompresser_t : public libzpaq::Decompresser
{
	public:
		llib_zpaq_decompresser_t();
		~llib_zpaq_decompresser_t();
		void setError(const char*);
		void error(const char* msg);
		lbool haveError();
		const char* getError();
		unsigned char* getSHA1();
		lbool initInput(int fd);
		lbool initInput(const unsigned char* buf, llib_size_t len);
		lbool initOutput(int fd);
		lbool initOutput(unsigned char* buf, llib_size_t len);

		libzpaq::SHA1 sha1;
		libzpaq::Writer zout;
		libzpaq::Reader in;
		libzpaq::Writer out;

	private:
		const char* strerror;
};

#else /* C part */

typedef struct llib_zpaq_compressor_t llib_zpaq_compressor_t;
typedef struct llib_zpaq_decompresser_t llib_zpaq_decompresser_t;

#endif

/* functions */
#ifdef __cplusplus /* CPP part */
extern "C" {
#endif

llib_zpaq_compressor_t* llib_zpaq_x_compressor_init();
lbool llib_zpaq_x_compressor_free(llib_zpaq_compressor_t** comp);
lbool llib_zpaq_x_compressor_init_input(llib_zpaq_compressor_t* comp, int fd, const unsigned char* buf, llib_size_t len, lbool lz);
lbool llib_zpaq_x_compressor_init_output(llib_zpaq_compressor_t* comp, int fd, unsigned char* buf, llib_size_t len);
lbool llib_zpaq_x_compressor_write_tag(llib_zpaq_compressor_t* comp);
const char* llib_zpaq_x_compressor_get_error(llib_zpaq_compressor_t* comp);
lbool llib_zpaq_x_compressor_start_block_hcomp(llib_zpaq_compressor_t* comp, const char* hcomp);
lbool llib_zpaq_x_compressor_start_block_level(llib_zpaq_compressor_t* comp, int level);
lbool llib_zpaq_x_compressor_set_verify(llib_zpaq_compressor_t* comp, lbool v);
lbool llib_zpaq_x_compressor_start_segment(llib_zpaq_compressor_t* comp, const char* filename, const char* comment);
lbool llib_zpaq_x_compressor_post_process(llib_zpaq_compressor_t* comp, const char* pcomp, int len);
lbool llib_zpaq_x_compressor_compress(llib_zpaq_compressor_t* comp, int n);
lbool llib_zpaq_x_compressor_end_segment(llib_zpaq_compressor_t* comp, llib_zpaq_sha1_t*);
lbool llib_zpaq_x_compressor_end_segment_checksum(llib_zpaq_compressor_t* comp, lint64* size, llib_zpaq_sha1_t);
lint64 llib_zpaq_x_compressor_get_size(llib_zpaq_compressor_t* comp);
lbool llib_zpaq_x_compressor_get_checksum(llib_zpaq_compressor_t* comp, llib_zpaq_sha1_t);
lbool llib_zpaq_x_compressor_end_block(llib_zpaq_compressor_t* comp);
int llib_zpaq_x_compressor_stat(llib_zpaq_compressor_t* comp, int x);
lbool llib_zpaq_x_compressor_hcomp(llib_zpaq_compressor_t* comp, unsigned char*, llib_size_t);
lbool llib_zpaq_x_compressor_pcomp(llib_zpaq_compressor_t* comp, unsigned char*, llib_size_t);
const char* llib_zpaq_x_compressor_error(llib_zpaq_compressor_t* comp);
luint64 llib_zpaq_x_compressor_output_length (llib_zpaq_compressor_t* comp);

llib_zpaq_decompresser_t* llib_zpaq_x_decompresser_init();
lbool llib_zpaq_x_decompresser_free(llib_zpaq_decompresser_t** dcomp);
lbool llib_zpaq_x_decompresser_init_input(llib_zpaq_decompresser_t* dcomp, int fd, const unsigned char* buf, llib_size_t len);
lbool llib_zpaq_x_decompresser_init_output(llib_zpaq_decompresser_t* dcomp, int fd, unsigned char* buf, llib_size_t len);
const char* llib_zpaq_x_decompresser_get_error(llib_zpaq_decompresser_t* dcomp);
int llib_zpaq_x_decompresser_stat(llib_zpaq_decompresser_t* comp, int x);
lbool llib_zpaq_x_decompresser_find_block(llib_zpaq_decompresser_t* dcomp, luint64* mem);
lbool llib_zpaq_x_decompresser_hcomp(llib_zpaq_decompresser_t* dcomp, unsigned char*, llib_size_t);
lbool llib_zpaq_x_decompresser_find_filename(llib_zpaq_decompresser_t* dcomp, char* buf, llib_size_t len);
lbool llib_zpaq_x_decompresser_read_comment(llib_zpaq_decompresser_t* dcomp, char* buf, llib_size_t len);
lbool llib_zpaq_x_decompresser_decompress(llib_zpaq_decompresser_t* dcomp, int n);
lbool llib_zpaq_x_decompresser_pcomp(llib_zpaq_decompresser_t* dcomp, unsigned char*, llib_size_t);
lbool llib_zpaq_x_decompresser_read_segment_end(llib_zpaq_decompresser_t* dcomp, llib_zpaq_sha1_t* sha1, lbool* sha1_valid);
lbool llib_zpaq_x_decompresser_check_sha1(llib_zpaq_decompresser_t* dcomp, llib_zpaq_sha1_t sha1);
const char* llib_zpaq_x_decompresser_error(llib_zpaq_decompresser_t* dcomp);
luint64 llib_zpaq_x_decompresser_output_length (llib_zpaq_decompresser_t* dcomp);
luint64 llib_zpaq_x_decompresser_input_length (llib_zpaq_decompresser_t* dcomp);
void llib_zpaq_x_decompresser_input_no_end (llib_zpaq_decompresser_t* dcomp, lbool b);

#ifdef __cplusplus /* CPP part */
}
#endif

/** model for LZ77 */
LLIB_UNUSED
static const char* llib_zpaq_x_model_lz77 =
{
	"comp 9 16 0 $1+20 0\n"
	"hcomp\n"
	"c-- *c=a a+= 255 d=a *d=c\n"
	"halt\n"
	"pcomp lazy2 3 ;\n"
	" (r1 = state\n"
	"  r2 = len - match or literal length\n"
	"	  r3 = m - number of offset bits expected\n"
	"  r4 = ptr to buf\n"
	"  r5 = r - low bits of offset\n"
	"  c = bits - input buffer\n"
	"  d = n - number of bits in c)\n"
	"\n"
	"  a> 255 if\n"
	"    (reset state)\n"
	"    a=0 b=0 c=0 d=0 r=a 1 r=a 2 r=a 3 r=a 4\n"
	"    halt\n"
	"  endif\n"
	"\n"
	"  a<<=d a+=c c=a               (bits+=a<<n)\n"
	"  a= 8 a+=d d=a                (n+=8)\n"
	"\n"
	"  (if state==0 (expect new code))\n"
	"  a=r 1 a== 0 if (match code mm,mmm)\n"
	"    a= 1 r=a 2                 (len=1)\n"
	"    a=c a&= 3 a> 0 if          (if (bits&3))\n"
	"      a-- a<<= 3 r=a 3           (m=((bits&3)-1)*8)\n"
	"      a=c a>>= 2 c=a             (bits>>=2)\n"
	"      b=r 3 a&= 7 a+=b r=a 3     (m+=bits&7)\n"
	"   	   a=c a>>= 3 c=a             (bits>>=3)\n"
	"      a=d a-= 5 d=a              (n-=5)\n"
	"      a= 1 r=a 1                 (state=1)\n"
	"    else (literal, discard 00)\n"
	"      a=c a>>= 2 c=a             (bits>>=2)\n"
	"      d-- d--                    (n-=2)\n"
	"      a= 3 r=a 1                 (state=3)\n"
	"    endif\n"
	"  endif\n"
	"\n"
	"  (while state==1 && n>=3 (expect match length n*4+ll -> r2))\n"
	"  do a=r 1 a== 1 if a=d a> 2 if\n"
	"    a=c a&= 1 a== 1 if         (if bits&1)\n"
	"      a=c a>>= 1 c=a             (bits>>=1)\n"
	"      b=r 2 a=c a&= 1 a+=b a+=b r=a 2 (len+=len+(bits&1))\n"
	"      a=c a>>= 1 c=a             (bits>>=1)\n"
	"      d-- d--                    (n-=2)\n"
	"    else\n"
	"      a=c a>>= 1 c=a             (bits>>=1)\n"
	"      a=r 2 a<<= 2 b=a           (len<<=2)\n"
	"      a=c a&= 3 a+=b r=a 2       (len+=bits&3)\n"
	"      a=c a>>= 2 c=a             (bits>>=2)\n"
	"      d-- d-- d--                (n-=3)\n"
	"      a= 2 r=a 1                 (state=2)\n"
	"    endif\n"
	"  forever endif endif\n"
	"\n"
	"  (if state==2 && n>=m) (expect m offset bits)\n"
	"  a=r 1 a== 2 if a=r 3 a>d ifnot\n"
	"    a=c r=a 6 a=d r=a 7          (save c=bits, d=n in r6,r7)\n"
	"    b=r 3 a= 1 a<<=b d=a         (d=1<<m)\n"
	"    a-- a&=c a+=d                (d=offset=bits&((1<<m)-1)|(1<<m))\n"
	"    d=a b=r 4 a=b a-=d c=a       (c=p=(b=ptr)-offset)\n"
	"\n"
	"    (while len-- (copy and output match d bytes from *c to *b))\n"
	"    d=r 2 do a=d a> 0 if d--\n"
	"      a=*c *b=a c++ b++          (buf[ptr++]-buf[p++])\n"
	" out\n"
	"    forever endif\n"
	"    a=b r=a 4\n"
	"\n"
	"    a=r 6 b=r 3 a>>=b c=a        (bits>>=m)\n"
	"    a=r 7 a-=b d=a               (n-=m)\n"
	"    a=0 r=a 1                    (state=0)\n"
	"  endif endif\n"
	"\n"
	"  (while state==3 && n>=2 (expect literal length))\n"
	"  do a=r 1 a== 3 if a=d a> 1 if\n"
	"    a=c a&= 1 a== 1 if         (if bits&1)\n"
	"      a=c a>>= 1 c=a              (bits>>=1)\n"
	"      b=r 2 a&= 1 a+=b a+=b r=a 2 (len+=len+(bits&1))\n"
	"      a=c a>>= 1 c=a              (bits>>=1)\n"
	"      d-- d--                     (n-=2)\n"
	"    else\n"
	"      a=c a>>= 1 c=a              (bits>>=1)\n"
	"      d--                         (--n)\n"
	"      a= 4 r=a 1                  (state=4)\n"
	"    endif\n"
	"  forever endif endif\n"
	"\n"
	"  (if state==4 && n>=8 (expect len literals))\n"
	"  a=r 1 a== 4 if a=d a> 7 if\n"
	"    b=r 4 a=c *b=a\n"
	" out\n"
	"    b++ a=b r=a 4                 (buf[ptr++]=bits)\n"
	"    a=c a>>= 8 c=a                (bits>>=8)\n"
	"    a=d a-= 8 d=a                 (n-=8)\n"
	"    a=r 2 a-- r=a 2 a== 0 if      (if --len<1)\n"
	"      a=0 r=a 1                     (state=0)\n"
	"    endif\n"
	"  endif endif\n"
	"  halt\n"
	"end\n"
};

#endif
