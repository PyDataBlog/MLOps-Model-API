Our induction module is still a work-in-progress.  We close with related work
and our future directions for this module.

\subsection{Related Work}

Our work is inspired by two other educational efforts here at the University of
Pennsylvania.  The first is our efforts to introduce functional programming into
our CS2 course~\cite{zdancewic:cis120:2013} which is an exemplar in the 2013
curriculum revision~\cite{curricula:2013}.  This course features the OCaml
programming language in its first half to give students a firm mathematical
foundation to their programming endeavors as well as level the playing field
among the diverse students we find in our introductory sequence.  The second is
our graduate-level programming languages course, Software
Foundations~\cite{pierce:sf:2012}, which features the Coq proof assistant.  In
particular, the course features a rapid introduction to functional programming
in Gallina, Coq's specification language, and proving basic properties over
those specifications with Coq's tactics language.  Our module can be seen as a
refinement of this process, tailor-made for the purpose of learning induction.

Other universities have also adopted functional programming early in the
curriculum.  Most notably, Carnegie Mellon University's Principles of Functional
Programming course~\cite{cmu:cs15150:2013}, features a module on proving
properties of simple functional programs.  In this case, the properties are
proven on paper only, without the aid of a proof assistant.

Finally, proof assistants themselves have been used as the primary learning
vehicle in a variety of classes.  The aforementioned Software Foundations course
at the University of Pennsylvania is one such example.  A more closely related
example to our work is the ProofWeb online proof
assistant~\cite{kaliszyk:proofweb:1999}.  ProofWeb acts as an online front-end
for a variety of proof assistants and has been used in several classes ranging
from formal logic to type theory.  ProofWeb exposes the full power of the proof
assistant to the user which makes it too heavyweight for our more modest
purposes.

Notably, the University of Oklahoma and Northeastern both have used ACL2 in the
context of software engineering and introductory programming courses to expose
students to the power of combining programming with theorem
proving~\cite{page:fpt:2008}.  In particular, the ACL2
Dracula~\cite{eastlund:acl2:2009} and the ACL2 Sedan
(ACL2s)~\cite{chamarthi:ast:2011} projects demonstrate the potential of
employing theorem proving to link theory with programming.  Like \minifn,
Dracula and ACL2s both provide interfaces to the students that tightly
interweave the act of programming and proof.  However, where these efforts
differ from \minifn is that \minifn requires the student build the proof
manually whereas ACL2 automatically searches for the proof.  This difference
reflects the different philosophies of the two projects.  The efforts around
ACL2 Dracula and ACL2s are designed to expose students to software verification
with practical theorem proving tools whereas \minifn strives for the more modest
goal of helping students understand the mechanics of inductive proofs and
bridging formal and informal reasoning.

\subsection{Future Work}

Our induction module and the \minifn system are both in the early
proof-of-concept stage.  We are currently refining the flow of the module, the
examples we present, and layout and presentation of the tutorial.

\subsubsection{Improvement}

As mentioned previously, \minifn is backed by the Coq proof assistant.  The
initial version of \minifn is heavily influenced by this decision.  In
particular, the \minifn proof commands are taken from the Coq tactics language.
While this has made our proof-of-concept easier to implement, these commands may
not be ideal as a surface language for the student.  For example, we likely want
to force the student to explicitly name the cases they expect when performing a
\texttt{destruct} or \texttt{induction}, \eg, \texttt{induction: n = O, n = S
n'}, something that Coq does not natively provide.  This way, the proof script
that they write better reflects the structure of the proof.  Other syntactic
improvements are certainly possible to provide the student with a better
experience.

Another area of improvement is extending the tutorial to cover more advanced
topics regarding induction proofs.  For example, one of the most difficult
concepts for students is knowing when to strengthen their induction hypothesis.
We believe that machine-checked proofs will help demystify this process for the
student.  However, the addition of more complicated proofs will likely require
that we extend \minifn with extra machinery or commands which will need to
balanced against keeping the system tractable for students to learn.

One final area of improvement, and one of our motivations for pursuing this line
of work, is employing the techniques of program synthesis to automatically
generate practice induction problems and solutions as well as give feedback to
the student~\cite{gulwani:tr:2013}.  We believe that our approach gives us
additional leverage in this domain because our choice of using Coq as the
back-end means that our proofs and programs have a ``programmatic''
representation in the Calculus of Inductive Constructions that can be amendable
to existing synthesis techniques with some adaption, \eg,
sketching~\cite{solar-lezama:thesis:2008}.

\subsubsection{Deployment}

We plan on releasing our work along two vectors:

\begin{enumerate}
\item Internally as an augmentation to the induction portion of our discrete
  mathematics class (CIS 160) in the spring and
\item Externally as a publicly available tutorial usable by anyone over the
  Internet.
\end{enumerate}

The University of Pennsylvania introductory programming sequence (CIS 120, in
particular) uses the OCaml programming language, so the syntax of \minifn
closely resembles OCaml to ease the transition into our module.  This fall we
are planning to pilot the tutorial with a select group of students and TAs from
CIS 160.  After integrating their feedback into our tutorial, we plan to widen
our scope to the whole class.  In this setting, we would like to evaluate the
efficacy of our module with respect to our current, more traditional approach to
teaching induction.  We hypothesize that we will be able to leverage our
student's existing knowledge of OCaml to make learning induction more concrete
and directly applicable to what the student already knows: programming.

Furthermore, one of the major appeals of this work is its potential to scale
well to situations outside of the UPenn classroom.  We plan on continuing to
refine our web offering of the module so that interested educators can use it
either as a supplement or even potential replacement to their current methods
for teaching induction.  We also hope that by offering our module on the web
that interested students and computer science practitioners that are interested
in strengthening their induction skills find it a useful resource.
