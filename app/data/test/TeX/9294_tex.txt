\chapter{Einf\"uhrung}
\section{Motivation}
Im ersten Semester haben wir gesehen, wie sich Probleme durch die Benutzung von Mengen und
Relationen formulieren und l\"osen lassen.  Eine Frage blieb dabei allerdings unbeantwortet:
Mit welchen Datenstrukturen lassen sich Mengen und Relationen am besten darstellen und mit welchen
Algorithmen lassen sich die Operationen, mit denen wir in der Mengenlehre gearbeitet haben, am
effizientesten realisieren? 
Die Vorlesung \emph{Algorithmen und Datenstrukturen} beantwortet diese Frage sowohl f\"ur die
Datenstrukturen Mengen und Relationen als auch f\"ur einige andere Datenstrukturen, die in der
Informatik eine wichtige Rolle spielen.

\subsection{\"Uberblick}
Die Vorlesung \emph{Algorithmen und Datenstrukturen} besch\"aftigt sich mit dem Design und
der Analyse von Algorithmen und den diesen Algorithmen zugrunde liegenden
Daten-Strukturen.  Im Detail werden wir die folgenden Themen behandeln:
\begin{enumerate}
\item Unl\"osbarkeit des Halte-Problems

      Zu Beginn der Vorlesung zeigen wir die Grenzen der Berechenbarkeit auf
      und beweisen, dass es praktisch relevante Funktionen gibt, die sich nicht durch
      Programme berechnen lassen.  Konkret werden wir zeigen, dass es kein \textsc{SetlX}-Programm
      gibt, dass f\"ur eine gegebene \textsc{SetlX}-Funktion $f$ und ein gegebenes Argument
      $s$ entscheidet, ob der Aufruf $f(s)$ terminiert.
\item Komplexit\"at von Algorithmen

      Um die Komplexit\"at von Algorithmen behandeln zu k\"onnen, f\"uhren wir zwei
      Hilfsmittel aus der Mathematik ein.
      \begin{enumerate}
      \item \emph{Rekurrenz-Gleichungen} sind die diskrete Varianten der
            Differential-Gleichungen.  Diese Gleichungen treten bei der Analyse
            des Rechenzeit-Verbrauchs rekursiver Funktionen auf.
      \item Die \emph{$\mathcal{O}$-Notation} wird verwendet, um das Wachstumsverhalten 
            von Funktionen kompakt beschreiben zu k\"onnen.  Sie bieten die M\"oglichkeit,
            bei der Beschreibung des des Rechenzeit-Verbrauchs eines Algorithmus von
            unwichtigen Details abstrahieren zu k\"onnen. 
      \end{enumerate}
\item Abstrakte Daten-Typen

      Beim Programmieren treten bestimmte Daten-Strukturen in \"ahnlicher Form
      immer wieder auf.  Diesen Daten-Strukturen liegen sogenannte
      \emph{abstrakte Daten-Typen} zugrunde.  Als konkretes Beispiel
      stellen wir in diesem Kapitel den abstrakten Daten-Typ \textsl{Stack} vor.

      Dieser Teil der Vorlesung \"uberlappt sich mit der Vorlesung zur Sprache \textsl{Java}, 
      denn abstrakte Datentypen sind eine der Grundlagen der Objekt-orientierten Programmierung.
\item Sortier-Algorithmen

      Sortier-Algorithmen sind die in der Praxis mit am h\"aufigsten verwendeten
      Algorithmen.  Da Sortier-Algorithmen zu den einfacheren Algorithmen geh\"oren,
      bieten Sie sich als Einstieg in die Theorie der Algorithmen an.
      Wir behandeln im Einzelnen die folgenden Sortier-Algorithmen:
      \begin{enumerate}
      \item Sortieren durch Einf\"ugen (engl.~\emph{insertion sort}),
      \item Sortieren durch Auswahl (engl.~\emph{min sort}),
      \item Sortieren durch Mischen (engl.~\emph{merge sort}),
      \item Den \emph{Quick-Sort}-Algorithmus von C.~A.~R.~Hoare.
      \end{enumerate}
\item Hoare-Kalk\"ul

      Die wichtigste Eigenschaft eines Algorithmus' ist seine Korrektheit.  Der \emph{Hoare-Kalk\"ul}
      ist ein Verfahren, mit dessen Hilfe die Frage der Korrektheit eines Algorithmus' auf die Frage
      der G\"ultigkeit logischer Formeln reduziert werden kann.  An dieser Stelle werden wir eine
      Br\"ucke zu der im ersten Semester vorgestellten Logik schlagen.
\item Abbildungen
  
      Abbildungen (in der Mathematik auch als Funktionen bezeichnet)
      spielen nicht nur in der Mathematik sondern auch in der Informatik eine wichtige
      Rolle.  Wir behandeln die verschiedene Daten-Strukturen, mit denen sich Abbildungen 
      realisieren lassen.  Im Einzelnen besprechen wir bin\"are B\"aume, AVL-B\"aume und
      Hash-Tabellen.
\item Priorit\"ats-Warteschlangen

      Die Daten-Struktur der Priorit\"ats-Warteschlangen spielt einerseits bei der Simulation von Systemen und
      bei Betriebssystemen eine wichtige Rolle, andererseits  ben\"otigen wir diese Datenstruktur bei der
      Diskussion graphentheoretischer Algorithmen.
\item Graphen
  
      Graphen spielen in vielen Bereichen der Informatik eine wichtige Rolle.
      Beispielsweise basieren die Navigationssysteme, die heute in fast allen Autos zu finden sind,
      auf dem Algorithmus von Dijkstra zur Bestimmung des k\"urzesten Weges.  Wir werden diesen
      Algorithmus in der Vorlesung herleiten.
\item Monte-Carlo-Simulation
  
      Viele interessante Fragen aus der Wahrscheinlichkeits-Theorie lassen sich aufgrund ihrer 
      Komplexit\"at nicht analytisch l\"osen.  Als Alternative bietet sich an, durch Simulation eine 
      approximative L\"osung zu gewinnen.  Als konkretes Beispiel werden wir zeigen, wie
      komplexe Wahrscheinlichkeiten beim Poker-Spiel durch Monte-Carlo-Simulationen bestimmt werden k\"onnen.
\end{enumerate}
Ziel der Vorlesung ist nicht prim\"ar, dass Sie m\"oglichst viele Algorithmen und
Daten-Strukturen kennen lernen.  Vermutlich wird es eher so sein, dass Sie viele der
Algorithmen und Daten-Strukturen, die Sie in dieser Vorlesung kennen lernen
werden, sp\"ater nie gebrauchen k\"onnen.  
Worum geht es dann in der Vorlesung?  Das wesentliche Anliegen 
ist es, Sie mit den \emph{Denkweisen} vertraut zu machen, die bei der
Konstruktion und Analyse von Algorithmen verwendet werden.  Sie sollen in die
Lage versetzt werden, algorithmische L\"osungen f\"ur komplexe Probleme
selbstst\"andig zu entwickeln und zu analysieren.  Dabei handelt es sich um einen
 kreativen Prozess, der sich nicht in einfachen Kochrezepten
einfangen l\"asst.  
Wir werden in der Vorlesung versuchen, den Prozess anhand verschiedener
Beispiele zu demonstrieren.  

\section{Algorithmen und Programme}
Gegenstand der Vorlesung ist die Analyse von Algorithmen, nicht die Erstellung von Programmen.  Es
ist wichtig, dass die beiden Begriffe ``\emph{Algorithmus}'' und ``\emph{Programm}'' nicht
verwechselt werden.  Ein \emph{Algorithmus} ist seiner Natur nach zun\"achst einmal ein abstraktes
Konzept, das ein Vorgehen beschreibt um ein gegebenes Problem zu l\"osen.  Im Gegensatz dazu ist ein
\emph{Programm} eine konkrete Implementierungen eines Algorithmus.  Bei einer solchen
Implementierung muss letztlich jedes Detail festgelegt werden, sonst k\"onnte das Programm nicht vom
Rechner ausgef\"uhrt werden.  Bei einem Algorithmus ist das nicht notwendig: Oft wollen wir nur einen
Teil eines Vorgehens beschreiben, der Rest interessiert uns nicht, weil beispielsweise ohnehin klar
ist, was zu tun ist.  Ein Algorithmus l\"asst also eventuell noch Fragen offen.

In Lehrb\"uchern werden Algorithmen oft mit Hilfe von \emph{Pseudo-Code} dargestellt.  Syntaktische
hat Pseudo-Code eine \"ahnliche Form wie ein Programm.  Im Gegensatz zu Programmen kann Pseudo-Code
aber auch nat\"urlich-sprachlichen Text beinhalten. Sie sollten sich aber klar machen, dass
\emph{Pseudo-Code} genau so wenig ein Algorithmus ist, wie ein Programm ein Algorithmus ist, denn
auch der \emph{Pseudo-Code} ist ein konkretes St\"uck Text, wohingen der Algorithmus eine abstrakte
Idee ist.  Allerdings bietet der Pseudo-Code dem Informatiker die M\"oglichkeit, einen Algorithmus auf
der Ebene zu beschreiben, die zur Beschreibung am zweckm\"a{\ss}igisten ist, denn man ist nicht durch die
Zuf\"alligkeiten der Syntax einer Programmier-Sprache eingeschr\"ankt.

Konzeptuell ist der Unterschied zwischen einem Algorithmus und einem Programm vergleichbar mit dem
Unterschied zwischen einer philosophischen Idee und einem Text, der die Idee beschreibt: Die Idee
selbst lebt in den K\"opfen der Menschen, die diese Idee verstanden haben.  Diese Menschen k\"onnen dann
versuchen, die Idee konkret zu fassen und aufzuschreiben.  Dies kann in verschiedenen Sprachen und
mit verschiedenen Worten passieren, es bleibt dieselbe Idee.  Genauso kann ein Algorithmus in
verschiedenen Programmier-Sprachen kodiert werden, es bleibt derselbe Algorithmus.

Nachdem wir uns den Unterschied zwischen einem Algorithmus und einem Programm diskutiert haben,
\"uberlegen wir uns, wie wir Algorithmen beschreiben k\"onnen.  Zun\"achst einmal k\"onnen wir versuchen,
Algorithmen durch nat\"urliche Sprache zu beschreiben.  Nat\"urliche Sprache hat den Vorteil, dass Sie
sehr ausdrucksstark ist: Was wir nicht mit nat\"urlicher Sprache ausdr\"ucken k\"onnen, k\"onnen wir
\"uberhaupt nicht ausdr\"ucken.  Der Nachteil der nat\"urlichen Sprache besteht darin, dass die Bedeutung
nicht immer eindeutig ist.  Hier hat eine Programmier-Sprache den Vorteil, dass die Semantik
wohldefiniert ist.  Allerdings ist es oft sehr m\"uhselig, einen Algorithmus vollst\"andig
auszukodieren, denn es m\"ussen dann Details gekl\"art werden, die f\"ur das Prinzip vollkommen unwichtig
sind.  Es gibt noch eine dritte M\"oglichkeit, Algorithmen zu beschreiben und das ist die Sprache der
Mathematik.  Die wesentlichen Elemente dieser Sprache sind die Pr\"adikaten-Logik und die
Mengen-Lehre.  In diesem Skript werden wir die Algorithmen in dieser Sprache beschreiben.  Um diese
Algorithmen dann auch ausprobieren zu k\"onnen, m\"ussen wir sie in eine Programmier-Sprache \"ubersetzen.
Hier bietet sich \textsc{SetlX} an, denn diese Programmier-Sprache stellt die
Daten-Strukturen Mengen und Funktionen, die in der Mathematik allgegenw\"artig sind, zur
Verf\"ugung.  Sie werden sehen, dass es in \textsc{SetlX} m\"oglich ist, die Algorithmen auf
einem sehr hohen Abstraktions-Niveau darzustellen.  Eine Implementierung der Algorithmen
in \texttt{C++} oder \textsl{Java} ist erheblich aufwendiger.

\section{Eigenschaften von Algorithmen und Programmen}
Bevor wir uns an die Konstruktion von Algorithmen machen, sollten wir uns
\"uberlegen, durch welche Eigenschaften Algorithmen charakterisiert werden und
welche dieser Eigenschaften erstrebenswert sind.
\begin{enumerate}
\item Algorithmen sollen \emph{korrekt} sein.
\item Algorithmen sollen \emph{effizient} sein.
\item Algorithmen sollen m\"oglichst \textbf{einfach} sein.
\end{enumerate}
Die erste dieser Forderung ist so offensichtlich, dass sie oft vergessen wird:
 Das schnellste Programm nutzt nichts, wenn es falsche Ergebnisse liefert. 
Nicht ganz so klar ist die letzte Forderung.  Diese Forderung hat einen
\"okonomischen Hintergrund: Genauso wie die Rechenzeit eines Programms Geld
kostet, so kostet auch die Zeit, die Programmierer brauchen um ein Programm zu
erstellen und zu warten, Geld.  Aber es gibt noch zwei weitere Gr\"unde f\"ur die
dritte Forderung:
\begin{enumerate}
\item F\"ur einen Algorithmus, dessen konzeptionelle Komplexit\"at hoch ist, ist die
      Korrektheit nicht mehr einsehbar und damit auch nicht gew\"ahrleistbar. 
\item Selbst wenn der Algorithmus an sich korrekt ist, so kann doch die
      Korrektheit der Implementierung nicht mehr sichergestellt werden.
\end{enumerate}

\section{Literatur}
Erg\"anzend zu diesem Skript m\"ochte ich die folgende Literatur empfehlen.
\begin{enumerate}
\item \textsl{Alfred V.~Aho}, \textsl{John E.~Hopcraft}, and \textsl{Jeffrey D.~Ullman}:
      \emph{Data Structures and Algorithms}, Addison-Wesley, 1987. 
      
      Dieses Buch geh\"ort zu den Standardwerken \"uber Algorithmen.  
      Die Algorithmen werden dort auf einem hohen Niveau erkl\"art.
\item \textsl{Frank M.~Carrano} and \textsl{Janet J. Prichard}:
      \emph{Data Abstraction and Problem Solving with \textsl{Java}}, 
      Addison-Wesley, 2003. 

      In diesem Buch sind die Darstellungen der Algorithmen sehr breit und
      verst\"andlich.  Viele Algorithmen sind graphisch illustriert. 
      Leider geht das Buch oft nicht genug in die Tiefe, so wird zum Beispiel
      die Komplexit\"at von Algorithmen kaum untersucht.
\item \textsl{Thomas H.~Cormen}, \textsl{Charles E.~Leiserson}, 
      \textsl{Ronald L.~Rivest}, and \textsl{Clifford Stein}:
      \emph{Introduction to Algorithms}, 
      MIT Press, 2001. 

      Aufgrund seiner Ausf\"uhrlichkeit eignet sich dieses Buch sehr gut zum
      Nachschlagen von Algorithmen.  Die Darstellungen der Algorithmen sind eher
      etwas knapper gehalten, daf\"ur wird aber auch die Komplexit\"at analysiert.
\item \textsl{Robert Sedgewick}: \emph{Algorithms in \textsl{Java}}, 
      Pearson, 2002.
    
      Dieses Buch liegt in der Mitte zwischen den B\"uchern von Carrano und
      Cormen:  Es ist theoretisch nicht so anspruchsvoll wie das von Cormen,
      enth\"alt aber wesentlich mehr Algorithmen als das Buch von Carrano.
      Zus\"atzlich wird die Komplexit\"at der Algorithmen diskutiert.
\item \textsl{Heinz-Peter Gumm und Manfred Sommer},
      \emph{Einf\"uhrung in die Informatik},
      Oldenbourg Verlag, 2006.

      Dieses Buch ist eine sehr gute Einf\"uhrung in die Informatik, die auch ein
      umfangreiches Kapitel \"uber Algorithmen und Datenstrukturen enth\"alt.  
      Die Darstellung der Algorithmen ist sehr gelungen.
\end{enumerate}
%Von den meisten der oben aufgef\"uhrten angels\"achsischen B\"uchern existieren \"Ubersetzungen ins
%Deutsche.  Ich rate von dem Gebrauch dieser \"Ubersetzungen ab, da die Qualit\"at in der Regel hinter
%den Originalen zur\"uck bleibt.  Au{\ss}erdem sind heute in der Informatik gute Kenntnisse der
%englischen Sprache unverzichtbar.  Solche Kenntnisse lassen sich relativ einfach durch die Lekt\"ure guter
%englischer Fachb\"ucher gewinnen und weiterentwickeln.

\nocite{aho:87}
\nocite{boerger:2003}
\nocite{carrano:02}
\nocite{cormen:01}
\nocite{gurevich:91}
\nocite{sedgewick:02}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "algorithmen"
%%% End: 
