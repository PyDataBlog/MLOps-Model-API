using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace KaoriStudio.Core.Collections
{
	/// <summary>
	/// A generic wrapper for System.Collections.IList
	/// </summary>
	/// <typeparam name="T">The item type</typeparam>
	public struct GenericList<T> : IList<T>
	{
		/// <summary>
		/// The underlying list
		/// </summary>
		public IList List { get; set; }

		/// <summary>
		/// Creates a new generic list
		/// </summary>
		/// <param name="List">The underlying list</param>
		public GenericList(IList List)
		{
			this.List = List;
		}

		/// <summary>
		/// The index accessor
		/// </summary>
		/// <param name="index">The index</param>
		/// <returns>The value as the index</returns>
		public T this[int index]
		{
			get
			{
				return (T)List[index];
			}

			set
			{
				List[index] = value;
			}
		}

		/// <summary>
		/// The number of elements in this list
		/// </summary>
		public int Count
		{
			get
			{
				return List.Count;
			}
		}

		/// <summary>
		/// Whether this list is read-only
		/// </summary>
		public bool IsReadOnly
		{
			get
			{
				return List.IsReadOnly;
			}
		}

		/// <summary>
		/// Adds an item to this list
		/// </summary>
		/// <param name="item">The item</param>
		public void Add(T item)
		{
			List.Add(item);
		}

		/// <summary>
		/// Clears this list
		/// </summary>
		public void Clear()
		{
			List.Clear();
		}

		/// <summary>
		/// Checks this list for the presence of an item
		/// </summary>
		/// <param name="item">The item</param>
		/// <returns>Whether the item is present</returns>
		public bool Contains(T item)
		{
			return List.Contains(item);
		}

		/// <summary>
		/// Copies the contents of this list to an array
		/// </summary>
		/// <param name="array">The array</param>
		/// <param name="arrayIndex">The starting index</param>
		public void CopyTo(T[] array, int arrayIndex)
		{
			List.CopyTo(array, arrayIndex);
		}

		/// <summary>
		/// The list enumerator
		/// </summary>
		public struct Enumerator : IEnumerator<T>
		{
			private GenericList<T> list;
			private int index;
			private T current;
			
			/// <summary>
			/// Creates a new list enumerator
			/// </summary>
			/// <param name="List">The underlying list</param>
			public Enumerator(GenericList<T> List)
			{
				this.list = List;
				this.index = 0;
				this.current = default(T);
			}

			/// <summary>
			/// The current element in the list
			/// </summary>
			public T Current
			{
				get
				{
					return current;
				}
			}

			object IEnumerator.Current
			{
				get
				{
					return Current;
				}
			}

			/// <summary>
			/// Disposes of this enumerator
			/// </summary>
			public void Dispose()
			{
			}

			/// <summary>
			/// Attempts to move this enumerator to the next element
			/// </summary>
			/// <returns>Whether there was a next element</returns>
			public bool MoveNext()
			{
				if (index < list.List.Count)
				{
					current = (T)list.List[index];
					index++;
					return true;
				}
				else
					return false;
			}

			/// <summary>
			/// Resets this enumerator
			/// </summary>
			public void Reset()
			{
				this.current = default(T);
				this.index = 0;
			}
		}

		/// <summary>
		/// Gets the enumerator for this list
		/// </summary>
		/// <returns>The enumerator</returns>
		public Enumerator GetEnumerator()
		{
			return new Enumerator(this);
		} 
		
		IEnumerator<T> IEnumerable<T>.GetEnumerator()
		{
			throw new NotImplementedException();
		}

		/// <summary>
		/// Gets the index of an item
		/// </summary>
		/// <param name="item">The item</param>
		/// <returns>The index of the first occurrence of the item, or -1</returns>
		public int IndexOf(T item)
		{
			return List.IndexOf(item);
		}

		/// <summary>
		/// Inserts an item into this list
		/// </summary>
		/// <param name="index">The index</param>
		/// <param name="item">The item</param>
		public void Insert(int index, T item)
		{
			List.Insert(index, item);
		}

		/// <summary>
		/// Removes an item from this list
		/// </summary>
		/// <param name="item">The item</param>
		/// <returns>Whether the item was found and removed</returns>
		public bool Remove(T item)
		{
			int i = List.IndexOf(item);

			if (i != -1)
			{
				List.RemoveAt(i);
				return true;
			}
			else
				return false;
		}

		/// <summary>
		/// Removes the item at an index
		/// </summary>
		/// <param name="index">The index</param>
		public void RemoveAt(int index)
		{
			List.RemoveAt(index);
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			throw new NotImplementedException();
		}
	}
}
