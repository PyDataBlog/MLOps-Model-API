import Test.QuickCheck
import Data.Maybe
import Data.List

-- These functions are copied directly from problem #11.

data EncodedEntry a = Multiple (Int, a) | Single a deriving (Eq, Show, Ord)

listToEncodedEntry :: [a] -> Maybe (EncodedEntry a)
listToEncodedEntry x =
	case length x of
		0 -> Nothing
		1 -> Just . Single . head $ x
		otherwise -> Just . Multiple $ (length x, head x)

myEncode :: Eq a => [a] -> [EncodedEntry a]
myEncode [] = []
myEncode xs = [fromJust . listToEncodedEntry $ x | x <- group xs]

-- Define a decode function.

encodedEntryToList :: EncodedEntry a -> [a]
encodedEntryToList (Multiple (n, x)) = replicate n x
encodedEntryToList (Single x) = [x]

myDecode :: [EncodedEntry a] -> [a]
myDecode x = concatMap encodedEntryToList x

-- Define a very basic test for our decoding function.

testMyDecode :: [Char] -> Bool
testMyDecode x = (myDecode . myEncode $ x) == x

main = quickCheck testMyDecode
