!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.12 (r6213) - 13 Oct 2016 10:54
!
!  Differentiation of porteagel_analyze in reverse (adjoint) mode:
!   gradient     of useful results: wtvelocity
!   with respect to varying inputs: rotordiameter turbinez turbinexw
!                wtvelocity turbineyw yawdeg ct
!   RW status of diff variables: rotordiameter:out turbinez:out
!                turbinexw:out wtvelocity:in-zero turbineyw:out
!                yawdeg:out ct:out
! Implementation of the Bastankhah and Porte Agel gaussian-shaped wind turbine wake 
! model (2016) with various farm modeling (TI and wake combination) methods included
! Created by Jared J. Thomas, 2017.
! FLight Optimization and Wind Laboratory (FLOW Lab)
! Brigham Young University
! implementation of the Bastankhah and Porte Agel (BPA) wake model for analysis
SUBROUTINE PORTEAGEL_ANALYZE_BV(nturbines, nrotorpoints, turbinexw, &
& turbinexwb, sorted_x_idx, turbineyw, turbineywb, turbinez, turbinezb, &
& rotordiameter, rotordiameterb, ct, ctb, wind_speed, yawdeg, yawdegb, &
& ky, kz, alpha, beta, ti, rotorpointsy, rotorpointsz, z_ref, z_0, &
& shear_exp, wake_combination_method, ti_calculation_method, calc_k_star&
& , opt_exp_fac, print_ti, wtvelocityb, nbdirs)
 ! USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
!print *, "TIturbs: ", TIturbs
!print *, wtVelocity
!! make sure turbine inflow velocity is non-negative
!             if (wtVelocity(turbI) .lt. 0.0_dp) then 
!                 wtVelocity(turbI) = 0.0_dp
!             end if
!print *, "fortran"
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  INTEGER, INTENT(IN) :: nturbines, nrotorpoints
  INTEGER, INTENT(IN) :: wake_combination_method, ti_calculation_method
  LOGICAL, INTENT(IN) :: calc_k_star, print_ti
  REAL(dp), DIMENSION(nturbines), INTENT(IN) :: turbinexw, turbineyw, &
& turbinez
  REAL(dp), DIMENSION(nbdirs, nturbines), intent(out) :: turbinexwb, turbineywb, &
& turbinezb
  INTEGER, DIMENSION(nturbines), INTENT(IN) :: sorted_x_idx
  REAL(dp), DIMENSION(nturbines), INTENT(IN) :: rotordiameter, yawdeg
  REAL(dp), DIMENSION(nbdirs, nturbines), intent(out) :: rotordiameterb, yawdegb
  REAL(dp), DIMENSION(nturbines), INTENT(IN) :: ct
  REAL(dp), DIMENSION(nbdirs, nturbines), intent(out) :: ctb
  REAL(dp), INTENT(IN) :: ky, kz, alpha, beta, ti, wind_speed, z_ref, &
& z_0, shear_exp, opt_exp_fac
  REAL(dp), DIMENSION(nrotorpoints), INTENT(IN) :: rotorpointsy, &
& rotorpointsz
! local (General)
  REAL(dp), DIMENSION(nturbines) :: yaw, titurbs
  REAL(dp), DIMENSION(nbdirs, nturbines) :: yawb, titurbsb
  REAL(dp) :: x0, deltax0, deltay, theta_c_0, sigmay, sigmaz, &
& wake_offset, k_star
  REAL(dp), DIMENSION(nbdirs) :: x0b, deltax0b, deltayb, theta_c_0b, &
& sigmayb, sigmazb, wake_offsetb, k_starb
  REAL(dp) :: x, deltav, deltaz, sigmay_dp, sigmaz_dp, deltax0_dp, &
& deficit_sum
  REAL(dp), DIMENSION(nbdirs) :: xb, deltavb, deltazb, sigmay_dpb, &
& sigmaz_dpb, deltax0_dpb, deficit_sumb
  REAL(dp) :: ky_local, kz_local, tol, discontinuity_point
  REAL(dp), DIMENSION(nbdirs) :: ky_localb, kz_localb, &
& discontinuity_pointb
  REAL(dp) :: localrotorpointy, localrotorpointz, point_velocity, &
& point_z, point_velocity_with_shear
  REAL(dp), DIMENSION(nbdirs) :: localrotorpointyb, localrotorpointzb&
& , point_velocityb, point_zb, point_velocity_with_shearb
  INTEGER :: u, d, turb, turbi, p
  REAL(dp), PARAMETER :: pi=3.141592653589793_dp
! model out
  REAL(dp), DIMENSION(nturbines) :: wtvelocity
  REAL(dp), DIMENSION(nbdirs, nturbines) :: wtvelocityb
  INTRINSIC SIN, COS, ATAN, MAX, SQRT, LOG
  INTRINSIC KIND
  INTEGER :: nd
  INTEGER :: branch
  INTEGER :: nbdirs
! bastankhah and porte agel 2016 define yaw to be positive clockwise, this is reversed
  yaw = -(yawdeg*pi/180.0_dp)
! set tolerance for location checks
  tol = 0.1_dp
! initialize wind turbine velocities to 0.0
  wtvelocity = 0.0_dp
! initialize TI of all turbines to free-stream value
!print *, "start TIturbs: ", TIturbs
  titurbs = ti
!print *, "initialized TIturbs: ", TIturbs
  ky_local = ky
  kz_local = kz
!print *, "ky_local: ", ky_local
!print *, "kz_local: ", kz_local
!print *, "TIturbs init: ", TIturbs
  DO d=1,nturbines
! get index of downstream turbine
    turbi = sorted_x_idx(d) + 1
    DO p=1,nrotorpoints
! initialize deficit summation term to zero
      deficit_sum = 0.0_dp
! scale rotor sample point coordinate by rotor diameter (in rotor hub ref. frame)
      localrotorpointy = rotorpointsy(p)*0.5_dp*rotordiameter(turbi)
      localrotorpointz = rotorpointsz(p)*0.5_dp*rotordiameter(turbi)
!             print *, "rotorDiameter after local rotor points", rotorDiameter
!             print *, "local rotor points Y,Z: ", LocalRotorPointY, LocalRotorPointZ
! at turbineX-locations
      DO u=1,nturbines
! get index of upstream turbine
        CALL PUSHINTEGER4(turb)
        turb = sorted_x_idx(u) + 1
! skip this loop if turb = turbI (turbines impact on itself)
        IF (turb .EQ. turbi) THEN
          CALL PUSHCONTROL2B(0)
        ELSE
! downstream distance between upstream turbine and point
          CALL PUSHREAL4ARRAY(x, dp/4)
          x = turbinexw(turbi) - turbinexw(turb) + localrotorpointy*SIN(&
&           yaw(turbi))
! set this iterations velocity deficit to 0
! check turbine relative locations
          IF (x .GT. 0.0_dp + tol) THEN
!print *, "rotorDiameter before x0 ", rotorDiameter
! determine the onset location of far wake
            CALL PUSHREAL4ARRAY(x0, dp/4)
            CALL X0_FUNC(rotordiameter(turb), yaw(turb), ct(turb), alpha&
&                  , titurbs(turb), beta, x0)
! downstream distance from far wake onset to downstream turbine
            CALL PUSHREAL4ARRAY(deltax0, dp/4)
            deltax0 = x - x0
! calculate wake spreading parameter at each turbine if desired
            IF (calc_k_star .EQV. .true.) THEN
              CALL K_STAR_FUNC(titurbs(turb), k_star)
              CALL PUSHREAL4ARRAY(ky_local, dp/4)
              ky_local = k_star
              CALL PUSHREAL4ARRAY(kz_local, dp/4)
              kz_local = k_star
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
!print *, "ky_local ", ky_local
!print *, "deltax0 ", deltax0
!print *, "turbineZ ", turbineZ
!print *, "rotorDiameter after x0 ", rotorDiameter
!print *, "Ct ", Ct
!print *, "yaw ", yaw
! determine the initial wake angle at the onset of far wake
            CALL PUSHREAL4ARRAY(theta_c_0, dp/4)
            CALL THETA_C_0_FUNC(yaw(turb), ct(turb), theta_c_0)
!print *, "theta_c_0 ", theta_c_0
! horizontal spread
            CALL PUSHREAL4ARRAY(sigmay, dp/4)
            CALL SIGMAY_FUNC(ky_local, deltax0, rotordiameter(turb), yaw&
&                      (turb), sigmay)
!print *, "sigmay ", sigmay
!print *, "rotorDiameter after sigmay", rotorDiameter
! vertical spread
            CALL PUSHREAL4ARRAY(sigmaz, dp/4)
            CALL SIGMAZ_FUNC(kz_local, deltax0, rotordiameter(turb), &
&                      sigmaz)
!print *, "sigmaz ", sigmaz
!print *, "rotorDiameter after sigmaz ", rotorDiameter
! horizontal cross-wind wake displacement from hub
            CALL WAKE_OFFSET_FUNC(rotordiameter(turb), theta_c_0, x0, &
&                           yaw(turb), ky_local, kz_local, ct(turb), &
&                           sigmay, sigmaz, wake_offset)
!print *, "wake_offset ", wake_offset                 
! cross wind distance from downstream point location to wake center
            CALL PUSHREAL4ARRAY(deltay, dp/4)
            deltay = localrotorpointy*COS(yaw(turbi)) + turbineyw(turbi)&
&             - (turbineyw(turb)+wake_offset)
! cross wind distance from hub height to height of point of interest
            deltaz = localrotorpointz + turbinez(turbi) - turbinez(turb)
!print *, "dx, dy, dz: ", x, deltay, deltaz
!print *, "local y,z : ", LocalRotorPointY, LocalRotorPointZ, turb, turbI, p
!print *, deltaz, deltay
! far wake region
! find the final point where the original model is undefined
            CALL DISCONTINUITY_POINT_FUNC(x0, rotordiameter(turb), &
&                                   ky_local, kz_local, yaw(turb), ct(&
&                                   turb), discontinuity_point)
            IF (x .GT. discontinuity_point) THEN
!print *, x
! velocity difference in the wake
              CALL PUSHREAL4ARRAY(deltav, dp/4)
              CALL DELTAV_FUNC(deltay, deltaz, ct(turb), yaw(turb), &
&                        sigmay, sigmaz, rotordiameter(turb), &
&                        opt_exp_fac, deltav)
!print *, "rotorDiameter after far deltav ", rotorDiameter
! near wake region (linearized)
              CALL PUSHCONTROL1B(0)
            ELSE
! determine distance from discontinuity point to far wake onset
              CALL PUSHREAL4ARRAY(deltax0_dp, dp/4)
              deltax0_dp = discontinuity_point - x0
! horizontal spread at far wake onset
              CALL PUSHREAL4ARRAY(sigmay_dp, dp/4)
              CALL SIGMAY_FUNC(ky_local, deltax0_dp, rotordiameter(turb)&
&                        , yaw(turb), sigmay_dp)
!print *, "rotorDiameter after sigmay0", rotorDiameter
! vertical spread at far wake onset
              CALL PUSHREAL4ARRAY(sigmaz_dp, dp/4)
              CALL SIGMAZ_FUNC(kz_local, deltax0_dp, rotordiameter(turb)&
&                        , sigmaz_dp)
!print *, "rotorDiameter after sigmaz0", rotorDiameter
! velocity deficit in the nearwake (linear model)
              CALL PUSHREAL4ARRAY(deltav, dp/4)
              CALL DELTAV_NEAR_WAKE_LIN_FUNC(deltay, deltaz, ct(turb), &
&                                      yaw(turb), sigmay_dp, sigmaz_dp, &
&                                      rotordiameter(turb), x, x0, &
&                                      sigmay_dp, sigmaz_dp, opt_exp_fac&
&                                      , deltav)
!print *, "rotorDiameter after deltav near ", rotorDiameter
              CALL PUSHCONTROL1B(1)
            END IF
! combine deficits according to selected method wake combination method
            CALL PUSHREAL4ARRAY(deficit_sum, dp/4)
            CALL WAKE_COMBINATION_FUNC(wind_speed, wtvelocity(turb), &
&                                deltav, wake_combination_method, &
&                                deficit_sum)
            IF (x .GT. 0.0_dp .AND. ti_calculation_method .GT. 0) THEN
!print *, "turbI, turb: ", turbI, turb
! calculate TI value at each turbine
              CALL PUSHREAL4ARRAY(titurbs(turbi), dp/4)
              CALL ADDED_TI_FUNC(ti, ct(turb), x, ky_local, &
&                          rotordiameter(turb), rotordiameter(turbi), &
&                          deltay, turbinez(turb), turbinez(turbi), &
&                          titurbs(turb), ti_calculation_method, titurbs&
&                          (turbi))
!print *, "rotorDiameter after TI calcs", rotorDiameter
              CALL PUSHCONTROL2B(3)
            ELSE
              CALL PUSHCONTROL2B(2)
            END IF
          ELSE
            CALL PUSHCONTROL2B(1)
          END IF
        END IF
      END DO
!                     print *, "deficit_sum, turbI, p, turb: ", deficit_sum, turbI, p, turb
! print *, deficit_sum
! find velocity at point p due to the wake of turbine turb
      CALL PUSHREAL4ARRAY(point_velocity, dp/4)
      point_velocity = wind_speed - deficit_sum
!print *, "point velocity, deficit_sum, turbI, p: ", point_velocity, deficit_sum, turbI, p    
! put sample point height in global reference frame
      point_z = localrotorpointz + turbinez(turbi)
!print *, "point_z, turbI, p: ", point_z, turbI, p    
! adjust sample point velocity for shear
      CALL WIND_SHEAR_FUNC(point_z, point_velocity, z_ref, z_0, &
&                    shear_exp, point_velocity_with_shear)
!print *, "v, vs, x, turb, turbI, p: ", point_velocity, point_velocity_with_shear, x, turb, turbI, p
! add sample point velocity to turbine velocity to be averaged later
      CALL PUSHREAL4ARRAY(wtvelocity(turbi), dp/4)
      wtvelocity(turbi) = wtvelocity(turbi) + point_velocity_with_shear
    END DO
! final velocity calculation for turbine turbI (average equally across all points)
    CALL PUSHREAL4ARRAY(wtvelocity(turbi), dp/4)
    wtvelocity(turbi) = wtvelocity(turbi)/nrotorpoints
  END DO
  DO nd=1,nbdirs
    rotordiameterb(nd, :) = 0.0
    turbinezb(nd, :) = 0.0
    turbinexwb(nd, :) = 0.0
    turbineywb(nd, :) = 0.0
    ctb(nd, :) = 0.0
    yawb(nd, :) = 0.0
    titurbsb(nd, :) = 0.0
    kz_localb(nd) = 0.0
    ky_localb(nd) = 0.0
  END DO
  DO d=nturbines,1,-1
    turbi = sorted_x_idx(d) + 1
    CALL POPREAL4ARRAY(wtvelocity(turbi), dp/4)
    DO nd=1,nbdirs
      wtvelocityb(nd, turbi) = wtvelocityb(nd, turbi)/nrotorpoints
    END DO
    DO p=nrotorpoints,1,-1
      DO nd=1,nbdirs
        point_velocity_with_shearb(nd) = wtvelocityb(nd, turbi)
      END DO
      CALL POPREAL4ARRAY(wtvelocity(turbi), dp/4)
      localrotorpointz = rotorpointsz(p)*0.5_dp*rotordiameter(turbi)
      point_z = localrotorpointz + turbinez(turbi)
      CALL WIND_SHEAR_FUNC_BV(point_z, point_zb, point_velocity, &
&                       point_velocityb, z_ref, z_0, shear_exp, &
&                       point_velocity_with_shear, &
&                       point_velocity_with_shearb, nbdirs)
      CALL POPREAL4ARRAY(point_velocity, dp/4)
      localrotorpointy = rotorpointsy(p)*0.5_dp*rotordiameter(turbi)
      DO nd=1,nbdirs
        localrotorpointzb(nd) = point_zb(nd)
        turbinezb(nd, turbi) = turbinezb(nd, turbi) + point_zb(nd)
        deficit_sumb(nd) = -point_velocityb(nd)
      END DO
      DO nd=1,nbdirs
        localrotorpointyb(nd) = 0.0
      END DO
      DO u=nturbines,1,-1
        CALL POPCONTROL2B(branch)
        IF (branch .LT. 2) THEN
          IF (branch .EQ. 0) THEN
            GOTO 100
          ELSE
            DO nd=1,nbdirs
              xb(nd) = 0.0
            END DO
          END IF
        ELSE
          IF (branch .EQ. 2) THEN
            DO nd=1,nbdirs
              xb(nd) = 0.0
              deltayb(nd) = 0.0
            END DO
          ELSE
            turb = sorted_x_idx(u) + 1
            CALL POPREAL4ARRAY(titurbs(turbi), dp/4)
            CALL ADDED_TI_FUNC_BV(ti, ct(turb), ctb(1, turb), x, xb, &
&                           ky_local, ky_localb, rotordiameter(turb), &
&                           rotordiameterb(1, turb), rotordiameter(turbi&
&                           ), rotordiameterb(1, turbi), deltay, deltayb&
&                           , turbinez(turb), turbinezb(1, turb), &
&                           turbinez(turbi), turbinezb(1, turbi), &
&                           titurbs(turb), titurbsb(1, turb), &
&                           ti_calculation_method, titurbs(turbi), &
&                           titurbsb(1, turbi), nbdirs)
          END IF
          CALL POPREAL4ARRAY(deficit_sum, dp/4)
          CALL WAKE_COMBINATION_FUNC_BV(wind_speed, wtvelocity(turb), &
&                                 wtvelocityb(1, turb), deltav, deltavb&
&                                 , wake_combination_method, deficit_sum&
&                                 , deficit_sumb, nbdirs)
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            deltaz = localrotorpointz + turbinez(turbi) - turbinez(turb)
            CALL POPREAL4ARRAY(deltav, dp/4)
            CALL DELTAV_FUNC_BV(deltay, deltayb, deltaz, deltazb, ct(&
&                         turb), ctb(1, turb), yaw(turb), yawb(1, turb)&
&                         , sigmay, sigmayb, sigmaz, sigmazb, &
&                         rotordiameter(turb), rotordiameterb(1, turb), &
&                         opt_exp_fac, deltav, deltavb, nbdirs)
            DO nd=1,nbdirs
              discontinuity_pointb(nd) = 0.0
              x0b(nd) = 0.0
            END DO
          ELSE
            deltaz = localrotorpointz + turbinez(turbi) - turbinez(turb)
            CALL POPREAL4ARRAY(deltav, dp/4)
            CALL DELTAV_NEAR_WAKE_LIN_FUNC_BV(deltay, deltayb, deltaz, &
&                                       deltazb, ct(turb), ctb(1, turb)&
&                                       , yaw(turb), yawb(1, turb), &
&                                       sigmay_dp, sigmay_dpb, sigmaz_dp&
&                                       , sigmaz_dpb, rotordiameter(turb&
&                                       ), rotordiameterb(1, turb), x, &
&                                       xb, x0, x0b, sigmay_dp, &
&                                       sigmay_dpb, sigmaz_dp, &
&                                       sigmaz_dpb, opt_exp_fac, deltav&
&                                       , deltavb, nbdirs)
            CALL POPREAL4ARRAY(sigmaz_dp, dp/4)
            CALL SIGMAZ_FUNC_BV(kz_local, kz_localb, deltax0_dp, &
&                         deltax0_dpb, rotordiameter(turb), &
&                         rotordiameterb(1, turb), sigmaz_dp, sigmaz_dpb&
&                         , nbdirs)
            CALL POPREAL4ARRAY(sigmay_dp, dp/4)
            CALL SIGMAY_FUNC_BV(ky_local, ky_localb, deltax0_dp, &
&                         deltax0_dpb, rotordiameter(turb), &
&                         rotordiameterb(1, turb), yaw(turb), yawb(1, &
&                         turb), sigmay_dp, sigmay_dpb, nbdirs)
            CALL POPREAL4ARRAY(deltax0_dp, dp/4)
            DO nd=1,nbdirs
              discontinuity_pointb(nd) = deltax0_dpb(nd)
              x0b(nd) = x0b(nd) - deltax0_dpb(nd)
            END DO
            DO nd=1,nbdirs
              sigmayb(nd) = 0.0
              sigmazb(nd) = 0.0
            END DO
          END IF
          CALL DISCONTINUITY_POINT_FUNC_BV(x0, x0b, rotordiameter(turb)&
&                                    , rotordiameterb(1, turb), ky_local&
&                                    , ky_localb, kz_local, kz_localb, &
&                                    yaw(turb), yawb(1, turb), ct(turb)&
&                                    , ctb(1, turb), discontinuity_point&
&                                    , discontinuity_pointb, nbdirs)
          CALL POPREAL4ARRAY(deltay, dp/4)
          DO nd=1,nbdirs
            localrotorpointzb(nd) = localrotorpointzb(nd) + deltazb(nd)
            turbinezb(nd, turbi) = turbinezb(nd, turbi) + deltazb(nd)
            turbinezb(nd, turb) = turbinezb(nd, turb) - deltazb(nd)
            localrotorpointyb(nd) = localrotorpointyb(nd) + COS(yaw(&
&             turbi))*deltayb(nd)
            yawb(nd, turbi) = yawb(nd, turbi) - localrotorpointy*SIN(yaw&
&             (turbi))*deltayb(nd)
            turbineywb(nd, turbi) = turbineywb(nd, turbi) + deltayb(nd)
            turbineywb(nd, turb) = turbineywb(nd, turb) - deltayb(nd)
            wake_offsetb(nd) = -deltayb(nd)
          END DO
          CALL WAKE_OFFSET_FUNC_BV(rotordiameter(turb), rotordiameterb(1&
&                            , turb), theta_c_0, theta_c_0b, x0, x0b, &
&                            yaw(turb), yawb(1, turb), ky_local, &
&                            ky_localb, kz_local, kz_localb, ct(turb), &
&                            ctb(1, turb), sigmay, sigmayb, sigmaz, &
&                            sigmazb, wake_offset, wake_offsetb, nbdirs)
          CALL POPREAL4ARRAY(sigmaz, dp/4)
          CALL SIGMAZ_FUNC_BV(kz_local, kz_localb, deltax0, deltax0b, &
&                       rotordiameter(turb), rotordiameterb(1, turb), &
&                       sigmaz, sigmazb, nbdirs)
          CALL POPREAL4ARRAY(sigmay, dp/4)
          CALL SIGMAY_FUNC_BV(ky_local, ky_localb, deltax0, deltax0b, &
&                       rotordiameter(turb), rotordiameterb(1, turb), &
&                       yaw(turb), yawb(1, turb), sigmay, sigmayb, &
&                       nbdirs)
          CALL POPREAL4ARRAY(theta_c_0, dp/4)
          CALL THETA_C_0_FUNC_BV(yaw(turb), yawb(1, turb), ct(turb), ctb&
&                          (1, turb), theta_c_0, theta_c_0b, nbdirs)
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            DO nd=1,nbdirs
              k_starb(nd) = ky_localb(nd) + kz_localb(nd)
            END DO
            CALL POPREAL4ARRAY(kz_local, dp/4)
            CALL POPREAL4ARRAY(ky_local, dp/4)
            CALL K_STAR_FUNC_BV(titurbs(turb), titurbsb(1, turb), k_star&
&                         , k_starb, nbdirs)
            DO nd=1,nbdirs
              kz_localb(nd) = 0.0
              ky_localb(nd) = 0.0
            END DO
          END IF
          DO nd=1,nbdirs
            xb(nd) = xb(nd) + deltax0b(nd)
            x0b(nd) = x0b(nd) - deltax0b(nd)
          END DO
          CALL POPREAL4ARRAY(deltax0, dp/4)
          CALL POPREAL4ARRAY(x0, dp/4)
          CALL X0_FUNC_BV(rotordiameter(turb), rotordiameterb(1, turb), &
&                   yaw(turb), yawb(1, turb), ct(turb), ctb(1, turb), &
&                   alpha, titurbs(turb), titurbsb(1, turb), beta, x0, &
&                   x0b, nbdirs)
        END IF
        CALL POPREAL4ARRAY(x, dp/4)
        DO nd=1,nbdirs
          turbinexwb(nd, turbi) = turbinexwb(nd, turbi) + xb(nd)
          turbinexwb(nd, turb) = turbinexwb(nd, turb) - xb(nd)
          localrotorpointyb(nd) = localrotorpointyb(nd) + SIN(yaw(turbi)&
&           )*xb(nd)
          yawb(nd, turbi) = yawb(nd, turbi) + localrotorpointy*COS(yaw(&
&           turbi))*xb(nd)
        END DO
 100    CALL POPINTEGER4(turb)
      END DO
      DO nd=1,nbdirs
        rotordiameterb(nd, turbi) = rotordiameterb(nd, turbi) + &
&         rotorpointsy(p)*0.5_dp*localrotorpointyb(nd) + rotorpointsz(p)&
&         *0.5_dp*localrotorpointzb(nd)
      END DO
    END DO
  END DO
  DO nd=1,nbdirs
    yawdegb(nd, :) = 0.0
    yawdegb(nd, :) = -(pi*yawb(nd, :)/180.0_dp)
  END DO
  DO nd=1,nbdirs
    wtvelocityb(nd, :) = 0.0
  END DO
END SUBROUTINE PORTEAGEL_ANALYZE_BV

!  Differentiation of x0_func in reverse (adjoint) mode:
!   gradient     of useful results: ti yaw rotor_diameter x0 ct
!   with respect to varying inputs: ti yaw rotor_diameter ct
! calculates the onset of far-wake conditions
SUBROUTINE X0_FUNC_BV(rotor_diameter, rotor_diameterb, yaw, yawb, ct, &
& ctb, alpha, ti, tib, beta, x0, x0b, nbdirs)
 ! USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: rotor_diameter, yaw, ct, alpha, ti, beta
  REAL(dp), DIMENSION(nbdirs) :: rotor_diameterb, yawb, ctb, tib
! out
  REAL(dp) :: x0
  REAL(dp), DIMENSION(nbdirs) :: x0b
  INTRINSIC COS, SQRT
  INTRINSIC KIND
! determine the onset location of far wake
  REAL(dp) :: temp
  REAL(dp) :: temp0
  REAL(dp) :: temp1
  REAL(dp) :: temp2
  REAL(dp) :: temp3
  INTEGER :: nd
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  INTEGER :: nbdirs
  temp3 = SQRT(-ct + 1.0_dp)
  temp2 = SQRT(2.0_dp)
  temp1 = temp2*(alpha*ti+beta*(-temp3+1.0_dp))
  temp0 = SQRT(-ct + 1.0_dp)
  temp = COS(yaw)
  DO nd=1,nbdirs
    tempb(nd) = x0b(nd)/temp1
    tempb0(nd) = -(rotor_diameter*temp*(temp0+1.0_dp)*temp2*tempb(nd)/&
&     temp1)
    rotor_diameterb(nd) = rotor_diameterb(nd) + (temp0+1.0_dp)*temp*&
&     tempb(nd)
    yawb(nd) = yawb(nd) - rotor_diameter*(temp0+1.0_dp)*SIN(yaw)*tempb(&
&     nd)
    IF (.NOT.1.0_dp - ct .EQ. 0.0) ctb(nd) = ctb(nd) + beta*tempb0(nd)/(&
&       2.0*temp3) - rotor_diameter*temp*tempb(nd)/(2.0*temp0)
    tib(nd) = tib(nd) + alpha*tempb0(nd)
  END DO
END SUBROUTINE X0_FUNC_BV

!  Differentiation of theta_c_0_func in reverse (adjoint) mode:
!   gradient     of useful results: theta_c_0 yaw ct
!   with respect to varying inputs: yaw ct
! calculates the wake angle at the onset of far wake conditions
SUBROUTINE THETA_C_0_FUNC_BV(yaw, yawb, ct, ctb, theta_c_0, theta_c_0b, &
& nbdirs)
 ! USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: yaw, ct
  REAL(dp), DIMENSION(nbdirs) :: yawb, ctb
! out
  REAL(dp) :: theta_c_0
  REAL(dp), DIMENSION(nbdirs) :: theta_c_0b
  INTRINSIC COS, SQRT
  INTRINSIC KIND
! determine the initial wake angle at the onset of far wake
  REAL(dp) :: temp
  REAL(dp) :: temp0
  REAL(dp) :: temp1
  INTEGER :: nd
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  INTEGER :: nbdirs
  temp1 = COS(yaw)
  temp0 = COS(yaw)
  temp = SQRT(-(ct*temp0) + 1.0_dp)
  DO nd=1,nbdirs
    IF (1.0_dp - ct*temp0 .EQ. 0.0) THEN
      tempb(nd) = 0.0
    ELSE
      tempb(nd) = -(yaw*0.3_dp*theta_c_0b(nd)/(temp1*2.0*temp))
    END IF
    tempb0(nd) = (1.0_dp-temp)*0.3_dp*theta_c_0b(nd)/temp1
    ctb(nd) = ctb(nd) - temp0*tempb(nd)
    yawb(nd) = yawb(nd) + (yaw*SIN(yaw)/temp1+1.0)*tempb0(nd) + ct*SIN(&
&     yaw)*tempb(nd)
  END DO
END SUBROUTINE THETA_C_0_FUNC_BV

!  Differentiation of sigmay_func in reverse (adjoint) mode:
!   gradient     of useful results: yaw sigmay ky rotor_diameter
!                deltax0
!   with respect to varying inputs: yaw ky rotor_diameter deltax0
! calculates the horizontal spread of the wake at a given distance from the onset of far 
! wake condition
SUBROUTINE SIGMAY_FUNC_BV(ky, kyb, deltax0, deltax0b, rotor_diameter, &
& rotor_diameterb, yaw, yawb, sigmay, sigmayb, nbdirs)
 ! USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
! define precision to be the standard for a double precision on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: ky, deltax0, rotor_diameter, yaw
  REAL(dp), DIMENSION(nbdirs) :: kyb, deltax0b, rotor_diameterb, yawb
! out
  REAL(dp) :: sigmay
  REAL(dp), DIMENSION(nbdirs) :: sigmayb
  INTRINSIC COS, SQRT
  INTRINSIC KIND
! horizontal spread
  REAL(dp) :: temp
  REAL(dp) :: temp0
  INTEGER :: nd
  REAL(dp), DIMENSION(nbdirs) :: tempb
  INTEGER :: nbdirs
  temp0 = SQRT(8.0_dp)
  temp = ky*deltax0/rotor_diameter
  DO nd=1,nbdirs
    tempb(nd) = sigmayb(nd)
    rotor_diameterb(nd) = rotor_diameterb(nd) + (temp+COS(yaw)/temp0)*&
&     sigmayb(nd) - temp*tempb(nd)
    kyb(nd) = kyb(nd) + deltax0*tempb(nd)
    deltax0b(nd) = deltax0b(nd) + ky*tempb(nd)
    yawb(nd) = yawb(nd) - rotor_diameter*SIN(yaw)*sigmayb(nd)/temp0
  END DO
END SUBROUTINE SIGMAY_FUNC_BV

!  Differentiation of sigmaz_func in reverse (adjoint) mode:
!   gradient     of useful results: sigmaz kz rotor_diameter
!   with respect to varying inputs: kz rotor_diameter deltax0
! calculates the vertical spread of the wake at a given distance from the onset of far 
! wake condition
SUBROUTINE SIGMAZ_FUNC_BV(kz, kzb, deltax0, deltax0b, rotor_diameter, &
& rotor_diameterb, sigmaz, sigmazb, nbdirs)
 ! USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: kz, deltax0, rotor_diameter
  REAL(dp), DIMENSION(nbdirs) :: kzb, deltax0b, rotor_diameterb
! out
  REAL(dp) :: sigmaz
  REAL(dp), DIMENSION(nbdirs) :: sigmazb
! load necessary intrinsic functions
  INTRINSIC SQRT
  INTRINSIC KIND
! vertical spread
  REAL(dp) :: temp
  INTEGER :: nd
  REAL(dp), DIMENSION(nbdirs) :: tempb
  INTEGER :: nbdirs
  temp = kz*deltax0/rotor_diameter
  DO nd=1,nbdirs
    tempb(nd) = sigmazb(nd)
    rotor_diameterb(nd) = rotor_diameterb(nd) + (1.0/SQRT(8.0_dp)+temp)*&
&     sigmazb(nd) - temp*tempb(nd)
    kzb(nd) = kzb(nd) + deltax0*tempb(nd)
    deltax0b(nd) = kz*tempb(nd)
  END DO
END SUBROUTINE SIGMAZ_FUNC_BV

!  Differentiation of wake_offset_func in reverse (adjoint) mode:
!   gradient     of useful results: yaw sigmay sigmaz ky kz rotor_diameter
!                x0 wake_offset ct
!   with respect to varying inputs: theta_c_0 yaw sigmay sigmaz
!                ky kz rotor_diameter x0 ct
! calculates the horizontal distance from the wake center to the hub of the turbine making
! the wake
SUBROUTINE WAKE_OFFSET_FUNC_BV(rotor_diameter, rotor_diameterb, &
& theta_c_0, theta_c_0b, x0, x0b, yaw, yawb, ky, kyb, kz, kzb, ct, ctb, &
& sigmay, sigmayb, sigmaz, sigmazb, wake_offset, wake_offsetb, nbdirs)
 ! USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: rotor_diameter, theta_c_0, x0, yaw, ky, kz, ct&
& , sigmay
  REAL(dp), DIMENSION(nbdirs) :: rotor_diameterb, theta_c_0b, x0b, &
& yawb, kyb, kzb, ctb, sigmayb
  REAL(dp), INTENT(IN) :: sigmaz
  REAL(dp), DIMENSION(nbdirs) :: sigmazb
! out
  REAL(dp) :: wake_offset
  REAL(dp), DIMENSION(nbdirs) :: wake_offsetb
  INTRINSIC COS, SQRT, LOG
  INTRINSIC KIND
! horizontal cross-wind wake displacement from hub
  REAL(dp) :: temp
  REAL(dp) :: temp0
  REAL(dp) :: temp1
  REAL(dp) :: temp2
  REAL(dp) :: temp3
  REAL(dp) :: temp4
  REAL(dp) :: temp5
  REAL(dp) :: temp6
  REAL(dp) :: temp7
  REAL(dp) :: temp8
  REAL(dp) :: temp9
  REAL(dp) :: temp10
  REAL(dp) :: temp11
  REAL(dp) :: temp12
  REAL(dp) :: temp13
  REAL(dp) :: temp14
  REAL(dp) :: temp15
  REAL(dp) :: temp16
  REAL(dp) :: temp17
  REAL(dp) :: temp18
  REAL(dp) :: temp19
  REAL(dp) :: temp20
  REAL(dp) :: temp21
  REAL(dp) :: temp22
  REAL(dp) :: temp23
  INTEGER :: nd
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  REAL(dp), DIMENSION(nbdirs) :: tempb1
  REAL(dp), DIMENSION(nbdirs) :: tempb2
  REAL(dp), DIMENSION(nbdirs) :: tempb3
  REAL(dp), DIMENSION(nbdirs) :: tempb4
  REAL(dp), DIMENSION(nbdirs) :: tempb5
  REAL(dp), DIMENSION(nbdirs) :: tempb6
  REAL(dp), DIMENSION(nbdirs) :: tempb7
  REAL(dp), DIMENSION(nbdirs) :: tempb8
  REAL(dp), DIMENSION(nbdirs) :: tempb9
  INTEGER :: nbdirs
  temp23 = SQRT(ct)
  temp22 = COS(yaw)
  temp7 = temp22*rotor_diameter**2
  temp6 = sigmay*sigmaz/temp7
  temp21 = SQRT(8.0_dp*temp6)
  temp20 = SQRT(ct)
  temp5 = (-temp20+1.6_dp)*(1.6_dp*temp21+temp23)
  temp19 = SQRT(ct)
  temp18 = COS(yaw)
  temp4 = temp18*rotor_diameter**2
  temp3 = sigmay*sigmaz/temp4
  temp17 = SQRT(8.0_dp*temp3)
  temp16 = 1.6_dp*temp17 - temp19
  temp15 = SQRT(ct)
  temp2 = (temp15+1.6_dp)*temp16/temp5
  temp14 = LOG(temp2)
  temp13 = SQRT(-ct + 1.0_dp)
  temp12 = 1.3_dp*temp13 - ct + 2.9_dp
  temp11 = theta_c_0/14.7_dp
  temp1 = ky*kz*ct
  temp10 = COS(yaw)
  temp0 = temp10/temp1
  temp9 = SQRT(temp0)
  temp8 = temp9*temp11*temp12
  temp = theta_c_0*x0/rotor_diameter
  DO nd=1,nbdirs
    tempb(nd) = rotor_diameter*wake_offsetb(nd)
    tempb0(nd) = tempb(nd)/rotor_diameter
    IF (temp0 .EQ. 0.0) THEN
      tempb1(nd) = 0.0
    ELSE
      tempb1(nd) = temp11*temp12*temp14*tempb(nd)/(2.0*temp9*temp1)
    END IF
    tempb2(nd) = -(temp0*tempb1(nd))
    tempb3(nd) = temp14*temp9*tempb(nd)
    tempb4(nd) = temp8*tempb(nd)/(temp2*temp5)
    IF (8.0_dp*temp3 .EQ. 0.0) THEN
      tempb5(nd) = 0.0
    ELSE
      tempb5(nd) = 8.0_dp*1.6_dp*(temp15+1.6_dp)*tempb4(nd)/(2.0*temp17*&
&       temp4)
    END IF
    tempb6(nd) = -(temp3*tempb5(nd))
    tempb7(nd) = -(temp2*tempb4(nd))
    IF (8.0_dp*temp6 .EQ. 0.0) THEN
      tempb8(nd) = 0.0
    ELSE
      tempb8(nd) = 8.0_dp*1.6_dp*(1.6_dp-temp20)*tempb7(nd)/(2.0*temp21*&
&       temp7)
    END IF
    tempb9(nd) = -(temp6*tempb8(nd))
    rotor_diameterb(nd) = rotor_diameterb(nd) + temp22*2*rotor_diameter*&
&     tempb9(nd) + temp18*2*rotor_diameter*tempb6(nd) - temp*tempb0(nd) &
&     + (temp+temp8*temp14)*wake_offsetb(nd)
    theta_c_0b(nd) = temp12*tempb3(nd)/14.7_dp + x0*tempb0(nd)
    x0b(nd) = x0b(nd) + theta_c_0*tempb0(nd)
    yawb(nd) = yawb(nd) - rotor_diameter**2*SIN(yaw)*tempb9(nd) - &
&     rotor_diameter**2*SIN(yaw)*tempb6(nd) - SIN(yaw)*tempb1(nd)
    kyb(nd) = kyb(nd) + ct*kz*tempb2(nd)
    kzb(nd) = kzb(nd) + ct*ky*tempb2(nd)
    IF (1.0_dp - ct .EQ. 0.0) THEN
      ctb(nd) = ctb(nd) + ky*kz*tempb2(nd) - temp11*tempb3(nd)
    ELSE
      ctb(nd) = ctb(nd) + ((1.6_dp-temp20)/(2.0*temp23)-(1.6_dp*temp21+&
&       temp23)/(2.0*temp20))*tempb7(nd) + (temp16/(2.0*temp15)-(temp15+&
&       1.6_dp)/(2.0*temp19))*tempb4(nd) + (-temp11-1.3_dp*temp11/(2.0*&
&       temp13))*tempb3(nd) + ky*kz*tempb2(nd)
    END IF
    sigmayb(nd) = sigmayb(nd) + sigmaz*tempb8(nd) + sigmaz*tempb5(nd)
    sigmazb(nd) = sigmazb(nd) + sigmay*tempb8(nd) + sigmay*tempb5(nd)
  END DO
END SUBROUTINE WAKE_OFFSET_FUNC_BV

!  Differentiation of deltav_func in reverse (adjoint) mode:
!   gradient     of useful results: yaw rotor_diameter_ust deltav
!                deltay ct
!   with respect to varying inputs: yaw rotor_diameter_ust sigmay
!                sigmaz deltay deltaz ct
! calculates the velocity difference between hub velocity and free stream for a given wake
! for use in the far wake region
SUBROUTINE DELTAV_FUNC_BV(deltay, deltayb, deltaz, deltazb, ct, ctb, yaw&
& , yawb, sigmay, sigmayb, sigmaz, sigmazb, rotor_diameter_ust, &
& rotor_diameter_ustb, opt_exp_fac, deltav, deltavb, nbdirs)
 ! USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
!print *, "rotor_diameter in deltav exit", rotor_diameter_ust
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: deltay, deltaz, ct, yaw, sigmay
  REAL(dp), DIMENSION(nbdirs) :: deltayb, deltazb, ctb, yawb, sigmayb
  REAL(dp), INTENT(IN) :: sigmaz, rotor_diameter_ust, opt_exp_fac
  REAL(dp), DIMENSION(nbdirs) :: sigmazb, rotor_diameter_ustb
! out
  REAL(dp) :: deltav
  REAL(dp), DIMENSION(nbdirs) :: deltavb
! load intrinsic functions
  INTRINSIC COS, SQRT, EXP
  INTRINSIC KIND
!print *, "rotor_diameter in deltav entry", rotor_diameter_ust
! velocity difference in the wake at each sample point
  REAL(dp) :: temp
  REAL(dp) :: temp0
  REAL(dp) :: temp1
  REAL(dp) :: temp2
  REAL(dp) :: temp3
  REAL(dp) :: temp4
  REAL(dp) :: temp5
  REAL(dp) :: temp6
  REAL(dp) :: temp7
  REAL(dp) :: temp8
  REAL(dp) :: temp9
  INTEGER :: nd
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  REAL(dp), DIMENSION(nbdirs) :: tempb1
  REAL(dp), DIMENSION(nbdirs) :: tempb2
  REAL(dp), DIMENSION(nbdirs) :: tempb3
  INTEGER :: nbdirs
  temp9 = opt_exp_fac**2*sigmaz**2
  temp2 = deltaz**2/temp9
  temp8 = EXP(-(0.5_dp*temp2))
  temp7 = opt_exp_fac**2*sigmay**2
  temp1 = deltay**2/temp7
  temp6 = EXP(-(0.5_dp*temp1))
  temp0 = 8.0_dp*sigmay*sigmaz
  temp5 = ct*rotor_diameter_ust**2
  temp = temp5/temp0
  temp4 = COS(yaw)
  temp3 = SQRT(-(temp4*temp) + 1.0_dp)
  DO nd=1,nbdirs
    IF (1.0_dp - temp4*temp .EQ. 0.0) THEN
      tempb(nd) = 0.0
    ELSE
      tempb(nd) = -(temp6*temp8*deltavb(nd)/(2.0*temp3))
    END IF
    tempb0(nd) = -(temp4*tempb(nd)/temp0)
    tempb1(nd) = -(temp*tempb0(nd))
    tempb2(nd) = -(0.5_dp*EXP(-(0.5_dp*temp1))*temp8*(1.0_dp-temp3)*&
&     deltavb(nd)/temp7)
    tempb3(nd) = -(0.5_dp*EXP(-(0.5_dp*temp2))*temp6*(1.0_dp-temp3)*&
&     deltavb(nd)/temp9)
    yawb(nd) = yawb(nd) + temp*SIN(yaw)*tempb(nd)
    ctb(nd) = ctb(nd) + rotor_diameter_ust**2*tempb0(nd)
    rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) + ct*2*&
&     rotor_diameter_ust*tempb0(nd)
    sigmayb(nd) = sigmaz*8.0_dp*tempb1(nd) - opt_exp_fac**2*temp1*2*&
&     sigmay*tempb2(nd)
    sigmazb(nd) = 8.0_dp*sigmay*tempb1(nd) - opt_exp_fac**2*temp2*2*&
&     sigmaz*tempb3(nd)
    deltayb(nd) = deltayb(nd) + 2*deltay*tempb2(nd)
    deltazb(nd) = 2*deltaz*tempb3(nd)
  END DO
END SUBROUTINE DELTAV_FUNC_BV

!  Differentiation of deltav_near_wake_lin_func in reverse (adjoint) mode:
!   gradient     of useful results: yaw x rotor_diameter_ust deltav
!                deltay ct
!   with respect to varying inputs: yaw discontinuity_point x rotor_diameter_ust
!                sigmay sigmaz deltay deltaz sigmay0 ct sigmaz0
! calculates the velocity difference between hub velocity and free stream for a given wake
! for use in the near wake region only
SUBROUTINE DELTAV_NEAR_WAKE_LIN_FUNC_BV(deltay, deltayb, deltaz, deltazb&
& , ct, ctb, yaw, yawb, sigmay, sigmayb, sigmaz, sigmazb, &
& rotor_diameter_ust, rotor_diameter_ustb, x, xb, discontinuity_point, &
& discontinuity_pointb, sigmay0, sigmay0b, sigmaz0, sigmaz0b, &
& opt_exp_fac, deltav, deltavb, nbdirs)
 ! USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: deltay, deltaz, ct, yaw, sigmay
  REAL(dp), DIMENSION(nbdirs) :: deltayb, deltazb, ctb, yawb, sigmayb
  REAL(dp), INTENT(IN) :: sigmaz, rotor_diameter_ust, opt_exp_fac
  REAL(dp), DIMENSION(nbdirs) :: sigmazb, rotor_diameter_ustb
  REAL(dp), INTENT(IN) :: x, discontinuity_point, sigmay0, sigmaz0
  REAL(dp), DIMENSION(nbdirs) :: xb, discontinuity_pointb, sigmay0b, &
& sigmaz0b
! local
  REAL(dp) :: deltav0m, deltavr
  REAL(dp), DIMENSION(nbdirs) :: deltav0mb, deltavrb
! out
  REAL(dp) :: deltav
  REAL(dp), DIMENSION(nbdirs) :: deltavb
! load intrinsic functions
  INTRINSIC COS, SQRT, EXP
  INTRINSIC KIND
  REAL(dp) :: temp
  REAL(dp) :: temp0
  REAL(dp) :: temp1
  REAL(dp) :: temp2
  REAL(dp) :: temp3
  REAL(dp) :: temp4
  REAL(dp) :: temp5
  REAL(dp) :: temp6
  REAL(dp) :: temp7
  REAL(dp) :: temp8
  REAL(dp) :: temp9
  INTEGER :: nd
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  REAL(dp), DIMENSION(nbdirs) :: tempb1
  REAL(dp), DIMENSION(nbdirs) :: tempb2
  REAL(dp), DIMENSION(nbdirs) :: tempb3
  REAL(dp), DIMENSION(nbdirs) :: tempb4
  REAL(dp), DIMENSION(nbdirs) :: tempb5
  REAL(dp), DIMENSION(nbdirs) :: tempb6
  INTEGER :: nbdirs
! magnitude term of gaussian at x0
  deltav0m = 1.0_dp - SQRT(1.0_dp - ct*COS(yaw)/(8.0_dp*sigmay0*sigmaz0/&
&   rotor_diameter_ust**2))
! initialize the gaussian magnitude term at the rotor for the linear interpolation
  deltavr = deltav0m
! linearized gaussian magnitude term for near wake
  temp9 = opt_exp_fac**2*sigmaz**2
  temp6 = deltaz**2/temp9
  temp8 = opt_exp_fac**2*sigmay**2
  temp5 = deltay**2/temp8
  temp7 = EXP(-(0.5_dp*temp5))
  temp4 = x/discontinuity_point
  temp3 = (deltav0m-deltavr)*temp4 + deltavr
  temp0 = 8.0_dp*sigmay0*sigmaz0
  temp2 = ct*rotor_diameter_ust**2
  temp = temp2/temp0
  temp1 = COS(yaw)
  DO nd=1,nbdirs
    tempb(nd) = EXP(-(0.5_dp*temp6))*deltavb(nd)
    tempb0(nd) = temp7*tempb(nd)
    tempb1(nd) = (deltav0m-deltavr)*tempb0(nd)/discontinuity_point
    tempb2(nd) = -(0.5_dp*EXP(-(0.5_dp*temp5))*temp3*tempb(nd)/temp8)
    tempb3(nd) = -(0.5_dp*EXP(-(0.5_dp*temp6))*temp3*temp7*deltavb(nd)/&
&     temp9)
    deltavrb(nd) = (1.0-temp4)*tempb0(nd)
    deltav0mb(nd) = deltavrb(nd) + temp4*tempb0(nd)
    xb(nd) = xb(nd) + tempb1(nd)
    discontinuity_pointb(nd) = -(temp4*tempb1(nd))
    deltayb(nd) = deltayb(nd) + 2*deltay*tempb2(nd)
    sigmayb(nd) = -(opt_exp_fac**2*temp5*2*sigmay*tempb2(nd))
    deltazb(nd) = 2*deltaz*tempb3(nd)
    sigmazb(nd) = -(opt_exp_fac**2*temp6*2*sigmaz*tempb3(nd))
    IF (1.0_dp - temp1*temp .EQ. 0.0) THEN
      tempb4(nd) = 0.0
    ELSE
      tempb4(nd) = -(deltav0mb(nd)/(2.0*SQRT(1.0_dp-temp1*temp)))
    END IF
    tempb5(nd) = -(temp1*tempb4(nd)/temp0)
    tempb6(nd) = -(temp*tempb5(nd))
    yawb(nd) = yawb(nd) + temp*SIN(yaw)*tempb4(nd)
    ctb(nd) = ctb(nd) + rotor_diameter_ust**2*tempb5(nd)
    rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) + ct*2*&
&     rotor_diameter_ust*tempb5(nd)
    sigmay0b(nd) = sigmaz0*8.0_dp*tempb6(nd)
    sigmaz0b(nd) = 8.0_dp*sigmay0*tempb6(nd)
  END DO
END SUBROUTINE DELTAV_NEAR_WAKE_LIN_FUNC_BV

!  Differentiation of wake_combination_func in reverse (adjoint) mode:
!   gradient     of useful results: turb_inflow deficit_sum
!   with respect to varying inputs: turb_inflow deficit_sum deltav
! combines wakes using various methods
SUBROUTINE WAKE_COMBINATION_FUNC_BV(wind_speed, turb_inflow, &
& turb_inflowb, deltav, deltavb, wake_combination_method, deficit_sum, &
& deficit_sumb, nbdirs)
 ! USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: wind_speed, turb_inflow, deltav
  REAL(dp), DIMENSION(nbdirs) :: turb_inflowb, deltavb
  INTEGER, INTENT(IN) :: wake_combination_method
! out    
  REAL(dp), INTENT(INOUT) :: deficit_sum
  REAL(dp), DIMENSION(nbdirs), INTENT(INOUT) :: deficit_sumb
! intrinsic functions
  INTRINSIC SQRT
  INTRINSIC KIND
  INTEGER :: nd
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  REAL(dp), DIMENSION(nbdirs) :: tempb1
  INTEGER :: nbdirs
! freestream linear superposition (Lissaman 1979)
  IF (wake_combination_method .EQ. 0) THEN
    DO nd=1,nbdirs
      deltavb(nd) = wind_speed*deficit_sumb(nd)
    END DO
  ELSE IF (wake_combination_method .EQ. 1) THEN
    DO nd=1,nbdirs
      turb_inflowb(nd) = turb_inflowb(nd) + deltav*deficit_sumb(nd)
      deltavb(nd) = turb_inflow*deficit_sumb(nd)
    END DO
  ELSE IF (wake_combination_method .EQ. 2) THEN
    DO nd=1,nbdirs
      IF (deficit_sum**2 + (wind_speed*deltav)**2 .EQ. 0.0) THEN
        tempb(nd) = 0.0
      ELSE
        tempb(nd) = deficit_sumb(nd)/(2.0*SQRT(deficit_sum**2+(&
&         wind_speed*deltav)**2))
      END IF
      deltavb(nd) = 2*wind_speed**2*deltav*tempb(nd)
      deficit_sumb(nd) = 2*deficit_sum*tempb(nd)
    END DO
  ELSE IF (wake_combination_method .EQ. 3) THEN
    DO nd=1,nbdirs
      IF (deficit_sum**2 + (turb_inflow*deltav)**2 .EQ. 0.0) THEN
        tempb0(nd) = 0.0
      ELSE
        tempb0(nd) = deficit_sumb(nd)/(2.0*SQRT(deficit_sum**2+(&
&         turb_inflow*deltav)**2))
      END IF
      tempb1(nd) = 2*turb_inflow*deltav*tempb0(nd)
      turb_inflowb(nd) = turb_inflowb(nd) + deltav*tempb1(nd)
      deltavb(nd) = turb_inflow*tempb1(nd)
      deficit_sumb(nd) = 2*deficit_sum*tempb0(nd)
    END DO
  ELSE
    STOP
  END IF
END SUBROUTINE WAKE_COMBINATION_FUNC_BV

!  Differentiation of added_ti_func in reverse (adjoint) mode:
!   gradient     of useful results: k_star_ust rotor_diameter_ust
!                wake_height turbine_height ti_dst ct_ust rotor_diameter_dst
!                ti_ust
!   with respect to varying inputs: k_star_ust x rotor_diameter_ust
!                wake_height turbine_height ti_dst ct_ust deltay
!                rotor_diameter_dst ti_ust
! combines wakes using various methods
SUBROUTINE ADDED_TI_FUNC_BV(ti, ct_ust, ct_ustb, x, xb, k_star_ust, &
& k_star_ustb, rotor_diameter_ust, rotor_diameter_ustb, &
& rotor_diameter_dst, rotor_diameter_dstb, deltay, deltayb, wake_height&
& , wake_heightb, turbine_height, turbine_heightb, ti_ust, ti_ustb, &
& ti_calculation_method, ti_dst, ti_dstb, nbdirs)
 ! USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
!print *, "ratio: ", wake_overlap/rotor_area_dst
!print *, "Dr, Dw: ", rotor_diameter_dst, wake_diameter
!print *, "Ar, Aol: ", rotor_area_dst, wake_overlap          
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: ct_ust, x, k_star_ust, rotor_diameter_ust, &
& rotor_diameter_dst
  REAL(dp), DIMENSION(nbdirs) :: ct_ustb, xb, k_star_ustb, &
& rotor_diameter_ustb, rotor_diameter_dstb
  REAL(dp), INTENT(IN) :: deltay, wake_height, turbine_height, ti_ust, &
& ti
  REAL(dp), DIMENSION(nbdirs) :: deltayb, wake_heightb, &
& turbine_heightb, ti_ustb
  INTEGER, INTENT(IN) :: ti_calculation_method
! local
  REAL(dp) :: axial_induction_ust, beta, epsilon, sigma, wake_diameter, &
& wake_overlap
  REAL(dp), DIMENSION(nbdirs) :: axial_induction_ustb, betab, &
& epsilonb, sigmab, wake_diameterb, wake_overlapb
  REAL(dp) :: ti_added, ti_tmp, rotor_area_dst
  REAL(dp), DIMENSION(nbdirs) :: ti_addedb, ti_tmpb, rotor_area_dstb
  REAL(dp), PARAMETER :: pi=3.141592653589793_dp
! out  
  REAL(dp), INTENT(INOUT) :: ti_dst
  REAL(dp), DIMENSION(nbdirs), INTENT(INOUT) :: ti_dstb
! intrinsic functions
  INTRINSIC SQRT
  INTRINSIC KIND
  REAL(dp) :: temp
  REAL(dp) :: temp0
  REAL(dp) :: temp1
  REAL(dp) :: temp2
  REAL(dp) :: temp3
  REAL(dp) :: temp4
  INTEGER :: nd
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  REAL(dp), DIMENSION(nbdirs) :: tempb1
  REAL(dp), DIMENSION(nbdirs) :: tempb2
  REAL(dp), DIMENSION(nbdirs) :: tempb3
  REAL(dp) :: temp5
  REAL(dp) :: temp6
  REAL(dp) :: temp7
  REAL(dp) :: temp8
  REAL(dp) :: temp9
  REAL(dp) :: temp10
  REAL(dp), DIMENSION(nbdirs) :: tempb4
  REAL(dp), DIMENSION(nbdirs) :: tempb5
  REAL(dp), DIMENSION(nbdirs) :: tempb6
  REAL(dp), DIMENSION(nbdirs) :: tempb7
  INTEGER :: nbdirs
!print *, "TI_dst in: ", TI_dst
! Niayifar and Porte Agel 2015, 2016 (adjusted by Annoni and Thomas for SOWFA match 
! and optimization)
  IF (ti_calculation_method .EQ. 1) THEN
! calculate axial induction based on the Ct value
    CALL CT_TO_AXIAL_IND_FUNC(ct_ust, axial_induction_ust)
! calculate BPA spread parameters Bastankhah and Porte Agel 2014
    beta = 0.5_dp*((1.0_dp+SQRT(1.0_dp-ct_ust))/SQRT(1.0_dp-ct_ust))
    epsilon = 0.2_dp*SQRT(beta)
!print *, "epsilon = ", epsilon
! calculate wake spread for TI calcs
    sigma = k_star_ust*x + rotor_diameter_ust*epsilon
    wake_diameter = 4.0_dp*sigma
!print *, "sigma = ", sigma
! calculate wake overlap ratio
    CALL OVERLAP_AREA_FUNC(deltay, turbine_height, rotor_diameter_dst, &
&                    0.0_dp, wake_height, wake_diameter, wake_overlap)
!print *, "wake_overlap = ", wake_overlap   
! Calculate the turbulence added to the inflow of the downstream turbine by the 
! wake of the upstream turbine
    ti_added = 0.73_dp*axial_induction_ust**0.8325_dp*ti_ust**0.0325_dp*&
&     (x/rotor_diameter_ust)**(-0.32_dp)
!print *, "TI_added = ", TI_added
    rotor_area_dst = 0.25_dp*pi*rotor_diameter_dst**2_dp
! Calculate the total turbulence intensity at the downstream turbine
!sum_of_squares = TI_dst**2 + (TI_added*wake_overlap)**2
! print *, "sum of squares = ", sum_of_squares
!         TI_dst = sqrt(sum_of_squares)
!         print *, "TI_dst = ", TI_dst
! Niayifar and Porte Agel 2015, 2016
    temp4 = ti_added*wake_overlap/rotor_area_dst
    temp1 = x/rotor_diameter_ust
    temp3 = ti_ust**0.0325_dp
    temp2 = axial_induction_ust**0.8325_dp
    temp0 = SQRT(-ct_ust + 1.0_dp)
    temp = SQRT(-ct_ust + 1.0_dp)
    DO nd=1,nbdirs
      IF (ti_dst**2.0_dp + temp4**2.0_dp .EQ. 0.0) THEN
        tempb(nd) = 0.0
      ELSE
        tempb(nd) = ti_dstb(nd)/(2.0*SQRT(ti_dst**2.0_dp+temp4**2.0_dp))
      END IF
      tempb0(nd) = 2.0_dp*temp4*tempb(nd)/rotor_area_dst
      ti_addedb(nd) = wake_overlap*tempb0(nd)
      wake_overlapb(nd) = ti_added*tempb0(nd)
      rotor_area_dstb(nd) = -(temp4*tempb0(nd))
      ti_dstb(nd) = 2.0_dp*ti_dst*tempb(nd)
      rotor_diameter_dstb(nd) = rotor_diameter_dstb(nd) + pi*0.25_dp*&
&       2_dp*rotor_diameter_dst*rotor_area_dstb(nd)
      tempb1(nd) = 0.73_dp*temp1**(-0.32_dp)*ti_addedb(nd)
      tempb2(nd) = -(0.32_dp*temp1**(-1.32)*temp2*temp3*0.73_dp*&
&       ti_addedb(nd)/rotor_diameter_ust)
      axial_induction_ustb(nd) = temp3*0.8325_dp*axial_induction_ust**(&
&       -0.1675)*tempb1(nd)
      ti_ustb(nd) = ti_ustb(nd) + temp2*0.0325_dp*ti_ust**(-0.9675)*&
&       tempb1(nd)
    END DO
    CALL OVERLAP_AREA_FUNC_BV(deltay, deltayb, turbine_height, &
&                       turbine_heightb, rotor_diameter_dst, &
&                       rotor_diameter_dstb, 0.0_dp, wake_height, &
&                       wake_heightb, wake_diameter, wake_diameterb, &
&                       wake_overlap, wake_overlapb, nbdirs)
    DO nd=1,nbdirs
      sigmab(nd) = 4.0_dp*wake_diameterb(nd)
      xb(nd) = k_star_ust*sigmab(nd) + tempb2(nd)
      rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) + epsilon*sigmab&
&       (nd) - temp1*tempb2(nd)
      k_star_ustb(nd) = k_star_ustb(nd) + x*sigmab(nd)
      epsilonb(nd) = rotor_diameter_ust*sigmab(nd)
      IF (beta .EQ. 0.0) THEN
        betab(nd) = 0.0
      ELSE
        betab(nd) = 0.2_dp*epsilonb(nd)/(2.0*SQRT(beta))
      END IF
      tempb3(nd) = 0.5_dp*betab(nd)/temp0
      IF (.NOT.1.0_dp - ct_ust .EQ. 0.0) ct_ustb(nd) = ct_ustb(nd) + ((&
&         temp+1.0_dp)/(2.0*temp0**2)-1.0/(2.0*temp))*tempb3(nd)
    END DO
    CALL CT_TO_AXIAL_IND_FUNC_BV(ct_ust, ct_ustb, axial_induction_ust, &
&                          axial_induction_ustb, nbdirs)
  ELSE IF (ti_calculation_method .EQ. 2) THEN
! calculate axial induction based on the Ct value
    CALL CT_TO_AXIAL_IND_FUNC(ct_ust, axial_induction_ust)
! calculate BPA spread parameters Bastankhah and Porte Agel 2014
    beta = 0.5_dp*((1.0_dp+SQRT(1.0_dp-ct_ust))/SQRT(1.0_dp-ct_ust))
    epsilon = 0.2_dp*SQRT(beta)
! calculate wake spread for TI calcs
    sigma = k_star_ust*x + rotor_diameter_ust*epsilon
    wake_diameter = 4.0_dp*sigma
! calculate wake overlap ratio
    CALL OVERLAP_AREA_FUNC(deltay, turbine_height, rotor_diameter_dst, &
&                    0.0_dp, wake_height, wake_diameter, wake_overlap)
! Calculate the turbulence added to the inflow of the downstream turbine by the 
! wake of the upstream turbine
    ti_added = 0.73_dp*axial_induction_ust**0.8325_dp*ti_ust**0.0325_dp*&
&     (x/rotor_diameter_ust)**(-0.32_dp)
! Calculate the total turbulence intensity at the downstream turbine based on 
! current upstream turbine
    rotor_area_dst = 0.25_dp*pi*rotor_diameter_dst**2_dp
    ti_tmp = SQRT(ti**2.0_dp + (ti_added*(wake_overlap/rotor_area_dst))&
&     **2.0_dp)
! Check if this is the max and use it if it is
    IF (ti_tmp .GT. ti_dst) THEN
      DO nd=1,nbdirs
        ti_tmpb(nd) = ti_dstb(nd)
      END DO
      DO nd=1,nbdirs
        ti_dstb(nd) = 0.0
      END DO
    ELSE
      DO nd=1,nbdirs
        ti_tmpb(nd) = 0.0
      END DO
    END IF
    temp10 = ti_added*wake_overlap/rotor_area_dst
    temp7 = x/rotor_diameter_ust
    temp9 = ti_ust**0.0325_dp
    temp8 = axial_induction_ust**0.8325_dp
    temp6 = SQRT(-ct_ust + 1.0_dp)
    temp5 = SQRT(-ct_ust + 1.0_dp)
    DO nd=1,nbdirs
      IF (ti**2.0_dp + temp10**2.0_dp .EQ. 0.0) THEN
        tempb4(nd) = 0.0
      ELSE
        tempb4(nd) = 2.0_dp*temp10*ti_tmpb(nd)/(2.0*SQRT(ti**2.0_dp+&
&         temp10**2.0_dp)*rotor_area_dst)
      END IF
      ti_addedb(nd) = wake_overlap*tempb4(nd)
      wake_overlapb(nd) = ti_added*tempb4(nd)
      rotor_area_dstb(nd) = -(temp10*tempb4(nd))
      rotor_diameter_dstb(nd) = rotor_diameter_dstb(nd) + pi*0.25_dp*&
&       2_dp*rotor_diameter_dst*rotor_area_dstb(nd)
      tempb5(nd) = 0.73_dp*temp7**(-0.32_dp)*ti_addedb(nd)
      tempb6(nd) = -(0.32_dp*temp7**(-1.32)*temp8*temp9*0.73_dp*&
&       ti_addedb(nd)/rotor_diameter_ust)
      axial_induction_ustb(nd) = temp9*0.8325_dp*axial_induction_ust**(&
&       -0.1675)*tempb5(nd)
      ti_ustb(nd) = ti_ustb(nd) + temp8*0.0325_dp*ti_ust**(-0.9675)*&
&       tempb5(nd)
    END DO
    CALL OVERLAP_AREA_FUNC_BV(deltay, deltayb, turbine_height, &
&                       turbine_heightb, rotor_diameter_dst, &
&                       rotor_diameter_dstb, 0.0_dp, wake_height, &
&                       wake_heightb, wake_diameter, wake_diameterb, &
&                       wake_overlap, wake_overlapb, nbdirs)
    DO nd=1,nbdirs
      sigmab(nd) = 4.0_dp*wake_diameterb(nd)
      xb(nd) = k_star_ust*sigmab(nd) + tempb6(nd)
      rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) + epsilon*sigmab&
&       (nd) - temp7*tempb6(nd)
      k_star_ustb(nd) = k_star_ustb(nd) + x*sigmab(nd)
      epsilonb(nd) = rotor_diameter_ust*sigmab(nd)
      IF (beta .EQ. 0.0) THEN
        betab(nd) = 0.0
      ELSE
        betab(nd) = 0.2_dp*epsilonb(nd)/(2.0*SQRT(beta))
      END IF
      tempb7(nd) = 0.5_dp*betab(nd)/temp6
      IF (.NOT.1.0_dp - ct_ust .EQ. 0.0) ct_ustb(nd) = ct_ustb(nd) + ((&
&         temp5+1.0_dp)/(2.0*temp6**2)-1.0/(2.0*temp5))*tempb7(nd)
    END DO
    CALL CT_TO_AXIAL_IND_FUNC_BV(ct_ust, ct_ustb, axial_induction_ust, &
&                          axial_induction_ustb, nbdirs)
  ELSE
!print *, "sigma: ", sigma
! TODO add other TI calculation methods
! wake combination method error 
    STOP
  END IF
END SUBROUTINE ADDED_TI_FUNC_BV

!  Differentiation of overlap_area_func in reverse (adjoint) mode:
!   gradient     of useful results: rotor_diameter turbine_z wake_center_z
!                wake_overlap
!   with respect to varying inputs: wake_diameter rotor_diameter
!                turbine_y turbine_z wake_center_z
! calculates the overlap area between a given wake and a rotor area
SUBROUTINE OVERLAP_AREA_FUNC_BV(turbine_y, turbine_yb, turbine_z, &
& turbine_zb, rotor_diameter, rotor_diameterb, wake_center_y, &
& wake_center_z, wake_center_zb, wake_diameter, wake_diameterb, &
& wake_overlap, wake_overlapb, nbdirs)
 ! USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
!print *, "wake overlap in func: ", wake_overlap
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: turbine_y, turbine_z, rotor_diameter
  REAL(dp), DIMENSION(nbdirs) :: turbine_yb, turbine_zb, &
& rotor_diameterb
  REAL(dp), INTENT(IN) :: wake_center_y, wake_center_z, wake_diameter
  REAL(dp), DIMENSION(nbdirs) :: wake_center_zb, wake_diameterb
! out    
  REAL(dp) :: wake_overlap
  REAL(dp), DIMENSION(nbdirs) :: wake_overlapb
! local
  REAL(dp), PARAMETER :: pi=3.141592653589793_dp, tol=0.000001_dp
  REAL(dp) :: ovdyd, ovr, ovrr, ovl, ovz
  REAL(dp), DIMENSION(nbdirs) :: ovdydb, ovrb, ovrrb, ovlb, ovzb
! load intrinsic functions
  INTRINSIC DACOS, SQRT
  INTRINSIC KIND
  INTEGER :: nd
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  REAL(dp), DIMENSION(nbdirs) :: tempb1
  REAL(dp) :: temp
  REAL(dp) :: temp0
  REAL(dp), DIMENSION(nbdirs) :: tempb2
  REAL(dp), DIMENSION(nbdirs) :: tempb3
  INTEGER :: branch
  INTEGER :: nbdirs
! distance between wake center and rotor center
  ovdyd = SQRT((wake_center_y-turbine_y)**2_dp + (wake_center_z-&
&   turbine_z)**2_dp)
!print *, "OVdYd: ", OVdYd
! find rotor radius
  ovr = rotor_diameter/2.0_dp
!print *, "OVr: ", OVr
! find wake radius
  ovrr = wake_diameter/2.0_dp
!print *, "OVRR: ", OVRR
! make sure the distance from wake center to turbine hub is positive
! OVdYd = abs(OVdYd) !!! commented out since change to 2D distance (y,z) will always be positive
! calculate the distance from the wake center to the line perpendicular to the 
! line between the two circle intersection points
  IF (ovdyd .GE. 0.0_dp + tol) THEN
! check case to avoid division by zero
    ovl = (-(ovr*ovr)+ovrr*ovrr+ovdyd*ovdyd)/(2.0_dp*ovdyd)
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
    ovl = 0.0_dp
  END IF
  ovz = ovrr*ovrr - ovl*ovl
! Finish calculating the distance from the intersection line to the outer edge of the wake
  IF (ovz .GT. 0.0_dp + tol) THEN
    CALL PUSHREAL4ARRAY(ovz, dp/4)
    ovz = SQRT(ovz)
    CALL PUSHCONTROL1B(0)
  ELSE
    ovz = 0.0_dp
    CALL PUSHCONTROL1B(1)
  END IF
  IF (ovdyd .LT. ovr + ovrr) THEN
! if the rotor overlaps the wake
!print *, "OVL: ", OVL
!if (OVL < OVRR .and. (OVdYd-OVL) < OVr) then
    IF (ovdyd .GT. 0.0_dp + tol) THEN
      temp = ovl/ovrr
      temp0 = (ovdyd-ovl)/ovr
      DO nd=1,nbdirs
        IF (temp .EQ. 1.0 .OR. temp .EQ. (-1.0)) THEN
          tempb2(nd) = 0.0
        ELSE
          tempb2(nd) = -(ovrr*wake_overlapb(nd)/SQRT(1.D0-temp**2))
        END IF
        IF (temp0 .EQ. 1.0 .OR. temp0 .EQ. (-1.0)) THEN
          tempb3(nd) = 0.0
        ELSE
          tempb3(nd) = -(ovr*wake_overlapb(nd)/SQRT(1.D0-temp0**2))
        END IF
        ovrrb(nd) = DACOS(temp)*2*ovrr*wake_overlapb(nd) - temp*tempb2(&
&         nd)
        ovlb(nd) = tempb2(nd) - tempb3(nd)
        ovrb(nd) = DACOS(temp0)*2*ovr*wake_overlapb(nd) - temp0*tempb3(&
&         nd)
        ovdydb(nd) = tempb3(nd) - ovz*wake_overlapb(nd)
        ovzb(nd) = -(ovdyd*wake_overlapb(nd))
      END DO
    ELSE
      IF (ovrr .GT. ovr) THEN
        DO nd=1,nbdirs
          ovrb(nd) = pi*2*ovr*wake_overlapb(nd)
        END DO
        DO nd=1,nbdirs
          ovrrb(nd) = 0.0
        END DO
      ELSE
        DO nd=1,nbdirs
          ovrrb(nd) = pi*2*ovrr*wake_overlapb(nd)
        END DO
        DO nd=1,nbdirs
          ovrb(nd) = 0.0
        END DO
      END IF
      DO nd=1,nbdirs
        ovdydb(nd) = 0.0
        ovlb(nd) = 0.0
        ovzb(nd) = 0.0
      END DO
    END IF
  ELSE
    DO nd=1,nbdirs
      ovdydb(nd) = 0.0
      ovlb(nd) = 0.0
      ovrb(nd) = 0.0
      ovrrb(nd) = 0.0
      ovzb(nd) = 0.0
    END DO
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    CALL POPREAL4ARRAY(ovz, dp/4)
    DO nd=1,nbdirs
      IF (ovz .EQ. 0.0) THEN
        ovzb(nd) = 0.0
      ELSE
        ovzb(nd) = ovzb(nd)/(2.0*SQRT(ovz))
      END IF
    END DO
  ELSE
    DO nd=1,nbdirs
      ovzb(nd) = 0.0
    END DO
  END IF
  DO nd=1,nbdirs
    ovrrb(nd) = ovrrb(nd) + 2*ovrr*ovzb(nd)
    ovlb(nd) = ovlb(nd) - 2*ovl*ovzb(nd)
  END DO
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    DO nd=1,nbdirs
      tempb1(nd) = ovlb(nd)/(2.0_dp*ovdyd)
      ovrrb(nd) = ovrrb(nd) + 2*ovrr*tempb1(nd)
      ovrb(nd) = ovrb(nd) - 2*ovr*tempb1(nd)
      ovdydb(nd) = ovdydb(nd) + (2*ovdyd-(ovrr**2-ovr**2+ovdyd**2)/ovdyd&
&       )*tempb1(nd)
    END DO
  END IF
  DO nd=1,nbdirs
    wake_diameterb(nd) = ovrrb(nd)/2.0_dp
    rotor_diameterb(nd) = rotor_diameterb(nd) + ovrb(nd)/2.0_dp
    IF ((wake_center_y-turbine_y)**2_dp + (wake_center_z-turbine_z)**&
&       2_dp .EQ. 0.0) THEN
      tempb(nd) = 0.0
    ELSE
      tempb(nd) = ovdydb(nd)/(2.0*SQRT((wake_center_y-turbine_y)**2_dp+(&
&       wake_center_z-turbine_z)**2_dp))
    END IF
    tempb0(nd) = 2_dp*(wake_center_z-turbine_z)*tempb(nd)
    turbine_yb(nd) = -(2_dp*(wake_center_y-turbine_y)*tempb(nd))
    wake_center_zb(nd) = wake_center_zb(nd) + tempb0(nd)
    turbine_zb(nd) = turbine_zb(nd) - tempb0(nd)
  END DO
END SUBROUTINE OVERLAP_AREA_FUNC_BV

!  Differentiation of k_star_func in reverse (adjoint) mode:
!   gradient     of useful results: k_star_ust ti_ust
!   with respect to varying inputs: ti_ust
! compute wake spread parameter based on local turbulence intensity
SUBROUTINE K_STAR_FUNC_BV(ti_ust, ti_ustb, k_star_ust, k_star_ustb, &
& nbdirs)
 ! USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: ti_ust
  REAL(dp), DIMENSION(nbdirs) :: ti_ustb
! out  
  REAL(dp), INTENT(INOUT) :: k_star_ust
  REAL(dp), DIMENSION(nbdirs), INTENT(INOUT) :: k_star_ustb
  INTRINSIC KIND
! calculate wake spread parameter from Niayifar and Porte Agel (2015, 2016)
  INTEGER :: nd
  INTEGER :: nbdirs
  DO nd=1,nbdirs
    ti_ustb(nd) = ti_ustb(nd) + 0.3837*k_star_ustb(nd)
  END DO
END SUBROUTINE K_STAR_FUNC_BV

!  Differentiation of ct_to_axial_ind_func in reverse (adjoint) mode:
!   gradient     of useful results: axial_induction ct
!   with respect to varying inputs: ct
! calculate axial induction from Ct
SUBROUTINE CT_TO_AXIAL_IND_FUNC_BV(ct, ctb, axial_induction, &
& axial_inductionb, nbdirs)
 ! USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: ct
  REAL(dp), DIMENSION(nbdirs) :: ctb
! out
  REAL(dp) :: axial_induction
  REAL(dp), DIMENSION(nbdirs) :: axial_inductionb
  INTRINSIC KIND
  INTRINSIC SQRT
  INTEGER :: nd
  INTEGER :: nbdirs
! initialize axial induction to zero
! calculate axial induction
  IF (ct .GT. 0.96) THEN
    DO nd=1,nbdirs
      IF (.NOT.0.0203_dp - 0.6427_dp*(0.889_dp-ct) .EQ. 0.0) ctb(nd) = &
&         ctb(nd) + 0.6427_dp*axial_inductionb(nd)/(2.0*SQRT(0.0203_dp-&
&         0.6427_dp*(0.889_dp-ct)))
    END DO
  ELSE
    DO nd=1,nbdirs
      IF (.NOT.1.0_dp - ct .EQ. 0.0) ctb(nd) = ctb(nd) + 0.5_dp*&
&         axial_inductionb(nd)/(2.0*SQRT(1.0_dp-ct))
    END DO
  END IF
END SUBROUTINE CT_TO_AXIAL_IND_FUNC_BV

!  Differentiation of wind_shear_func in reverse (adjoint) mode:
!   gradient     of useful results: adjusted_wind_speed
!   with respect to varying inputs: point_z u_ref
! adjust wind speed for wind shear
SUBROUTINE WIND_SHEAR_FUNC_BV(point_z, point_zb, u_ref, u_refb, z_ref, &
& z_0, shear_exp, adjusted_wind_speed, adjusted_wind_speedb, nbdirs)
 ! USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: point_z, u_ref, z_ref, z_0, shear_exp
  REAL(dp), DIMENSION(nbdirs) :: point_zb, u_refb
! out
  REAL(dp) :: adjusted_wind_speed
  REAL(dp), DIMENSION(nbdirs) :: adjusted_wind_speedb
  INTRINSIC KIND
  REAL(dp) :: temp
  INTEGER :: nd
  INTEGER :: nbdirs
! initialize adjusted wind speed to zero
! check that the point of interest is above ground level
  IF (point_z .GE. z_0) THEN
    temp = (point_z-z_0)/(z_ref-z_0)
    DO nd=1,nbdirs
      u_refb(nd) = temp**shear_exp*adjusted_wind_speedb(nd)
      IF (temp .LE. 0.0 .AND. (shear_exp .EQ. 0.0 .OR. shear_exp .NE. &
&         INT(shear_exp))) THEN
        point_zb(nd) = 0.0
      ELSE
        point_zb(nd) = shear_exp*temp**(shear_exp-1)*u_ref*&
&         adjusted_wind_speedb(nd)/(z_ref-z_0)
      END IF
    END DO
  ELSE
    DO nd=1,nbdirs
      point_zb(nd) = 0.0
      u_refb(nd) = 0.0
    END DO
  END IF
END SUBROUTINE WIND_SHEAR_FUNC_BV

!  Differentiation of discontinuity_point_func in reverse (adjoint) mode:
!   gradient     of useful results: yaw discontinuity_point ky
!                kz rotor_diameter x0 ct
!   with respect to varying inputs: yaw ky kz rotor_diameter x0
!                ct
! calculate the point where the Bastankhah and Porte Agel wake model becomes undefined
SUBROUTINE DISCONTINUITY_POINT_FUNC_BV(x0, x0b, rotor_diameter, &
& rotor_diameterb, ky, kyb, kz, kzb, yaw, yawb, ct, ctb, &
& discontinuity_point, discontinuity_pointb, nbdirs)
 ! USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: x0, rotor_diameter, ky, kz, yaw, ct
  REAL(dp), DIMENSION(nbdirs) :: x0b, rotor_diameterb, kyb, kzb, yawb&
& , ctb
! local
  REAL(dp) :: a, b, c
  REAL(dp), DIMENSION(nbdirs) :: ab, bb, cb
! out
  REAL(dp) :: discontinuity_point
  REAL(dp), DIMENSION(nbdirs) :: discontinuity_pointb
  INTRINSIC COS, SQRT
  INTRINSIC KIND
  REAL(dp) :: temp
  REAL(dp) :: temp0
  INTEGER :: nd
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  REAL(dp), DIMENSION(nbdirs) :: tempb1
  REAL(dp), DIMENSION(nbdirs) :: tempb2
  INTEGER :: nbdirs
! for clarity, break out the terms in the equation
  a = ky + kz*COS(yaw)
  b = 4.0_dp*ky*kz*COS(yaw)*(ct-1.0_dp)
  c = 2.0_dp*SQRT(8.0_dp)*ky*kz
! distance from rotor to the last point where the wake model is undefined
  temp0 = a**2 - b
  temp = SQRT(temp0)
  DO nd=1,nbdirs
    tempb(nd) = rotor_diameter*discontinuity_pointb(nd)/c
    tempb0(nd) = (a-temp)*discontinuity_pointb(nd)/c
    x0b(nd) = x0b(nd) + discontinuity_pointb(nd)
    IF (temp0 .EQ. 0.0) THEN
      ab(nd) = tempb(nd)
    ELSE
      ab(nd) = (1.0-2*a/(2.0*temp))*tempb(nd)
    END IF
    IF (temp0 .EQ. 0.0) THEN
      bb(nd) = 0.0
    ELSE
      bb(nd) = tempb(nd)/(2.0*temp)
    END IF
    rotor_diameterb(nd) = rotor_diameterb(nd) + tempb0(nd)
    cb(nd) = -(rotor_diameter*tempb0(nd)/c)
    tempb1(nd) = SQRT(8.0_dp)*2.0_dp*cb(nd)
    tempb2(nd) = 4.0_dp*COS(yaw)*bb(nd)
    kyb(nd) = kyb(nd) + (ct-1.0_dp)*kz*tempb2(nd) + ab(nd) + kz*tempb1(&
&     nd)
    kzb(nd) = kzb(nd) + (ct-1.0_dp)*ky*tempb2(nd) + COS(yaw)*ab(nd) + ky&
&     *tempb1(nd)
    ctb(nd) = ctb(nd) + ky*kz*tempb2(nd)
    yawb(nd) = yawb(nd) - kz*SIN(yaw)*ab(nd) - ky*kz*(ct-1.0_dp)*4.0_dp*&
&     SIN(yaw)*bb(nd)
  END DO
END SUBROUTINE DISCONTINUITY_POINT_FUNC_BV

