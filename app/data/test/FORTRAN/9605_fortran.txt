

!	This program will find the solutions of a function within a
!	defined tolerance range


!	***   I/O compatible with 64bit function values   ***


!	INPUT		Main interval for zeroes calculation
!	INPUT		Tolerance value range
!	OUTPUT		Solution


!		GNU GENERAL PUBLIC LICENSE V3.0
!		V1.1.1 - Developed by Mattia Verticchio
!		Last update 19/10/2016

!__________________________________________________________________

        implicit none
    
        real*16 x1,x2,tol,funct,f1,f2,q,xs,fs
    	integer k,m,input
   	
    	print *,' '
    	print *, 'Program to calculate the solutions of a known function'
    	print *,' '
    	print *, 'Which method do you want to use?'
    	print *,' '
1    	print *, '1 - secant method'
    	print *, '2 - bisection method'
    	print *, '3 - Newton method'
    	print *,' '
    	
    	write (*,"(' Choice : ')",advance='no')
    	read *,input
    	
    	select case (input)
    	case(1)
    		call def1(x1,x2,tol)
    		call zeroes_finder(x1,x2)
    		call secant(x1,x2,tol,xs)
    	case(2)
    		call def1(x1,x2,tol)
    		call zeroes_finder(x1,x2)
    		call bisection(x1,x2,tol,xs)
    	case(3)
    		call def2(m,tol,xs)
    		call newton(m,tol,xs)
    	case default
    		print *, ' '
    		print *, 'Define a valid option : '
    		go to 1
    	end select

     	
     	print *,'The solution is : ', xs
     	
        end
        
!__________________________________________________________________


!       Main function

!	The main program will calculate the solutions of the following function:


        function funct(x)
        implicit none
        real*16 x,funct
        
        funct=x**2-1
        
        end
        

!__________________________________________________________________


!       Main function derivative


        function deriv(x)
        implicit none
        real*16 x,deriv
        
        deriv=2*x
        
        end
        

!__________________________________________________________________


!       Values defining (by user input) subroutine :

!       OUT     x1      left value
!       OUT     x2      right value
!       OUT     tol     tolerance



        subroutine def1(x1,x2,tol)
        implicit none
        real*16 x1,x2,tol
        
!	Interval values requests :

1       print *,' '
        write (*,"(' Define x1 value : ')",advance='no')
        read *,x1
        print *,' '
        write (*,"(' Define x2 value : ')",advance='no')
        read *,x2
        print *,' '

!       x1 must be lower than x2
!	The following script will give a feedback for invalid values

        if (x2.lt.x1) then
                print *, 'Invalid values, x1 > x2'
                go to 1
                
!       x1 must not be equal to x2
!	The following script will give a feedback for invalid values

        else if (x1.eq.x2) then
                print *, 'Invalid values, x1 = x2'
                go to 1
        endif

!	Tolerance value request :

2       write (*,"(' Define maximum tolerance value : ')",advance='no')
        read *,tol
        print *,' '

!       Tolerance must be greater than 0
!	The following scripts will give a feedback for invalid values

        if (tol.lt.0) then
                print *, 'Invalid tolerance value, tolerance < 0'
                go to 2
        else if (tol.eq.0) then
                print *, 'Invalid tolerance value, tolerance = 0'
                go to 2
        endif
       
        return
        end

!__________________________________________________________________


!       Values defining (by user input) subroutine :

!       OUT     m      	maximum number of iterations
!       OUT     tol     convergence criterion abs( function / derivative )
!       OUT     xs	solution



        subroutine def2(m,tol,xs)
        implicit none
        real*16 xs,tol,h
        integer m
        
!	Initial value request :

        print *,' '
        write (*,"('Define the initial value : ')",advance='no')
        read *,xs
        print *,' '
        
!	Maximum iteration value request :
        
1	write (*,"('Maximum iterations : ')", advance='no')
        read *,h
        print *,' '

!	m must be integer

	if ( (h - int(h)) .ne. 0 ) then
		print *, 'Invalid maximum value' 
                print *, 'It must be integer'
                go to 1
        else
        	m = int(h)
        endif

!	Convergence criterion request :

2       write (*,"('Define the convergence criterion : ')",advance='no')
        read *,tol
        print *,' '

!       Convergence criterion must be greater than 0
!	The following scripts will give a feedback for invalid values

        if (tol.lt.0) then
                print *, 'Invalid tolerance value' 
                print *, 'Convergenge criterion must not be < 0'
                go to 2
        else if (tol.eq.0) then
                print *, 'Invalid tolerance value' 
                print *, 'Convergenge criterion must not be = 0'
                go to 2
        endif
       
        return
        end

!__________________________________________________________________


!       Subroutine, function calculation of a straight line passing 
!	through two known points

!       IN      x1      |
!       IN      y1      |  Two points 
!       IN      x2      |   Location
!       IN      y2      |
!       OUT     m       Angular coefficient
!       OUT     q       Known term


        subroutine two_points_line(x1,y1,x2,y2,m,q)
        implicit none
        real*16 x1,y1,x2,y2,m,q
        
!       This is the complete function
!       (y-y1)/(y2-y1)=(x-x1)/(x2-x1)

!	y = x * ((y2-y1)/(x2-x1)) - ( x1 * ((y2-y1)/(x2-x1))) + y1

	m = ((y2-y1)/(x2-x1))
	q = - ( x1 * ((y2-y1)/(x2-x1))) + y1

        return
        end
       
!__________________________________________________________________


!	Solution calculation by secant method


!	IN	x1	Left interval value
!	IN	x2	Right interval value
!	IN	tol	Tolerance
!	OUT	xs	Solution

	
	subroutine secant(x1,x2,tol,xs)
	integer k
	real*16 x1,x2,f1,f2,tol,m,q,xs,fs,funct
	external two_points_line, funct
	
	k=0
	
     	do while ( (abs((x1-x2)/2)) .gt. tol )
     	
    		call two_points_line(x1,f1,x2,f2,m,q)
     	
     		xs = - q / m
		fs = funct(xs)
		
		if ( fs .eq. 0 ) exit
		if ( (f1*fs) .lt. 0 ) x2=xs
		if ( (f1*fs) .gt. 0 ) x1=xs
	
		k=k+1
		if ( k .eq. 10000) exit
	
	enddo
	
	return
	end
	
!__________________________________________________________________


!	Solution calculation by bisection method


!	IN	x1	Left interval value
!	IN	x2	Right interval value
!	IN	tol	Tolerance
!	OUT	xs	Solution

	
	subroutine bisection(x1,x2,tol,xs)
	integer k
	real*16 x1,x2,f1,f2,tol,xs,fs,funct
	external funct
	
	k=0
	
!	Average value of [x1;x2]
	xs = (x1+x2) / 2
     	fs=funct(xs)
!	Initial f(x1;x2) range
	f1=funct(x1)
	f2=funct(x2)
	
     	do while ( abs(x1-x2)/2 .gt. tol )

     		xs = (x1+x2) / 2
     		fs=funct(xs)
     		
     		if ( (fs*f1) .lt. 0 ) then
     			x2=xs
     			f2=funct(x2)
     		else if ( (fs*f1) .gt. 0 ) then
     			x1=xs
     			f1=funct(x1)
     		else if ( fs .eq. 0 ) then
     			exit
     		endif
     		
     	 
		k=k+1
		if ( k .eq. 10000) exit
	
	enddo
	
	return
	end
	
!__________________________________________________________________


!	Solution calculation by Newton method


!	Initial variables
!	IN	m	Maximum number of iterations
!	IN	tol	Tolerance
!	IN	xs	Initial value
!	Final variables
!	OUT	xs	Solution
	
	
	subroutine newton(m,tol,xs) 
	implicit none 
  	real*16 tol,xs,fs,ds,funct,deriv
  	external funct,deriv
	integer m,n
	n=0
	! Get y and y1
	
	fs = funct(xs)
    	ds = deriv(xs)
    	
	do while ( abs(fs/ds) .gt. tol )
	
	fs = funct(xs)
    	ds = deriv(xs)
	
	n=n+1
	if ( n .ge. m ) then
		print *,"Maximum number of iterations reached, no solution found"
		exit
	endif
    	
!	Update xs value
  	xs=xs-(fs/ds)
  	
  	enddo
	
	return
	end
	
	
!__________________________________________________________________

!	Zero localization subroutine

!	Initial variables
!	IN	x1	Initial left interval value
!	IN	x2	Initial right interval value
!	Final variables
!	OUT	x1	Final left interval value
!	OUT	x2	Final right interval value


	subroutine zeroes_finder(x1,x2)
	implicit none 
	real*16 x1,x2,x01,x02,f1,f2,factor,funct
	integer i,k
	external funct
	parameter ( factor = 0.1, k = 50 )

!	Saving input values
	x01 = x1
	x02 = x2
	f1 = funct(x1)	
	f2 = funct(x2)
	
	do i = 1,k
	
	if ( ( f1 * f2) .lt. 0 ) go to 3
	
	if ( abs(f1) .lt. abs(f2) ) then
		x1=x1-factor*(x2-x1)
		f1=funct(x1)
	else
		x2=x2+factor*(x2-x1)
		f2=funct(x2)
	endif
	
	enddo
	
3	return
	end
		

