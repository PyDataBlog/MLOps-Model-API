module mCoulomb

use mGlobal

implicit none

type tCoulomb
  real(rb) :: alpha = 0.2_rb
  procedure(damping_model), pointer :: compute => null()
  contains
    procedure :: setup => tCoulomb_setup
    procedure :: damping_none => tCoulomb_damping_none
    procedure :: damping_debye => tCoulomb_damping_debye
    procedure :: damping_gauss => tCoulomb_damping_gauss
    procedure :: damping_erfc => tCoulomb_damping_erfc
end type tCoulomb

interface
  subroutine damping_model( me, r, v, f )
    import :: rb, tCoulomb
    class(tCoulomb), intent(in)  :: me
    real(rb),        intent(in)  :: r
    real(rb),        intent(out) :: v, f
  end subroutine damping_model
end interface

contains
  !-------------------------------------------------------------------------------------------------
  subroutine tCoulomb_setup( me, model )
    class(tCoulomb), intent(inout) :: me
    character(*),    intent(in)    :: model
    select case (model)
      case ("none"); me%compute => tCoulomb_damping_none
      case ("debye"); me%compute => tCoulomb_damping_debye
      case ("gauss"); me%compute => tCoulomb_damping_gauss
      case ("erfc"); me%compute => tCoulomb_damping_erfc
      case default; call error( "unknown Coulomb damping function:", model )
    end select

  end subroutine tCoulomb_setup
  !-------------------------------------------------------------------------------------------------
  subroutine tCoulomb_damping_none( me, r, v, f )
    class(tCoulomb), intent(in)  :: me
    real(rb),        intent(in)  :: r
    real(rb),        intent(out) :: v, f
    v = 1.0_rb/r
    f = v*v
  end subroutine tCoulomb_damping_none
  !-------------------------------------------------------------------------------------------------
  subroutine tCoulomb_damping_debye( me, r, v, f )
    class(tCoulomb), intent(in)  :: me
    real(rb),        intent(in)  :: r
    real(rb),        intent(out) :: v, f
    real(rb) :: ar
    ar = me%alpha*r
    f = 1.0_rb/r
    v = exp(-ar)*f
    f = f*(1.0_rb + ar)*v
  end subroutine tCoulomb_damping_debye
  !-------------------------------------------------------------------------------------------------
  subroutine tCoulomb_damping_gauss( me, r, v, f )
    class(tCoulomb), intent(in)  :: me
    real(rb),        intent(in)  :: r
    real(rb),        intent(out) :: v, f
    real(rb) :: ar2, rinv
    ar2 = (me%alpha*r)**2
    rinv = 1.0_rb/r
    v = exp(-ar2)*rinv
    f = (1.0_rb + 2.0_rb*ar2)*v*rinv
  end subroutine tCoulomb_damping_gauss
  !-------------------------------------------------------------------------------------------------
  subroutine tCoulomb_damping_erfc( me, r, v, f )
    class(tCoulomb), intent(in)  :: me
    real(rb),        intent(in)  :: r
    real(rb),        intent(out) :: v, f
    real(rb) :: ar, rinv
    ar = me%alpha*r
    rinv = 1.0_rb/r
    f = exp(-ar*ar)*rinv
    v = 1.0_rb / (1.0_rb + 0.3275911_rb*ar)
    v = v*(0.254829592_rb + v*(-0.284496736_rb + v*(1.421413741_rb + &
        v*(-1.453152027_rb + v*1.061405429_rb))))*f
    f = v*rinv + 1.12837916709551*me%alpha*f
  end subroutine tCoulomb_damping_erfc
  !-------------------------------------------------------------------------------------------------
end module mCoulomb
